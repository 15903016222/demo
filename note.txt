零、C语言知识点
    1. 关键字：
        static/volatile/const/extern/register/auto
        static作用：
            限制作用域
            限制变量的存储域
            在c语言中，static主要不在于作用域，而在于存储方式。
                static指的是内部，作用域也就是该文件的内部使用
            在c++中，基本上与c中的作用相同，不在于作用域，而在于存储方式。
                static修饰的变量和函数指属于类，不属于类的实例化对象

        volatile作用：
            volatile是"易变"的意思
            volatile是告诉编译器修饰的变量可能随时改变，
                因此编译器每次读取这个变量的值时，都去变量所在的地址读取，
                避免编译器对变量的优化。在嵌入式中经常用到，涉及到内存的
                物理地址读取值或者状态寄存器的读取，都要使用volatile修饰
                避免读取该地址的值时，编译器将其优化掉。

        const作用：
            const修饰变量为只读变量，与全局/局部变量无关，只是数据属性只读

        extern作用：
            extern是指声明修饰的变量在其他的文件中有定义，
                或者说解释为外部变量的引用

        register作用：
            register修饰的变量是指该变量会频繁的修改，建议修饰的变量
                可以存储在cpu的寄存器中，而不是存储在内存中，这种作用也就决定了
                修饰的变量是有一定的限制。存储在全局的变量的不能使用register修饰
                register修饰的变量不能使用&取变量的地址。

        auto作用：
            修饰的变量是自动变量，也是只能修饰局部变量。

        指针数组、数组指针、函数指针、指针函数
        常用的就是字符串的相关操作与字符串的变量存储位置

一、数据结构

1.自我介绍
   马如忠  Maruzhong/ruzhong Ma
   小马哥
   marz@tedu.cn

2.学习方法
  (1)课堂以听懂为主，尽量记笔记和代码；
  (2)程序员是代码喂出来的；
  (3)永久性作业：苦练指法；

3.课程简介
(1)数据结构
   栈、队列、链表、二叉树
(2)算法
   2种查找算法 + 4种排序算法
(3)课程时间
   理论时间：4天左右
   实际时间：5天左右
(4)注意事项
   重点理解数据结构的特性以及算法的思想
----------------------------------------------------------
今天内容：
   (1)数据结构的概念和分类
   (2)栈的基本特征和基本操作

1.数据结构的概念和分类
如：
   编程实现输入5个学生成绩并计算总成绩和平均成绩？？？
   int scores[5];
   int i1,i2,i3,i4,i5;

1.1 基本概念
    在计算机中，数据结构就是指数据在计算机中的存储和组织形式，也就是一种或者多种特定关系的数据的集合；
    一般来说，数据结构的选择会直接影响到程序的执行效率(时间复杂度)和存储效率(空间复杂度);
    计算机程序 = 数据结构 + 算法；

1.2 数据结构的三个层次
(1)逻辑结构
   - 主要描述数据元素之间的逻辑关系；
(2)物理结构
   - 主要描述数据元素在计算机中的存储形式，也就是位置关系；
(3)运算结构
   - 主要描述数据结构的实现方式以及基本特征；

1.3 逻辑结构的分类
(1)集合结构
   - 主要描述所有数据元素都属于一个整体，不强调数据元素之间的关系；
   - CSD1602系列班
   - 2 3 5 7 11 13 17 ...  统称为 质数/素数
   - 找出1 ~ 200之间的素数(质数)

(2)线性结构
   - 主要描述数据元素之间存在一对一的前后关系；
   - 该结构中有且只有唯一的首元素；
   - 该结构中有且只有唯一的尾元素；
   - 除首元素之外，结构中的每一个元素有且只有一个前趋元素；
   - 除尾元素之外，结构中的每一个元素有且只有一个后继元素；
如：
   等公交/地铁时排的队伍、手链

(3)树形结构
   - 主要描述结构中的数据元素之间存在一对多的父子关系；
   - 该结构中存在唯一的根元素，也就是起始元素；
   - 其中该结构中顶端的元素叫做叶元素；
   - 除了根元素之外，结构中的每个元素有且只有一个前趋元素；
   - 除了叶元素之外，结构中的每个元素可以拥有一个或多个
     后继元素；
如：
   树、家谱

(4)图形结构/网状结构
  - 主要描述数据元素之间存在多对多的交叉映射结构；
  - 该结构中的每个元素都可以有多个前趋和多个后继元素；
  - 该结构中的任意两个元素之间都可以建立关联；
如：
  蜘蛛网、球拍、铁路图

1.4 物理结构的分类
(1)顺序结构
  - 主要描述采用一组连续的存储单元依次存储逻辑上相邻的各个元素，如果每个元素都具有相同的属性，则每个元素占用的存储空间相同；
  - 物理结构中的顺序结构可以采用C语言中的数组类型加以描述；

思考：
   该结构有什么优点以及缺点？？？
优点：
   a.支持下标访问，实现随机访问也比较方便；
   b.除了申请存储数据元素本身之外的存储空间，不需要额外的
   存储空间来表达数据元素之间的逻辑关系，因此比较节省内存；

缺点：
   a.申请连续的存储空间时需要预知元素的个数来确定存储空间的大小，若太小则可能不够，若太大则可能造成浪费；
   b.要求申请连续的存储空间，导致小块空闲区域无法有效利用，因此整个内存空间的利用率比较低；
   c.当插入/删除元素时，可能会导致大量数据元素的移动，因此执行效率比较低；

(2)链式结构
  - 主要描述采用一组地址不连续的存储单元来依次存放各个元素，不保证逻辑上相邻的元素在物理位置上也相邻；
  - 为每个元素构造一个节点，而节点中的内容包括两部分：存储数据元素本身 + 记录下一个节点的首地址；
  - 该结构无法使用C语言中的数据类型加以描述，因此需要程序员手动编码去实现该结构；

思考：
   该结构有什么优点和缺点呢？？？
优点：
   a.不需要预知元素的个数，而是使用动态内存为每一个元素构造节点或者释放节点；
   b.不需要申请连续的存储空间，因此空间利用率比较高；
   c.插入/删除元素时比较方便，不需要移动其他元素的位置；
缺点：
   a.不支持下标访问，实现随机访问也不方便；
   b.除了申请存放数据元素本身的存储空间之外，还需要申请额外的存储空间表达数据元素之间的逻辑关系，也就是记录下一个节点的地址，因此比较消耗内存空间；

1.5 逻辑结构和物理结构之间的关系
   每种逻辑结构采用何种物理结构来实现并没有具体的规定，通常根据实现的难易程序，以及在时间复杂度和空间复杂度等方面的考虑，来选择合适的物理结构，也不排除同一种逻辑结构需要使用多种物理结构实现的可能；

1.6 运算结构
   主要描述数据结构的创建、销毁、增删改查以及相关的算法使用

2.栈(Stack)的基本概念和基本操作
2.1 基本概念
   栈就是一种具有后进先出特性的数据结构，简称为LIFO
   （last in first out）
   栈是只能在一端进行增删操作的数据结构，该位置叫做栈顶；
   栈属于逻辑结构中的线性结构；

2.2 基本操作
   创建(stack_create)、销毁(stack_destroy)、判断是否为空(stack_empty)、判断是否为满(stack_full)、入栈(stack_push)、出栈(stack_pop)、查看栈顶元素值(stack_peek)、计算栈中有效元素的个数(stack_size)、遍历栈中所有元素(stack_travel)；

2.3 使用顺序结构实现栈的基本操作

作业：
   编程实现顺序结构栈中的基本操作；
明日预报：
   (1)栈
   (2)队列

复习：
1.数据结构的概念和分类
1.1 基本概念
   数据结构就是指对数据在计算机中的存储和组织形式的描述，也就是具有一种或者多种特定关系的数据集合；
   通常情况下，数据结构的选择会直接影响到程序的执行效率(时间复杂度)和存储效率(空间复杂度)；
   计算机程序 = 数据结构 + 算法

1.2 数据结构的三个层次
   逻辑结构   物理结构   运算结构

1.3 逻辑结构的分类
(1)集合结构 - 主要描述所有数据元素都属于一个总体；
(2)线性结构 - 主要描述数据元素之间具有一对一的前后关系；
(3)树形结构 - 主要描述数据元素之间具有一对多的父子关系；
(4)网状结构 - 主要描述数据元素之间具有多对多交叉映射结构；

1.4 物理结构的分类
(1)顺序结构
   - 采用一组地址连续的存储单元依次存储逻辑上相邻的各个元素
   - 该结构可以借助C语言中的数组类型加以描述；
优点：
   a.支持下标访问，实现随机访问比较方便；
   b.除了申请存储数据元素本身的存储空间之外，不需要申请额外的存储空间来表达数据元素之间的逻辑关系，因此节省内存空间；

缺点：
   a.需要预知元素的个数来确定存储空间的大小；
   b.连续的存储空间导致内存空间的利用率比较低；
   c.插入/删除元素时，可能会导致大量元素的移动；

(2)链式结构
   - 采用一组地址不连续存储单元依次存储逻辑上相邻的各个元素
   - 为每个元素都构造了一个节点，主要包括：存储数据元素 +
     下一个节点的地址；
   - 无法使用C语言中数据类型加以描述，因此需要手动编码实现
   - 优点和缺点 与 顺序结构 相反

1.5 逻辑结构和物理结构的关系
1.6 运算结构

2.栈的基本概念和基本操作
2.1 基本概念
   栈本质就是一种具有后进先出特性的数据结构
   LIFO - last in first out
   栈是一种只能在一端进行增删操作的数据结构，该位置叫做栈顶
   栈是属于逻辑结构中的线性结构；

2.2 基本操作
   创建、销毁、... ...

2.3 使用顺序结构实现栈的基本操作

作业：
--------------------------------------------------------
今天内容：
   (1)栈
   (2)队列

1.栈
1.1 使用链式结构来实现栈的基本操作
1.2 实际应用
    可以用于小鼠走迷宫游戏等场合中；

作业：
   (1)将文件03stack_list.c拆分为3个文件：stack_list.h stack_list.c main.c，将这3个文件放到目录stack_list中，编写Makefile文件进行编译链接；

明日预报：
   (1)队列
   (2)链表

复习：
1.栈
1.1 使用链式结构实现栈的基本操作
1.2 实际应用
    主要用于小鼠走迷宫游戏等场合中；

作业：
-------------------------------------------------------
今天内容：
   (1)队列
   (2)链表

1.队列(Queue)
1.1 基本概念
   队列就是一种具有先进先出特性的数据结构，简称为FIFO；
   (first in first out)
   队列是一种可以在两端进行增删操作的数据结构；
   其中插入元素的端点叫做后端，也就是队尾；
   其中删除元素的端点叫做前端，也就是队首/队头；
   队列属于逻辑结构中的线性结构；

1.2 基本操作
   创建(queue_create)、销毁(queue_destroy)、判断队列是否为空(queue_empty)、判断队列是否为满(queue_full)、入队(queue_push)、遍历队列中所有有效元素(queue_travel)、计算队列中有效元素的个数(queue_size)、查看队列中队首元素值(queue_front)、查看队列中队尾元素值(queue_back)、出队(queue_pop)、清空队列中所有元素(queue_clear)；

1.3 使用顺序结构实现队列的基本操作
1.4 使用链式结构实现队列的基本操作
1.5 实际应用
    可以用于打印机打印任务的控制、银行取号系统等；

作业：
   (1)拆分02queue_arr.c文件和03queue_list.c文件，编写Makefile文件进行编译链接;

明日预报：
   (1)链表
   (2)二叉树

复习：
1.栈
1.1 使用链式结构实现栈的基本操作
1.2 实际应用
    主要用于小鼠走迷宫游戏等场合中；

作业：
-------------------------------------------------------
今天内容：
   (1)队列
   (2)链表

1.队列(Queue)
1.1 基本概念
   队列就是一种具有先进先出特性的数据结构，简称为FIFO；
   (first in first out)
   队列是一种可以在两端进行增删操作的数据结构；
   其中插入元素的端点叫做后端，也就是队尾；
   其中删除元素的端点叫做前端，也就是队首/队头；
   队列属于逻辑结构中的线性结构；

1.2 基本操作
   创建(queue_create)、销毁(queue_destroy)、判断队列是否为空(queue_empty)、判断队列是否为满(queue_full)、入队(queue_push)、遍历队列中所有有效元素(queue_travel)、计算队列中有效元素的个数(queue_size)、查看队列中队首元素值(queue_front)、查看队列中队尾元素值(queue_back)、出队(queue_pop)、清空队列中所有元素(queue_clear)；

1.3 使用顺序结构实现队列的基本操作
1.4 使用链式结构实现队列的基本操作
1.5 实际应用
    可以用于打印机打印任务的控制、银行取号系统等；

作业：
   (1)拆分02queue_arr.c文件和03queue_list.c文件，编写Makefile文件进行编译链接;

明日预报：
   (1)链表
   (2)二叉树

复习：
1.队列
1.1 基本概念
   队列就是一种具有先进先出特性的数据结构
   FIFO(first in first out)
   队列的插入和删除操作在两端执行；
   其中插入元素的一端，叫做队尾；
   其中删除元素的一端，叫做队首/队头；
   队列是属于逻辑结构中的线性结构；

1.2 基本操作
   创建、销毁、... ...

1.3 使用顺序结构实现队列的基本操作
1.4 使用链式结构实现队列的基本操作
1.5 实际应用
    可以用于打印机打印任务控制、银行取号系统等

作业：
-------------------------------------------------------
今天内容：
   (1)链表
   (2)二叉树

1.链表(List)
1.1 基本概念
   由若干个地址不连续的节点序列组成，不同的节点之间彼此通过指针连接组成的数据结构，叫做链表；

1.2 基本分类
(1)单向线性链表
   每个节点中除了存储数据元素本身之外，还需要保存下一个节点地址的指针，叫做后指针；
   其中链表中第一个节点，叫做头节点；
   指向头节点的指针叫做头指针；
   其中链表中最后一个节点，叫做尾节点；
   指向尾节点的指针叫做尾指针；
   尾节点中的后指针是一个空指针；

(2)单向循环链表
   与单向线性链表类似，所不同的是让尾节点的后指针指向头节点，首尾相接构成环状结构；

(3)双向线性链表
   每个节点中除了存储数据元素本身之外，还需要两个指针;
   其中一个用于记录下一个节点的地址，叫做后指针；
   另外一个用于记录前一个节点的地址，叫做前指针；
   头节点中的前指针和尾节点中的后指针都是空指针；

(4)双向循环链表
   与双向线性链表类似，所不同的是让尾节点的后指针指向头节点，让头节点的前指针指向尾节点，首尾相接构成环状结构；

(5)数组链表(了解)
   链表中的每一个元素都是一个数组，也就是由数组构成的链表；

(6)链表数组(了解)
   字符数组 - 数组中的每一个元素都是一个字符；
   整型数组 - 数组中的每一个元素都是一个整数；
   结构体数组 - 数组中的每一个元素都是一个结构体；
   指针数组 - 数组中的每一个元素都是一个指针；
   链表数组 - 数组中的每一个元素都是一个链表；

(7)二维链表(了解)
   二维数组 - 数组中的每一个元素都是一个一维数组的一维数组
   int arr[2][3] = {{1,2,3},{4,5,6}};
   二维链表 - 链表中的每一个元素都是一个一维链表的一维链表

1.3 编程实现单向线性链表的各种基本操作(重中之重)
扩展：
   a.实现返回单链表中中间节点的元素值；
   b.实现闭环/开环的基本操作；
   c.实现单链表中所有节点元素值的排序(从小到大)；
   d.实现将两个有序单链表合并成一个有序单链表；
   e.实现逆转单链表中所有节点的次序以及逆序打印所有节点元素
   ... ...

1.4 实际应用
   主要用于需要进行大量增删操作的场合中；
作业：
   (1)复习和理解单链表中的基本操作代码；
   (2)将01list.c文件拆分为多文件结构，编写Makefile文件；
明日预报：
   (1)二叉树
   (2)算法

复习：
1.链表
1.1 基本概念
   由若干个地址不连续的节点序列组成，不同的节点之间通过指针进行连接的数据结构，叫做链表；

1.2 基本分类
(1)单向线性链表
   每个节点中除了存储数据元素本身之外，还需要一个记录下一个节点地址的指针，叫做后指针；
   其中链表中最开始的节点叫做 头节点；
   指向头节点的指针叫做 头指针；
   其中链表中最末尾的节点叫做 尾节点；
   指向尾节点的指针叫做 尾指针；
   尾节点中的后指针是一个空指针；

(2)单向循环链表
   与单向线性链表类似，所不同的是将尾节点的后指针指向了头节点的地址，首尾相接构成环状结构；

(3)双向线性链表
   节点中除了存储数据元素本身之外，还需要两个指针；
   其中用于记录下一个节点地址的指针，叫做后指针；
   其中用于记录上一个节点地址的指针，叫做前指针；
   头节点中的前指针和尾节点中的后指针都是空指针；

(4)双向循环链表
   与双向线性链表类似，所不同的是将头节点的前指针指向了尾节点，尾节点的后指针指向了头节点，首尾相接构成环状结构；

(5)其他类型
   数组链表  链表数组  二维链表

1.3 编程实现单链表中的各种基本操作(重中之重)
1.4 实际应用
    主要用于需要进行大量增删操作的场合中；

作业：
-----------------------------------------------------------
今天内容：
   (1)二叉树
   (2)算法的概念和评价
   (3)常用的查找算法

1.二叉树(Binary Tree)
1.1 基本概念
   栈/队列/链表 属于逻辑结构中的线性结构；
   二叉树 属于逻辑结构中的树形结构；
   在计算机中，二叉树就是指每个节点最多只有两个子节点的树形结构，也就是最多只有两个分叉的树形结构；
   其中树形结构中的起始节点叫做根节点，除了根节点之外，其他每个节点有且只有一个父节点，而整棵树有且只有一个根节点；
   其中没有任何子节点的节点叫做叶子节点，叶子节点有父节点但是没有子节点；
   除了根节点和叶子节点之外，剩下的所有节点都叫做枝节点，枝节点有父节点也有子节点；
   如果该二叉树中每层节点个数都达到了最大值，并且所有枝节点都有两个子节点，这样的二叉树叫做满二叉树；
   如果该二叉树中除了最下面一层之外，其他每层节点个数都达到了最大值，并且最下面一层的所有节点都连续集中在左侧，这样的二叉树就叫做完全二叉树；

1.2 基本特征
   二叉树具有递归嵌套式的空间结构特征，因此采用递归的方法去处理二叉树问题，会使得处理算法更加简洁，而处理的方式如下：
   处理(二叉树)
   {
       if(二叉树为空) 直接处理；
       else
       {
           处理左子树(以左子节点为根节点的小二叉树)； -递归
           处理右子树(以右子节点为根节点的小二叉树)； -递归
           处理根节点；
       }
   }

1.3 存储结构
(1)顺序存储
   一般来说，从上到下，从左到右依次存放各个节点，对于非完全二叉树需要使用虚节点补成完全二叉树；

(2)链式存储
   一般来说，每个节点中包括三部分内容：一个记录数据元素本身 和 两个分别指向左右子节点地址的指针；
如：
   typedef struct node
   {
       int data;//记录数据元素本身
       struct node* left;//记录左子节点的地址
       struct node* right;//记录右子节点的地址
   }Node;

1.4 基本操作
   创建(binary_tree_create)、销毁(binary_tree_destroy)、插入新元素(binary_tree_insert)、遍历二叉树中所有元素(binary_tree_travel)、删除元素(binary_tree_delete)、修改元素(binary_tree_modify)、查找元素(binary_tree_find)、判断二叉树是否为空(binary_tree_empty)、判断二叉树是否为满(binary_tree_full)、查看二叉树中根节点元素值(binary_tree_root)、计算二叉树中有效元素个数(binary_tree_size)、清空二叉树(binary_tree_clear)

1.5 遍历方式
(1)先序遍历(DLR => data left right)
    先遍历根节点，再遍历左子树，最后遍历右子树，
    又叫做先根遍历；
(2)中序遍历(LDR => left data right)
    先遍历左子树，再遍历根节点，最后遍历右子树，
    又叫做中根遍历；
(3)后序遍历(LRD => left right data)
    先遍历左子树，再遍历右子树，最后遍历根节点，
    又叫做后根遍历；

1.6 有序二叉树
    满足以下三个条件的非空二叉树就叫做有序二叉树
    (1)如果左子树不为空，则左子树中所有节点的元素值都小于等于根节点元素值；
    (2)如果右子树不为空，则右子树中所有节点的元素值都大于等于根节点元素值；
    (3)左右子树内部依然满足上述规则；

实际应用：
    主要用于需要进行查找和排序的场合中，又叫做二叉查找树；

练习：
   使用以下数据组合成一棵有序二叉树，使用三种方法进行遍历
   50(根节点) 70 20 60 40 30 10 90 80
解析：
              50
          /       \
         20       70
        /  \      / \
       10  40    60 90
          /         /
         30        80
先序遍历结果是：50 20 10 40 30 70 60 90 80
中序遍历结果是：10 20 30 40 50 60 70 80 90
后序遍历结果是：10 30 40 20 60 80 90 70 50

1.7 编程实现有序二叉树的基本操作

作业：
   编程实现有序二叉树的其他基本操作；
明日预报：
   (1)算法的概念和评价
   (2)常用的查找算法
   (3)常用的排序算法

复习：
1.二叉树
1.1 基本概念
   二叉树就是指每个节点最多只有两个子节点的树形结构；
   其中最起始的节点，叫做根节点，除了根节点之外，其他每个节点都有且只有一个父节点；
   其中没有任何子节点的节点叫做叶子节点，有父节点没有子节点
   除了根节点和叶子节点之外，剩下的节点叫做枝节点；
   如果该二叉树中每层节点个数都达到了最大值，并且每个枝节点都有两个子节点，这样的二叉树叫做满二叉树；
   如果除了最下面一层之外，其他每层节点个数都达到了最大值，并且最下面一层节点都连续集中在左边，这样的二叉树叫完全二叉树；

1.2 基本特征
   处理(二叉树)
   {
       if(二叉树为空)  直接处理；
       else
       {
           处理左子树(以左子节点为根节点的小二叉树)，递归
           处理右子树(以右子节点为根节点的小二叉树)，递归
           处理根节点；
       }
   }

1.3 存储结构
(1)顺序存储
   一般来说，按照从上到下，从左到右的原则依次存放各个节点，但是对于非完全二叉树来说，需要使用虚节点补成完全二叉树；

(2)链式存储
typedef struct node
{
   int data;//记录数据元素本身
   struct node* left;//记录左子节点的地址
   struct node* right;//记录右子节点的地址
};

1.4 基本操作
   创建、销毁 ....

1.5 遍历方式
(1)先序遍历
   遍历根节点  =>  遍历左子树  => 遍历右子树
(2)中序遍历
   遍历左子树  =>  遍历根节点  => 遍历右子树
(3)后序遍历
   遍历左子树  =>  遍历右子树  => 遍历根节点

1.6 有序二叉树
  左子树所有节点  <= 根节点元素值 <=  右子树所有节点

实际应用：
   主要用于查找和排序的场合中；

1.7 编程实现有序二叉树的基本操作

作业：
---------------------------------------------------------
今天内容：
   (1)算法的概念和评价
   (2)常用的查找算法
   (3)常用的排序算法

1.算法的概念和评价
1.1 基本概念
   算法就是对解题方案准确而又完整的描述，是一系列清晰的指令
1.2 评价标准
(1)时间复杂度(重点)
   - 主要描述算法的时间消耗与问题规模之间的函数关系；
(2)空间复杂度
   - 主要描述算法的空间消耗与问题规模之间的函数关系；
(3)正确性
   - 主要描述算法的执行结果是否满足要求；
(4)可读性
   - 主要描述算法本身是否便于阅读；
(5)健壮性
   - 主要描述算法对非正常输入的反应和处理能力；
1.3 描述方式
   常见的算法描述方式主要有：自然语言、伪代码、结构化流程图、PAD图 ... ...

2.常用的查找算法
2.1 线性查找算法(顺序查找算法)
(1)算法流程
    使用目标元素与样本数列中的第一个元素起依次进行比较，如果找到了与目标元素相等的元素则表示查找成功，或者与所有的样本元素全部比较完毕，也没有找到与目标元素相等的元素，则表示查找失败；

(2)算法评价
    平均时间复杂度O(N),对样本的有序性不敏感；

2.2 二分查找算法(折半查找算法)
(1)算法流程
   假定样本数列中的所有元素从小到大依次进行排列，使用目标元素与样本数列中的中间元素进行比较，如果相等则查找成功；如果中间元素小于目标元素，则去中间元素的右边进行查找；如果中间元素大于目标元素，则去中间元素的左边进行查找，重复以上过程，直到找到满足条件的目标元素为止则表示查找成功，或者与需要比较的元素比较完毕，则表示查找失败；

(2)算法评价
   平均时间复杂度 O(logN)，要求样本元素必须有序；

3.常用的排序算法
3.1 冒泡排序算法(重点)
(1)算法流程
   a.比较相邻位置的元素，如果第一个元素比第二个元素大，则交换两个元素；
   b.从最开始的一对相邻位置元素到最后一对相邻位置的元素做同样的工作，经过这一步，最后的元素将是最大值；
  c.针对所有元素重复以上步骤，除了最后一个元素；
  d.持续每次对越来越少的元素重复以上步骤，直到没有元素需要交换为止；

(2)算法评价
   平均时间复杂度 O(N^2)，稳定，对样本的有序性非常敏感；

3.2 插入排序算法
(1)算法流程
   a.从第一个元素起，该元素可以认为已经有序；
   b.将下一个元素取出，在已经有序的元素中从后向前进行扫描和比较；
  c.如果左边元素大于取出的元素，则将左边元素赋值到下一个位置上，也就是右移；
  d.如果左边元素小于等于取出的元素，则将取出的元素插入到左边元素的右边；
  e.重复步骤b，直到处理完毕所有元素为止；

(2)算法评价
   平均时间复杂度O(N^2)，稳定，对样本的有序性非常敏感，但是赋值的次数比冒泡排序少，因此一般情况下略优于冒泡排序；

3.3 选择排序算法
(1)算法流程
   a.从第一个元素起依次取出，假定取出的元素是最小值，并且使用变量min来记录该元素的下标；
   b.使用min记录的最小值与后续所有元素依次进行比较，如果后续元素中有比min记录的最小值还小的元素，则重新记录该元素的下标到min中，也就是后续元素变成了min记录的最小值；
   c.直到min记录的最小值与后续所有元素比较完毕，交换min记录的最小值和最开始假定的最小值；
   d.重复以上过程，直到处理完毕所有元素为止；

(2)算法评价
   平均时间复杂度O(N^2)，不稳定，对样本的有序性不敏感，虽然比较的次数比较多，但是交换的次数比较少，因此一般情况下略优于冒泡排序；

3.4 快速排序算法
(1)算法流程
   a.从样本数列中选择中间元素作为基准值，单独保存起来；
   b.重组数列，将所有比基准值小的元素都放在基准值的左边，将所有比基准值大的元素都放在基准值的右边，与基准值相等的元素可以放在任意一边，这个过程叫做分组；
   c.以递归的方式对小于基准值的分组和大于基准值的分组分别进行分组排序；

(2)算法评价
   平均时间复杂度O(NlogN)，不稳定，对样本的有序性不敏感；

作业：
   复习和理解常用的查找算法和排序算法；
明日预报：
   (1)Unix/linux系统下的高级C编程


二、linux系统编程
    概述：
        1. 编程的编译过程
        2. 内存管理技术
        3. 文件、目录操作、文件锁
        4. 进程管理技术
        5. 进程间通讯技术
        6. 多线程编程
        7. 信号处理技术
        8. 网络编程(UDP/TCP)

    详述：
    1.课程简介
    1.1 课程阶段的简介
        Unix/Linux系统下的基本命令
     => 主要学习常用的基本命令 以及 vi的基本操作;
     => 依赖于Unix/Linux系统，部分命令和windows系统相同;

        标准c语言
     => 主要学习C语言的基本语法知识;
     => 不依赖于具体的操作系统，支持Unix/Linux/windows系统;

        数据结构和算法
     => 主要学习常见数据结构的特性以及常用的算法，理解思想;
     => 不依赖于具体的操作系统，支持Unix/Linux/windows系统;
     => 不依赖于具体的编程语言，支持c/c++/...

        Unix/Linux系统下的高级C编程
     => 主要学习操作系统提供的API函数以及操作系统的部分原理;
     => 依赖于具体的操作系统，支持Unix/Linux系统;
     => 主要是用C语言进行编程;
     => 理论时间：15天左右;

        目前主流的主机操作系统：Unix/linux/windows系列;
            windows系列：Xp系统，vista，win7，win8.1，win10
        目前主流的移动终端操作系统：android/ios/windows phone

    1.2 UC课程内容的简介
     1) Unix/Linux系统的概述以及概述基础;
     2) Unix/Linux系统下的内存管理技术;
     3) Unix/Linux系统下的文件管理以及目录操作;
     4) Unix/Linux系统下的进程管理技术;
     5) Unix/Linux系统下的信号处理技术;
     6) Unix/Linux系统下的进程间通讯技术;
     7) Unix/Lniux系统下的网络编程技术;
     8) Unix/Linux系统下的多线程开发技术;
    -----------------------------------------------------------
    今天的内容：
      1) Unix/Linux系统的简介
      2) gcc编译器的使用
      3) 多文件结构的编程
      4) 常用的预处理指令

    1. Unix/Linux系统的简介
    1.1 Unix系统的简介
        -在1969年左右，编写操作系统使用汇编语言，在编写和维护时非常不方便，贝尔实验室汤普逊研发了一门语言，叫做B语言，后期由丹尼斯-里奇做了修改和扩展，命名为New B语言，后来改名为C语言;
        - c语言诞生于1972年，产生于贝尔实验室，丹尼斯-里奇，至今在编程语言排行榜上占据重要的地位;
        - C/C++语言不属于任何一家公司;
        - Unix系统诞生于1970年，具有支持多用户多任务以及多种处理器的特性;

    1.2 Linux系统的简介
        - Linux系统是一款自由免费开放源代码的类Unix操作系统;
        - ubuntu系统每半年发布新版本，分别是4月，10月;

    2. gcc编译器的使用
    2.1 基本概念
        - gcc原名叫做GNU C Compiler(编译器)，支持对C语言的编译链接，后来对编译器进行了扩展，支持了更多的编程语言，如C++，object-c等等，改名为 GNU Compiler Collection(集合);
    2.2 基本功能
        - 目前主流的编程基本上都是使用高级语言进行，如C语言，但是高级语言编写的程序无法被计算机直接执行，需要先翻译成汇编语言，再翻译成机器指令，最后被计算机执行;
        - 为了实现高级语言代码到机器指令的翻译，则需要使用gcc编译器进行编译连接，而生成的过程分成以下四步：
     gcc xxx.c
     1) 预编译/预处理
        - 主要用于实现头文件的扩展以及宏替换;
        - -E选项 预处理选项;
        - -o选项  指定输出文件的名字;
     2) - 编译
        - 使用 -S选项
        - 主要用于将高级语言代码翻译成汇编语言，得到汇编文件;
     3) - 汇编
        - 使用 -c选项
        - 主要用于将汇编语言翻译成机器语言指令，得到目标文件;
     4) - 链接
        - 不使用任何选项 直接 cc xxx.o
        - 主要用于将目标文件和库文件进行链接，得到可执行文件;

    练习：
      cc -E 01hello.c -o 01hello.i
      cc -S 01hello.i/01hello.c
      cc -c 01hello.s/01hello.i/01hello.c
      cc 01hello.o/01hello.s/01hello.i/01hello.c

    2.3 常用的编译选项
     1) 熟练掌握的选项
        - fcc/cc -E  预处理，默认输出到屏幕，可以使用-哦来之顶输入文件(xxx.i);
        - gcc/cc -S  编译，将高级语言翻译成汇编语言文件(xxx.s);
        - gcc/cc -c  汇编，将汇编语言翻译成机器语言(xxx.o);
        - gcc/cc 编译连接，默认生成 a.out;
     2) 熟悉的选项
        - gcc/cc -std 指定执行的C标准(C89,C99);
        - gcc/cc -v   查看gcc的版本信息;
        - gcc/cc -Wall 尽可能的显示所有警告;
        - gcc/cc -Werror 将警告当作错误来处理;
     3) 了解的选项
        - gcc/cc -g  生成调试信息，可以进行GDB调试;
        - gcc/cc -x  显示指定源代码的编程语言;
        - gcc/cc -O  对代码进行优化处理
     4) 扩展的选项
        - man  命令/函数/gcc  - 查看相关的命令/函数/gcc编译器

    作业：安装引文词典  - 星际译王

    2.4 常见的编程相关的文件后缀
        .h - 头文件         .c  - 源文件
        .i - 预处理文件     .s  - 汇编文件
        .o - 目标文件
        .a - 静态库文件     .so - 共享库文件

    3. 多文件结构的编程
    3.1 多文件结构的主要组成
        .h  - 头文件，主要存放结构体的定义，函数的声明;
        .c  - 源文件，主要存放函数的定义;
        .a  - 静态库文件，主要对功能函数的打包;
        .so - 共享库文件，主要对功能函数的打包;
    3.2 头文件的详细组成
      1) 头文件的卫士
         #ifndef  _XXX_H
         #define  _XXX_H

         #endif  //_XXX_H
      2) 包含其他头文件
         #include <stdio.h>
         ... ...
      3) 进行宏定义
         #define PI 3.14
      4) 结构体的定义以及对数据类型起别名
         typedef struct node
         {
              int data;
              struct node *next;
         } Node;
      5) 外部变量和函数的声明
         extern int num;
         void show(void);

    作业：
       创建目录cilcle，在circle目录中编写以下三个文件
       circle.h  - 声明计算原型周长和面积的函数，函数名分别为：circle_length和circle_area;
       circle.c  - dingier圆形周长和面积的函数;
       main.c    - 定义main函数，调用计算周长河面几点函数，其中半径由用户手动输入



    预习：
       常用的预处理指令
       环境变量的概念和使用
       库文件的概念和使用


    复习：
    Unix和Linux的简介
    gcc编译器的使用
    多文件结构的编程
    -----------------------------------------------------------
    1. 常用的预处理指令
    1.1 复习标c学过的预处理指令
        #include ...  包含指定头文件
        #define  ...  进行宏定义
        #undef   ...  取消宏定义
        #if      ...  如果
        #ifndef  ...  如果没有定义
        #ifdef   ...  如果定义了
        #elif    ...  否则如果
        #else    ...  否则
        #endif   ...  结束如果
    1.2 学习常用的预处理指令
        #line 整数n  ---主要用于将下一行的行号标记为第n行，主要用于调试程序的场合中
        #warning  字符串
     =>  比啊是在编译阶段产生警告信息
        #error    字符串
     => 表示在编译阶段产生错误信息
     => 主要调试程序的场合中
    注意：
      #if 和 if 之间有什么区别？？？
        #if ---预处理指令，也就是在预编译阶段进行条件的判断;
        if  ---条件分支结构，也就是在运行阶段进行条件判断;

        #pragma GCC dependency 文件名
     => 主要用于关联两个文件的时间，如果指定文件名的最后一次修改时间晚于当前时间，则产生警告信息;
        #pragma GCC poison 标识符
     => 主要用于将后面指定的标识符设置成毒药，一旦使用则产生错误;
       #pragma pack(整数n)
     => 主要用于设置结构体的对齐和补齐方式;
     => 结构体的对齐和补齐方式就是为了存取数据方便，从而提高效率，但是这样会浪费内存空间，使用该指令可以节省内存;

    1.3 常见的预定义宏
        __FILE__ 主要获取当前文件的文件名信息   %s
        __LINE__ 主要用于获取当前宏所在的行号信息 %d
        __TIME__ 主要用于获取当前所在文件的最后一次编译时间 %s
        __DATE__ 主要获取当前所在文件的最后依次编译日期 %s

    2. 环境变量的概念和使用
    2.1 基本概念
        - 环境变量一般指在操作系统中用来指定操作系统运行环境的一些参数信息，也就是用于存放和系统/软件环境相关信息的特殊变量;
        - Path/PATH 本质上就是一种环境变量，里面可以存放可执行文件的路径信息，而一旦放入可执行文件的路径信息之后，就可以直接通过可执行文件的名称来启动该程序，而不再需要增加路径信息;

    2.2 环境变量的配置方法
     1) window Xp系统中的配置方法
        - 我的电脑 => 右击，选择属性 => 高级 => 环境变量 => 系统变量 => 找到Path，点击配置 => 在Ptah变量值的最后增加分号，再增加新路经 => 一路点击确定即可;
        - 其中分号是不同路径的分隔符，切忌不要删除Path变量的变量值内容;
     2) Linux 系统中的配置方法
        - 打开任意一个终端，执行以下指令：
              export PATH=$PATH;.
              $PATH  - 表示PATH变量原来变量值的内容
              :      - 表示不同路径之间的分隔符，相当于windows中的分号;
              .      - 表示当前目录，也就是a.out所在的目录
            执行上述指令之后，就可以直接通过a.out来执行文件，从而省略路径信息，次配置方法只对当前终端有效，为了使得环境变量的配置环境变量对后序打开的终端都有效，则按照以下步骤增加指令：
        vi ~/.bashrc文件，在文件的最后增加指令;
            export PATH=$PATH:.
        source ~/.bashrc   宝石使得配置文件
        ～  表示当前用户的主目录

    处理意外情况的方法：
        打开主目录，使用crtl + h的快捷键显示隐藏文件，找到.bashrc文件，使用鼠标右键选择文本编辑器的方式打开，进行修改后保存即可;

    2.3 编程相关的常用环境变量
        CPATH/C_INCLUDE_PATH  - 主要用于存放c语言头文件的路径信息
        CPLUS_INCLUDE_PATH    - 主要用于存放C++语言头文件的路径信息
        LIBRARY_PATH          - 主要用于存放库文件的路径信息，解决编译链接时找不到库文件的问题
        LD_LIBRRY_PATH        - 主要用于存放共享库文件的路径信息，解决运行时找不到库文件的问题

    练习：
      创建目录add，在目录add中编写三个文件：
       add.h    - 声明计算两个int 类型参数并返回的函数，含糊素名为add_int
       add.c    - 调用定义上述函数
       main.c   - 调用add_int函数，参数指定，不用输入，将计算的结果打印出来

    2.4 头文件的查找方式
     1) - #include <>    --- 表示从系统默认路径中查找该头文件
        - 当前系统中默认的路径是：/usr/include
        - 使用命令whereis stdio.h来查找该头文件的位置
     2) - #include ""    --- 表示优先从当前目录中进行查找，查找不到时也会去系统默认路径中进行查找
     3) 配置环境变量CPATH/C_INCLUDE_PATH，按照以下代码进行配置：
        export CPATH=$CPATH:..(头文件所在的路径信息)
     4) 通过编译选项来指定头文件的路径信息
        gcc/cc xxx.c -I 头文件路径
        gcc/cc *.c -I ..

    注意：
         方式1),方式2)的缺点在于：一旦头文件的路径发生了改变，则必须修改源代码才能解决问题;
         方式3)的缺点在于：当多个项目被创建时，配置环境变量可能会引起冲突问题;
         方式4)既不需要修改源代码，也不会引起多个项目之间的冲突，因此推荐使用该方法;



    作业：
      1) 编程打印常见的预定义宏
      2) 使用标c中文件操作函数实现学生信息管理系统;
    增删改查功能在函数内部实现(truncate)


    预习：
      库文件的概念和使用
      c语言中的错误处理


    复习：
      常用的预处理指令
      查环境变量的概念和使用
    -----------------------------------------------------------
    今天的内容：
     库文件的概念和使用
     c语言中的错误信息

    1.库文件的概念和使用
      - 在大型项目中，如果每个功能函数都放在独立的.o文件中，则项目的管理是灾难问题，因此需要库文件来解决该问题;
      - 一般来说，可以按照功能模块将若干个.o文件打包成一个或多个库文件，编写者只需要提供库文件和头文件即可;
      - 库文件主要分为两大类：静态库文件 和 共享库文件

    1.1 静态库的基本概念和特性
     1) 基本概念
        - 静态库本质上就是由若干个.o文件打包生成的.a文件;
        - 链接静态库的本质就是将被调用的代码指令复制到调用模块中去，体现在最终的可执行文件中;

     2) 基本特性
        - 静态库占用空间比较大，库中代码一旦修改则必须重新链接;
        - 使用静态库的代码在运行执行文件时可以脱离静态库，并且执行效率比较高;

     注意：
       gcc/cc -static xx.c    ---表示强制要求链接静态库
       ldd a.out       ---表示查看a.out所链接的共享库信息

    1.2 静态库的生成和调用步骤
     1) 生成步骤：
        a.编写源代码文件xxx.c  如：vi add.c
        b.只编译不链接生成目标文件 xxx.o  如：cc -c add.c
        c.生成静态库
          ar -r/*插入，若存在则更新*/ lib库名.a 目标文件
          ar -r libadd.a add.o
     2) 调用步骤
        a.编写测试源代码文件xxx.c，如：vi main.c
        b.只编译不链接生成目标文件xxx.o，如：
          cc -c main.c
    注意：
      其中libadd.a  静态库文件名;
      其中去掉lib和.a之后剩下的add叫做库名;
        c.链接静态库文件，链接的方式有以下三种：
          1) 直接链接
             cc 目标文件 静态库文件名
             cc main.o libadd.a
          2) 使用编译选项进行链接
             cc 目标文件 -l 库名 -L 库文件所在路径
             cc main.o -l add -L .
          3) 配置环境变量LIBRARY_PATH
             export LIBRARY_PATH=$LIBRARY_PATH:.

    1.3 共享库的基本概念和特性
     1) 共享库本质上就是由若干个目标文件(.o)打包生成.so文件
        链接共享库和静态库最大的不同就是，链接共享库时并不需要将被调用的代码指令复制到调用模块中，而仅仅是将被调用的代码指令在共享库中的相对地址嵌入到调用模块中;
     2) 基本特性
        共享库占用空间比较小，即使修改了库中的代码，只要接口保持不变，则不需要重新链接;
        使用共享库的代码在运行时需要依赖共享库，执行效率相对比较低;
        目前主流的商业开发中大多数采用共享库;

    1.4 共享库的生成和调用文件
        生成步骤
     1) 编写源代码xxx.c 如：vi xxx.c
     2) 只编译不链接生成目标文件xxx.o 如：
        cc -c -fpic/*生成位置无关码 小模式*/ add.c
     3) 生成共享库文件
        cc -share/*共享的*/ 目标文件 -o lib库名.so
        cc -share add.o -o libadd.so

        调用步骤
        a.编写测试源代码文件xxx.c，如：vi main.c
        b.只编译不链接生成目标文件xxx.o，如：
          cc -c main.c
       注意：
       其中libadd.so  共享库文件名;
       其中去掉lib和.a之后剩下的add叫做库名;
        c.链接共享库文件，链接的方式有以下三种：
          1) 直接链接
             cc 目标文件 共享库文件名
             cc main.o libadd.so
          2) 使用编译选项进行链接
             cc 目标文件 -l 库名 -L 库文件所在路径
             cc main.o -l add -L .
          3) 配置环境变量LIBRARY_PATH
             export LIBRARY_PATH=$LIBRARY_PATH:.
    注意：
      在使用共享库文件时，需要配置环境变量LD_LIBRARY_PATH来解决运行时找不到库文件的问题，具体配置方法如下：
      export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.

    注意：
      当静态库文件和共享库文件同时存在时存在并且库名相同时，采用上述第二种，第三种链接方式进行链接时，编译器会优先选择共享库进行链接，如果希望链接静态库则使用-static选项进行要求;

    1.5 共享库的动态加载
       #include <dlfcn.h>
     1) dlopen函数
        void *dlopen(const char *filename,int flag);
        第一个参数：字符串形式的共享库文件名
        第二个参数：具体的操作标志，加载方式：
         RTLD_LAZY  -延迟加载
         RTLD_NOW   -立即加载
        返回值：成功返回一个句柄（地址）信息，调用失败返回空
    函数功能：
        主要用于将参数filename指定的共享库文件加载到内存中

        void *dlsym(void *handle,const char *symbol);
        第一个参数：具体的句柄信息（dlopen的返回值）;
        第二个参数：字符串形式的符号名，这里指函数名;
        返回值：成功返回函数的地址，失败返回NULL;
        函数功能：主要用于查找handle指向共享库中名字symbol的函数在内存中的地址信息;

        dlclose函数
        int dlclose(void *handle);
        这个函数的功能，主要是关闭/卸载参数指定的共享库，参数为dlopen的返回值，成功返回0,失败返回!0;

        dlerror函数
        char *dlerror(void);
        函数的功能用于获前取调用dlopen()/dlsym()/dlclose()含糊素之后产生的错误信息并返回，如果上述函数没有产生错误，则返回NULL;



    作业：
      打印空心菱形，实心菱形
      共享库，静态库，的生成调用


    c语言中的错误处理
    环境表的和、概念和使用
    内存管理技术

    1.c语言中的错误处理
    如：
      int main(void)
      {
          if(...)
          {
               return -1;//表示程序出错结束
          }
          return 0;//表示程序正常结束
      }

    1.1 c语言中的错误表现形式(错了么？)
        - 一般来说，c语言中通过函数的返回值来表示函数调用的是否出错，而返回值的一般表现形式如下：
        (1) 对于返回值类型是int类型的函数来说，并且函数的计算结果不可能是负数时，一般返回-1表示出错，其他数据表示正常结束
        (2) 对于返回值是int的函数来说，但是函数的计算结果可能是负数时，使用指针作为函数的形式参数，将函数的计算结果带出去，而返回值专门用于表示是否出错，习惯上使用0表示正常结束，-1表示出错;
        (3) 对于返回值类型是指针的函数来说，一般使用返回NULL表示函数出错，其他数据表示正常;
        (4) 对于不考虑是否出错的函数来说，返回值类型用void即可;

    练习：
        按照上述4个规则编写以下4个功能函数
        1. 生成1～10之间的随机数并返回，如果随机数是5则返回错误;
        2. 比较两个int类型的的大小并返回最大值，相等返回错误;
        3. 判断传入的字符串是否为"error"，如果是则返回错误，否则返回"ok";
        4. 打印传入的字符串即可;

    1.2 错误编号(为什么错了？？？)
        判断函数是否调用失败，根据函数的返回值进行判断;
        当函数一旦调用失败时，希望直到失败的原因则查看errno的值;
        errno本质就是一个int类型的全局变量，当库函数调用失败时，会自动设置errno的值来表示错误的原因;
        #include <errno.h>  //实现了对errno的外部声明，并且包含了一些其他头文件，里面拥有errno的取值范围等信息;

        /etc/passwd  --- 主要包含了账户的信息;
        tedu01:  x  :  1001  :   1001  :tedu01,,,
        用户名：密码：用户编号：用户组编号：注释信息
        :/home/tedu01:/bin/bash
        ： 用户主目录：shell的类型
        /etc/shadow  --- 主要包含了账户的密码及管理信息;

    1.3 错误信息(对队伍编号的翻译)
        (1) strerror函数
        char *strerror(int errnum);
        函数功能：
        主要用于将参数指定的错误编号进行翻译，将翻译得到的字符串通过返回值返回;
        (2) perror函数
          #include <stdio.h>
          void perror(const char *s);
          函数功能：
          主要用于打印具体错误信息，参数指向的字符串会原样打印，紧跟着冒号，空格，错误信息以及自动换行;
        (3) printf函数(了解)
           printf("%m");  ---打印错误信息

    注意：
        不能直接使用error的数值来作为判度啊函数是否出错的一句，因为errno会保留之前的错误编号，野会随时发生改变，因此判断函数是否出错还是需要依据函数的返回值，而只有明确函数已经出错的情况下，可以一句error来获取错误的原因;

    2.环境表的基本概念和使用
    2.1 基本概念
        - 环境表本质就是环境变量的集合，每个进程内部都拥有一张独立的环境表信息，用于记录专属于该进程的环境信息;
        - 环境表就是一个以空指针作为结尾的字符指针数组，其中每个指针都指向一个格式为"变量名 = 变量值"的字符串，该指针数组的首地址保存在全局变量char **environ中，依次通过访问全局变量environ可以遍历整个环境表的信息;

    2.2 基本操作的相关函数
     1) getenv函数
        #include <stdlib.h>
        char *getenv(const char *name);
        函数的功能:
        主要用于根据参数指定的环境变量名来查找整个环境表，查找成功时，返回该变量名所对应的变量值，查找失败时返回NULL;
     2) setenv函数
          #include <stdlib.h>
          int setenv(const char *name, const char *value, int overwrite);

         第一个参数：字符串形式的环境变量名;
         第二个参数：字符串形式的环境变量值;
         第三个参数：是否修改的标志;
                    非0,表示修改;
                     0,表示不修改;
    返回值：成功返回 0; 失败返回-1;
         主要功能:
         主要用于修改/增加环境变量的值;

     3) unsetenv函数
        int unsetenv(const char *name);
        函数功能：
        主要用于从环境表中删除参数指定的环境变量，如果该环境变量不存在，则哈数调用成功，环境表没有变化;

     4) putenv函数
        int putenv(char *string);
        函数的功能
        主要用于增加或修改参数指定的环境变量，参数的格式为：name=value，当该变量不存在时则增加，否则失败;
        返回值：成功返回 0;失败返回非0;

     5) clearenv函数
        函数功能
        主要用于清空环境表中所有的环境变量对，并且让全局变量environ也置为空指针，成功返回 0,失败返回非0;

    2.3 main函数的原型(了解)
        int main(int argc,char *argv[],char *envp[])
    解析：
        argc  ---命令行参数的个数;
        argv  ---记录每个命令行参数的首地址;
        arvp  ---记录环境表的首地址;
    注意：
        优于历史原因，main函数中的第三个参数不一定被系统所支持，因此减一使用全局变量environ来访问环境表信息;

    明日预报：
        内存管理技术;

    复习：
      c语言的错误处理
      c语言中的错误表现形式（错了么）
      1.对于返回值为ingt类型的函数来说-1表示出错
      2.对于返回值为int类型来说，返回值肯呢个是负数，使用指针作为形式参数带出结果，返回值专门用于判错
      3.返回值为指针的雷顶函数来说，使用NULL比啊是错误
      4.对于不需要表示出错的
      错误的标号，为什么错了
      errno本质上就是int类型的全局变量，库函数调用出错是，自动设置errno的数值表达错误的原因
      #include <errno.h>
      passwd,账户的管理信息
      shadow，账户的密码信息
      错误信息，对错误编号的翻译
      strerror(errno)
      perror("")

    -----------------------------------------------------------
    今天的内容：
        内存的管理技术

    1.内存管理技术
    1.1 程序和进程的概念
        程序 - 主要指存放放在磁盘或硬盘上的可执行文件;
        进程 - 运行在内存中的程序;
        同一个程序可以同时对应多个进程;
    1.2 进程中的内存区域划分
      如：
        int num; //全局变量 默认初始值为0   BSS段
        int main()
        {
            int num; //局部变量 默认初始值为随机数   栈区
            return 0;
        }

     1) 代码区(Text)
        - 该区域主要用于存放具体的功能的代码，函数指针指向该区域;
     2) 只读常量区(Text)
        - 该区域主要用于存放常量字符串，const修饰的并且已经初始化的全局变量和静态局部变量，以及字面值(具体的数值);
     3) 全局区/数据区(Data)
        - 该区域主要用于存放没有const修饰的已经初始化的全局变量和静态局部变量;
     4) BSS段(Data)
        - 该区域主要存放没有const修饰也没有初始花的全局变量和静态局部变量;
        - 该区域会在main函数执行之前自动清零;
     5) 堆区(Heap)
        - 该区域主要用于由函数malloc()/calloc()/realloc()/free()函数操作的内存区域;
        - 该区域由程序员手动申请，手动释放;
     6) 栈区(Stack)
        - 该区域主要用于存放非静态的局部变量(包括函数的行参);
        - 该区域由操作系统自动管理;

    综上所述：
        按照进程中的内存区域按照从小到大依次排列的结果：代码区，只读常量区，全局区，BSS段，堆区，栈区;
        一般来说，其中堆区的内存地址按照从小到大进行分配，栈区的内存地址按照从大到小依次分配，以免区域的重叠;

    每个进程的内存分配：
       命令行参数
       环境表信息
       栈区

       堆区
       BSS段
       全局区/数据区
       只读常量区
       代码区

    1.3 常量字符串不同存放形式的比较(重点掌握)
        对于记录常量字符串的指针来说，指针指向的内容不可以改变，胆汁真的指向可以改变;
        对于记录常量字符串的字符数组来说，指针指向的内容可以改变，但是指针的指向不可以改变;
        对于指向一块动态内存来说，指针指向的内容和指针的指向都可以发生改变;

    1.4 虚拟内存管理技术(尽量理解)
        一般来说，在Lniux系统中采用虚拟内存管理技术来进行内存空间的管理，即：每个进程都可以拥有0～4G-1的内存地址空间(虚拟的并不是真实存在的)，由操作系统负责建立虚拟地址到真实物理内存/文件的映射，因此，不同进程中的地址空间看起来是一样的，但是所对应的真实物理内存/文件是不一样的
        其中0～3G-1 的地址空间 叫做用户空间
        3G～4G-1 之间的地址空间 叫做内核空间;
        而用户程序一般都运行在用户空间中，不能直接访问内核空间，不过内核提供了一些函数用于访问内核空间;
        内存地址的基本单位是字节，而内存映射的基本单位是内存页，目前主流的操作系统中一个内存页的大小是4kb(4096字节);
        1Tb = 1024Gb
        1Gb = 1024Mb
        1Mb = 1024Kb
        1Kb = 1024byte(字节)
        1byte = 8bit(二进制位)

    1.5 段错误的由来
     1) 试图去操作没有操作权限的内存空间时可能会引起段错误;
        如：试图修改只读常量区中的数据时会引起段错误;
     2) 试图使用没有经过映射的虚拟地址时可能会引起段错误;
        如：指定任意地址去访问里面的内容时;

    1.6 使用malloc函数申请动态内存
     1) 使用malloc函数申请动态内存时的注意事项
        使用malloc函数申请动态内存时，除了申请参数指定的动态内存空间之外，还可能申请额外的12个字节(一般原则)用于保存该动态内存块的管理信息，如：大小，是否空闲等信息;
        因此使用malloc函数申请的动态内存时，切忌不要越界访问，因为越界访问可能会破坏内存块的管理信息，从而导致段错误的结果;

     2) 使用malloc函数申请动态内存时的一般性原则
        一般来说，当使用malloc函数申请比较小块的动态内存时，操作系统一般会一次性映射33个内存页的地址空间，从而提高效率;
        #include <unistd.h>
        #include <sys/types.h>
        getpid()  - 主要用于获取当前进程的进程号;

        cat  /proc/进程号/maps  - 表示查看指定进程的内存映射情况;
        查看的最终结果是6列：地址范围，权限信息，设备编号，i节点编号，进程名称以及路径信息;

    1.7 使用free函数释放动态内存的一般原则
        一般来说，使用free函数释放多少则从映射的总量中减去多少，当所有的动态内存全部释放完毕后，操作系统依然会保留33个内存页，用以提高效率;


    练习：
        使用c语言中的错误表现形式编写以下两种功能
        1.实现计算参数指定文件的大小，并通过返回值返回，如果参数指定的文件打开时白，则返回错误;
        file_size()
        2.实现比较两个参数字符串的大小并返回最大值，如果相等则返回错误;
         string_compare()


    明日预报：
        1.内存管理
        2.文件管理

    今天的内容：
        内存的管理技术
        文件的管理

    1.内存管理技术
    1.1 常用的内存管理技术
     1) getpagesize函数
         #include <unistd.h>
         int getpagesize(void);
         函数的功能：
          主要用于获取当前系统中一个内存页的大小并返回;

     2) sbrk函数
        #include <unistd.h>
        void *sbrk(intptr_t increment);
        函数的功能：
         主要用于根据参数的数值来调整动态内存的大小，具体方式如下下：
         当increment > 0时，表示申请动态内存;
         当increment < 0时，表示释放动态内存;
         当increment = 0时，表示获取当前的动态内存的末尾地址 ;
        函数调用成功时返回调整之前的末尾地址，失败返回(void*)-1;

     注意：
       1.虽然sbrk函数既能申请动态内存，又能释放内存，但是申请内存的操作更方便一些;
       2.一般来说，使用sbrk函数申请比较小块的动态内存时，操作系统一次性映射1个内存页大小的地址空间，当sbrk函数申请的动态内存超过1个内存页时，则操作系统会再次映射1个内存页，当sbrk函数释放所有动态内存时，操作系统不会保留映射的地址空间，因此和malloc和free函数相比，更加节省内存空间，但是效率没有malloc和free函数高;

     3) brk函数
        #include <unistd.h>
        int brk(void *addr);
        函数功能：
         将动态内存的末尾位置调整到释放到参数指定位置，具体的调整方式如下：
         当addr > 动态内存原来的末尾地址时，表示申请动态内存;
         当addr < 动态内存原来的末尾地址时，表示释放动态内存;
         当adrr = 动态内存原来的末尾地址时，表示动态内存不变;

    注意：
      虽然brk函数既能申请内存又能释放内存，但是释放内存更加方便，因此一般情况下使用sbrk函数和brk函数搭配使用，sbrk函数专门用于申请内存，brk函数专门用于释放内存;

    练习：
      使用sbrk函数申请内存，brk函数释放内存首先申请一个int类型大小的存储空间存放数据66,在申请一个double类型大侠的存储空间，存放3.14,再申请10个字节大小的字符串空间存放数据"hello",最后打印上述数据内容，释放全部动态内存;

     4) mmap函数
        #include <sys/mman.h>
        void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);
     第一个参数：用于指定映射的起始地址，给NULL由系统内核指定;
     第二个参数：用于指定映射的大小;
     第三个参数：用于指定映射的权限信息：
                PROT_EXEC - 可执行
                PROT_READ - 可读
                PROT_WRITE - 可写
                PROT_NONE - 不可访问
     第四个参数：用于指定映射的标志位
                MAP_SHARED - 共享的，写入映射区的数据直接反映到文件中;
                MAP_PRIVATE - 私有的，写入到映射区的数据不会反映到文件中;
                MAP_ANONYMOUS - 表示映射到物理内存，忽略参数五，参数六;
     第五个参数：文件描述符，暂时给0即可;
     第六个参数：文件中的偏移量，暂时给0即可;
     函数功能：
       主要用于建立文件/设备到虚拟地址之间的映射;
     返回值:成功返回映射区域的首地址;
            失败返回MAP_FAILED((void*)-1);
     5) munmap函数
        #include <sys/mman.h>
        int munmap(void *addr, size_t length);
     函数功能：解除参数指定的映射区域;
     第一个参数：映射区的首地址，也就是mmap函数的返回值;
     第二个参数：映射区域的大小;

    1.2 内存管理函数之间的层次关系
        ... ...
            |
        标准c语言 => 使用malloc函数申请内存，使用free函数释放内存;
            |
        POSIX标准 => 使用sbrk函数申请内存，使用brk函数释放内存;
            |
        操作系统 => 使用mmap函数建立映射，使用munmap函数解除映射;
            |
        ... ...

    2.文件的管理
    2.1 基本概念
        - 在Linux系统中，几乎可以把所有的一切都看作文件，包括目录，输入/输出设备等;
        /dev/null  - 空设备文件;
    如：
      echo hello
     => 输出hello字符串;
      echo hello > a.txt
     => 将输出的字符串hello写入到文件a.txt中;
      cat a.txt
     => 输出hello字符串
      echo hello > /dev/null
     => 讲述出的字符串hello写入到文件/dev/null中，表示丢弃;
      cat /dev/null > a.txt
     => 表示清空文件a.txt中的内容;

    2.2 基本操作的相关函数(重中之重)
    -----------------------------------------------------------
        复习标c中的文件操作函数：
        fopen()/fclose()/fread()/fwrite()/fseek();
    -----------------------------------------------------------
    学习UC中的文件操作函数
        open()/close()/read()/write()/lseek();
     1) open函数
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <fcntl.h>
        int open(const char *pathname, int flags, mode_t mode);
     第一个参数：字符串形式的路径名：路径 + 文件名;
     第二个参数：具体的操作标志;
         必须包括以下访问权限中的一个：
            O_RDONLY  - 只读;
            O_WRONLY  - 只写;
            O_RDWR  - 可读可写;
         除此之外，还可以按位或以下的标志：
            O_APPEND  - 以追加的方式打开;
            O_CREAT - 文件不存在则创建，存在则打开;
            O_EXCL - 与O_CREAT搭配使用，若不存在则创建，存在则创建失败;
            O_TRUNC - 若文件存在，则清空文件中的内容;
     第三个参数：文件的权限信息;
         当创建新文件时，该参数可以指定新文件的权限信息
         如：0664 => rw-rw-r--;
            当大开一个已经存在的文件时，该参数可以忽略，不需要提供;
     返回值：成功返回新的描述符;失败返回-1;
     函数功能：
       主要用于打开/创建一个文件;

    注意：
        creat()函数
        creat() is equivalent to open() with flags equal to   O_CREAT|O_WRONLY|O_TRUNC.

    扩展：
        使用ls -l a.txt
          -       rw-      rw-        r--       1     tedu01
       文件类型 属主权限 属组权限 其他用户权限 硬连接数 属主名称
         6     4月 13 16:30    a.txt
     文件大小 最后一次修改时间 文件名称

    其中常见的文件类型有：
      - 表示普通规则文件
      d 表示目录文件
     ... ...
    其中文件的权限信息有：
     r  - 可读  4
     w  - 可写  2
     x  - 可执行 1
     -  - 没有此权限 0

     2) close函数
        #include <unistd.h>
        int close(int fd);
     函数的功能：
         主要用于关闭参数指定的文件描述符，以至于该文件描述不再关联任何一个文件，可以被再次使用;
     返回值：成功返回0;失败返回-1;

     3) read()函数
        #include <unistd.h>
        ssize_t read(int fd, void *buf, size_t count);
     第一个参数：文件描述符(open()函数的返回值)
     第二个参数：缓冲区的首地址(存到哪里去)
     第三个参数：期望读取的字节数
     返回值：成功返回读取到的字节数，0表示读取到了文件末尾;
             失败返回-1;
     函数功能：
         主要用于从指定的文件中读取数据到缓冲区;

     4) write()函数
        #include <unistd.h>
        ssize_t write(int fd, const void *buf, size_t count);
     第一个参数：文件描述符，open()函数的返回值
     第二个参数：缓冲区的首地址(写入的数据从哪里去)
     第三个参数：期望写入的数据大小
     返回值：成功返回实际写入的数据大小，返回0表示啥也没有写入;
             失败返回-1;
     函数功能：
         主要用于将指定的数据内容写入到指定的文件中;


    明天预报：
        文件的管理

    复习：
    1.内存管理技术
    1.1 常用的相关函数
       getpagesize() - 获取当前系统内存页的大小
       sbrk()/brk() - 用于调整内存大小
        mmap()/munmap() -建立或结束文件/设备到内存的设备
    1.2 内存管理函数之间的层次关系
        malloc/free
        sbrk/brk
        mmap/munmap

    2.文件的管理
    2.1 基本概念
        在linux系统中，几乎可以把所有的一切都看左文件
    2.2 基本操作(重中之重)
        open()/close()/read()/write()
    -----------------------------------------------------------
    今天的内容：
      文件的管理

    1.文件的管理
    1.1 文件操作的相关函数(重点掌握)
     1) lseek()函数
        #include <sys/types.h>
        #include <unistd.h>
        off_t lseek(int fd, off_t offset, int whence);
     第一个参数：文件描述符，open函数的返回值(调整那个参数);
     第二个参数：偏移量（调整多少字节）;
               正数  - 表示向文件末尾方向偏移;
                0    - 不偏移;
               负数  - 表示向文件开头方向偏移;
     第三个参数：起始位置（从什么地方开始偏移）;
               SEEK_SET  - 文件的起始位置;
                         - 向后偏移合理，向前偏移不合理(特殊情况不考虑);
               SEEK_CUR  - 文件的当前位置;
                         - 向前向后都合理（特殊情况不考虑）
               SEEK_END  - 文件的末尾位置;
                         - 向前向后偏移都合理(特殊情况不考虑)
     返回值：成功返回当前位置距离文件爱呢开头位置的偏移量;
             失败返回(off_t)-1;
     函数功能：
         主要用于调整指定文件中的读写位置;
     注意：
       当把文件的读写位置调整到SEEK_END后面的位置再写入数据时，数据也是可以写入的，只是中间有一块区域空间，该现象叫做文件的空洞现象，该区域会计算到文件大小中，但是mwiyou有效数据，获取数据时得到的是'\0';



     扩展：
       如何获取一个文件的大小信息呢？
         1.使用fseek函数调整文件读写位置到末尾，使用ftell函数返回;
         2.使用lseek函数调整文件读写位置到末尾，返回值就是文件的大小;
    注意：打开文件，默认文件的读写位置是开头位置;

    1.2 标c与uc的文件操作函数比较
    -----------------------------------------------------------
        由下边练习的程序的运行结果可知:标c的文件操作函数执行效率高于uc的文件操作函数，因为标c的文件操作函数内部提供了输入输出缓冲区，当数据积累到一定数量之后才去访问内核，才会将数据写入到文件中;
        可以使用命令time来获取程序的执行时间:
        real	0m0.191s  - 真实时间(关注)
        user	0m0.156s  - 用户态时间
        sys 	0m0.028s  - 内核态时间
        可以通过自定义缓冲区的方式来提高效率，但并不是缓冲区越大则效率越高;

    练习：
        分别是用标c与uc文件操作函数编写以下函数
        1.vi 04fwrite.c文件，将[1~100万]之间的每一个整数写入到num.dat中;
        2.vi 05write.c文件，将[1~100万]之间的每一个整数写入到num2.dat中;
    -----------------------------------------------------------

    1.3 文件描述符的工作原理
        文件描述符本质上就是一个整数，可以代表一个打开的文件，但是文件的打开信息并不是存放在文件描述符中，而是存放在文件表等数据结构中，使用open函数打开文件时，操作系统会将文件的相关信息加载到文件表等数据结构中，但是出于安全和效率等因素的考虑，文件表等数据结构不适合直接操作，而是给文件表结构指定一个编号，使用编号来操作文件，该编号就是文件描述符;
        在每个进程的内部都有一张文件描述符总表，当有新的文件描述符需求时，会从文件描述符总表中查找最小的未被使用的文件描述符返回，文件描述符虽然是int类型，但是本质上是非负整数，也就是从0开始，其中0 1 2已被系统占用，分别代表标准输入，标准输出，以及标准错误，因此一般从3开始使用，文件描述符的最大值可以打开到OPEN_MAX(当前教学系统环境是1024);
         使用close函数关闭文件时，本质上就是将文件描述符和文件表等数据结构的对应关系从文件描述符总表中移除，不一定会删除文件表等数据结构，只有当文件表没有和任何其他文件描述符对应时(也就是一个文件表可以同时对应多个文件描述符)，才会删除文件表等数据结构，close函数页不会改变文件描述符本身的整数值，只是该文件描述符无法代表一个文件而已;

    1.5 dup/dup2函数
        #include <unistd.h>
        int dup(int oldfd);
     函数功能：
         主要用于实现对参数oldfd的复制，从文件描述符总表中查找最小的未被使用的文件描述符作为oldfd的副本;
     返回值：
         成功返回新的文件描述符;
         失败返回-1;
         #include <unistd.h>
         int dup2(int oldfd, int newfd);
     函数功能：
         主要用于实现oldfd到newfd的复制，如果文件描述符newfd已经被其他文件占用，则先关闭再复制;
     返回值：
         成功返回新的文件描述符;
         失败返回-1;


     注意：
         复制文件描述的本质就是赋值文件描述符所对应的文件表地址信息，使得多个文件描述符可以对应同一个文件，因此无论使用哪个文件描述符都可以访问文件;

    作业：
        1.vi 09write_emp.c文件，要求定义一个员工类型的结构体变量并且进行初始化，将该员工信息写入到emp.dat中，其中员工的信息主要有：员工的编号，员工的姓名，员工的薪水;
        2.vi 10read_emp.c文件，要求读取emp.data中的员工信息，并打印出来;
        3.查询fcntl函数

    明日预报：
        文件管理

    复习：
      lseek()  - 主要用于调整文件中的读写位置

      标c和uc文件操作函数的比较
      又称序可知：标c文件操作函数比uc的效率很高

     文件描述符的工作原理
    ----------------------------------------------------------
    1.文件的管理
    1.1 fcntl()函数
        #include <unistd.h>
        #include <fcntl.h>
        int fcntl(int fd, int cmd, ... /* arg */ );
     第一个参数：文件描述符;
     第二个参数：具体的操作命令;
     第三个参数：可变长参数，是否需要取决于cmd;
     函数功能：
         主要用于操作文件描述符，具体操作方式如下：
         1.Duplicating a file descriptor(复制文件描述符)
           cmd的取值：
              F_DUPFD  - 查找最小的>=arg得描述符作fd的副本，与dup不同的地方在于：若arg已经被其他文件占用，则不会关闭，而是查找>arg的描述符进行复制;
       返回值：成功返回新的文件描述符;
               失败返回-1;

         2.File descriptor flags(操作文件描述符的标志)（了解）
           cmd的取值：
            F_GETFD/F_SETFD  - 获取/设置文件的描述符的标志;
       返回值：成功返回文件描述符的标志值;
               失败返回-1;

         3.File status flags(操作文件的状态标志)(来了解)
           cmd 的取值：
             F_GETFL/F_SETFL  - 获取设置文件的状态标志
       返回值：成功返回文件状态的标志值;
               失败返回-1;

         4.Advisory record locking(实现建议锁/文件锁的功能)(重点)
            第二个参数：cmd的取值：
            F_SETLK/F_SETLKW/F_GETLK  -实现解锁/加锁功能;
            第三个参数：arg的取值
            struct flock {
               ...
               short l_type;  /* 锁的类型: F_RDLCK,F_WRLCK,F_UNLCK */
               short l_whence;/* 加锁的起始位置:SEEK_SET, SEEK_CUR, SEEK_END */
               off_t l_start; /* 相对于起始位置的偏移量 */
               off_t l_len;   /* 加锁的长度，单位字节 */
               pid_t l_pid;   /* 加锁的进程号 */
               ...
           };
        返回值：成功返回 0;
                失败返回-1;

    1.2 使用fcntl()函数实现文件锁的功能(重点)
     1) 文件锁的由来
        当多个进程在同一时刻相统一个文件中的同一块区域写入不同数据时，可能会造成文件数据的交替和混乱文件，理论上多个进程读文件可以同时进行，但是只要有一个进程执行写操作，那么多个进程就不能同时进行，为了实现该效果，需要借助文件所机制;
        文件锁本质上就是读写锁，一把读锁，一把写锁，其中读锁是共享锁，允许其他进程加读锁但不允许加写锁;而写锁是互斥锁，不允许其他进程加读锁和写锁;

     2) 使用F_SETLK作为函数的第二个实参的用法
        当锁的类型是F_RDLCK,F_WRLCK时，实现加锁的功能;
        当锁的类型是F_UNLCK时，实现解锁的功能;
        无论实现加锁还是解锁，具体锁的信息由第三个参数决定;

        由程序结果可知：
        当文件被加完写锁时，依然是可以写入数据到文件中，由此课间，文件锁并不能真正锁定对文件的读写操作，只能锁定其他的锁，也就是导致第二次加锁失败(两个读锁除外) => 君子协定;

    思考：
        如何通过文件锁实现对文件读写操作的控制呢？？？
    解决方案：
        一般来说，在执行读写操作之前，尝试加读写锁，根据能否进行加读写锁来决定能否进行读写操作;

    释放锁的方式：
        1.将锁的类型改为F_UNLCK，重新使用fcntl函数进行设置即可;
        2.使用close函数关闭文件描述符，与该描述符有关的所有文件锁全部被释放;(适合多把锁的情况);
        3.进程结束时，会自动释放与该进程有关的文件锁;
     3) 使用F_SETLKW作为函数的第二个实参时的用法
        该参数的用法与F_SETLK用法相似，所不同的是，当文件中存在一把冲突的锁时，并不会返回加锁失败，而是一直等待直到文件上的冲突锁被释放为止

     4) F_GETLK作为实参的用法
        如果第三个参数锁描述的信息可以加到文件上，则fcntl函数不会去加，而是将锁的类型改为F_UNLCK,其他成员保持不变;
        如果第三个参数锁描述的信息不可以加到文件上，则fcntl函数会获取文件上已经存在的锁信息，并用这些信息覆盖第三个参数原来描述的锁信息，也就是获取文件上已经存在的锁信息;

    1.3 access函数
        #include <unistd.h>
        int access(const char *pathname, int mode);
     第一个参数：文件字符串形式的文件路径名;
     第二个参数：具体的操作模式;
         F_OK  - 判断文件是否存在(重点);
         R_OK/W_OK/X_OK  - 判断文件是否可读/可写/可执行;
     函数的功能：
         主要用于判断文件的存在性以及是否拥有相应的权限;
     返回值：
         成功返回0;
         失败返回-1;
    1.4 stat函数/fstat函数
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <unistd.h>
        int stat(const char *pathname, struct stat *buf);
        int fstat(int fd, struct stat *buf);
     第一个参数：字符串形式的文件路径名/文件描述符;
     第二个参数：结构体指针，准备结构体变量取地址作为实参;
          结构体的类型如下：
            mode_t st_mode; /* 文件的类型和权限 */
            off_t st_size; /* 文件的大小，单位字节 */(重点)
            time_t st_mtime  /* 最后一次修改结构 */
     函数功能：
         主要用于获取指定文件的状状态信息，通过第二个参数带出来;

    扩展：
       ctime()函数
       #include <time.h>
       char *ctime(const time_t *timep);
     函数功能：
          将参数指定的整数时间转换为字符串时间并返回;

       #include <time.h>
       struct tm *localtime(const time_t *timep);
     函数功能：
         将参数指定的整数时间转换为结构体指针类型的时间;
     其中结构体的类型如下：struct tm
         int tm_sec;    /* 秒 */
         int tm_min;    /* 分 */
         int tm_hour;   /* 时 */
         int tm_mday;   /* 日 */
         int tm_mon;    /* 月 */  (加1)
         int tm_year;   /* 年 */  (加1900)

    作业：
        1.自定义函数generator_id,实现每次执行程序时都可以不断地打印一个自动增长的整数值;
      a.out   10000
      a.out   10001
      a.out   10002
      ... ...

    明日预报：
        文件的管理
        目录的管理
        进程的管理

    复习：
    1.fcntl()函数
    主要用于操作文件描述符
     文件锁/建议锁
    F_SETLK作为参数的作用
    当锁的类型是F_RDLCK/F_WRLCK时，实现加锁功能;
    当锁的类型是F_UNLCK时，实现解锁功能功能;
    文件已经被加写锁时，文件还是可以写入数据的也就是文件锁不能锁定文件的读写操作，但是可以导致其他进程加锁失败(两个读锁除外)
    为了使得文件锁尅对文件的读写chou产生应先，在执行读写操作之前尝试加读写锁，根
    释放锁的方式：
    将锁的类型改为F_UNLCK,fcntl()函数
    关闭文件描述符;
    进程结束会自动释放所有与文件有关的锁

    F_SETLKW参数
    与F_SETLK的ginning相似，但是所不同的是，当文件已经被加锁时，此时第三个参数描述的文件锁无法被加到文件时，会一直等待在直到文件上已经存在的锁被释放为止;


    F_GETLK作为函数实参
    如过锁能加上，则不去加锁，而是将锁的类型改为F_UNLCK，其它成员不变;

    access()函数
    检查文件是否存在，以及是否权限信息;

    stat/fstat获取指定文件的状态信息

    扩展：
        获取一个文件指定大小的方式：
          1.fseek跳到调整文件的读写位置到末尾，用ftell函数得到文件的大小;
          2.lseek函数调整文件读写位置到末尾，返回值便是文件爱呢大小;
          3.stat/fstat函数获取文件的信息，结构体中st_size就是文件的大小信息;
    ----------------------------------------------------------
    今天的内容：
        文件的管理
        目录的管理


    1.文件的管理
    1.1 chmod/fchmod函数
        #include <sys/stat.h>
        int chmod(const char *pathname, mode_t mode);
        int fchmod(int fd, mode_t mode);
     第一个参数：字符串形式的文件路径名/文件描述符
     第二个参数：具体的新权限，如：0664
     函数功能：
         主要用于：修改文件的权限;
     返回值：
         成功返回0;
         失败返回-1;

    1.2 truncate/ftruncate函数(重点)
        #include <unistd.h>
        #include <sys/types.h>
        int truncate(const char *path, off_t length);
        int ftruncate(int fd, off_t length);
     第一个参数：字符串文件路径/文件描述符
     第二个参数：具体的新长度
     函数功能：
         主要用于修改指定文件到指定的大小;
    注意：
        当文件变小时，后面的多余数据会丢失;
        当文件变大时，扩展出来的内容读取到的就是'\0';
        而文件的读写闻之偏移量不会改变;
     返回值：
         成功返回0;失败返回-1;

    练习：

    1.3 umask函数(了解)
        #include <sys/types.h>
        #include <sys/stat.h>
        mode_t umask(mode_t mask);
     函数功能：
         设置文件在创建时，屏蔽的权限为：参数的指定值，返回之前旧的屏蔽权限;

    1.4 再见mmap/munmap函数
        通过建立虚拟地址到文件的映射，可以将对文件的读写操作转换为简单的赋值操作就尅将数据写入到文件中，因此又多了一种读写文件的方式;

    练习：vi 03mmap文件，通过映射的方式将文件emp.dat中的3个员工的信息打印出来;

    1.5 其他函数
        link()     - 用于建立硬链接
        unlink()   - 用于删除硬链接
        rename()   - 用于重命名文件
        remove()   - 用于删除文件
        ... ...

    2. 目录的管理
    2.1 常用的基本操作函数
     1) opendir()  - 打开目的一个函数
        #include <sys/types.h>
        #include <dirent.h>
        DIR *opendir(const char *name);
     参数：字符串形式的目录名
     函数功能：
         主要用于打开参数指定的目录;
     返回值：
         成功返回有效的目录指针;
         失败返回NULL;

     2) readdir()  - 读取一个目录
        #include <dirent.h>
        struct dirent *readdir(DIR *dirp);
     参数：
         opendir函数的返回值;
     函数功能：
         主要用于读取参数指定的目录内容;
     返回值：
         读取成功返回一个有效的结构体指针;
         失败返回NULL;

     返回的结构体中：
     struct dirent {
         unsigned char  d_type; /* 文件的类型 */
           /* 类型为 4  表示目录文件
              类型为 8  表示普通文件 */
         char       d_name[256]; /* 文件的名称 */
           };

     3) closedir()  - 关闭目录;
        #include <sys/types.h>
        #include <dirent.h>
        int closedir(DIR *dirp);
     函数功能：
         主要用于关闭函数参数指定的目录，参数为opendir函数的返回值;
     返回值：
         成功返回0; 失败返回-1;

    2.2 其他函数
        mkdir()  - 创建目录的函数
        rmdir()  - 删除目录的函数
        chdir()  - 切换目录的函数
        getcwd() - 获取当前工作目录的绝对路径信息
        ... ...

    3.进程的管理
    3.1 基本概念和基本命令
        程序 - 存放在磁盘上的可执行文件;
        进程 - 运行在内存中的程序;
        同一个程序可以同时对应多个进程;

      ps - 查看当前终端启动的进程信息;
        ps的执行结果：
        PID          TTY        TIME    CMD
        1984        pts/6    00:00:00  bash
        2376        pts/6    00:00:00  ps
     PID - 进程的编号
     TTY - 终端的次要装置号
     TIME - 消耗cpu的时间
     CMD - 进程的名称(重点)

     ps -aux  - 表示查看所有包括其他使用者的进程信息;
     ps -aux | more -表示分屏显示所有的进程信息;

     USER - 用户名称
     PID  -进程的编号
     %CPU - 占用cpu的百分比
     %MEM - 占用内存的百分比
     VSZ  - 虚拟内存的大小
     RSS  - 物理内存的大小
     TTY  - 终端的次要装置编号
     STAT - 进程的状态信息
     START- 进程的启动时间
     TIME - 消耗cpu的时间
     COMMAND - 进程的名称
     其中进程的主要状态如下(了解)
       S 休眠状态，为了减轻cpu的压力
       s 进程的领导者，下面拥有子进程
       Z 将是进程，已经结束但资源没有回收的进程
       R 正在运行的进程
       T 挂起的进程
       O 可以运行的进程
       < 优先级比较高的进程
       N 优先级比较低的进程
       ... ...

      ps -ef  - 以全格式的方式显示进程信息;
      ps -ef | more  - 表示分屏显示进程信息;
      ps -ef | more 的执行结果：
        UID - 用户的ID
        PID - 进程的编号
        PPID - 父进程的编号
        C  - 占用cpu的百分比
        STIME - 启动时间
        TTY  - 终端的次要编号
        TIME - 消耗cpu的时间
        CMD  - 进程的名称

       目前主流的操作系统都支持多进程，如果 进程A 启动了 进程B，那么 进程A 就叫做 进程B 的父进程，进程B 叫做 进程A 的子进程;
       当前系统中，进程0(系统内部的进程)负责启动进程1(init)和进程2,其他进程都是直接/间接有进城1或进程2启动起来的，从而构成了逻辑结构中的树形结构;
       进程号的数据类型虽然是int类型，但是本质上是从0开始，作为进程的唯一标识，操作系统采用延迟重(chong)用的策略进行进程号的管理，从而保证在任意时刻进程号都是唯一的;

        kill -9  进程号  - 表示杀死指定的进程

    3.2 各种ID的获取
        #include <sys/types.h>
        #include <unistd.h>
        getpid() - 获取当前进程的编号，返回值类型是pid_t类型;
        getppid() -获取当前父进程的编号，返回值类型是pid_t类型
        getuid() - 获取当前用户的编号，返回值类型是uid_t类型
        getgid() - 获取当前用户所在用户组的编号，返回值类型是gid_t类型

    注意：
        pid_t类型本质就是 int 类型
        uid_t类型和gid_t类型本质就是 unsigned int类型;


    3.3 进程的创建
     1) fork函数
        #include <unistd.h>
        pid_t fork(void);
     函数功能：
         主要用于复制当前正在调用进程的方式来启动一个新的进程，而其中启动的进程叫做子进程，原来的进程叫做父进程，函数调用成功时父进程返回子进程的进程号，子进程返回0,函数调用失败时直接返回-1,没有子进程被创建;



    作业：
        编程实现打印目录中所有内容，要求子目录中胡内容也要打印，参考代码如下 vi 06dir.c:
       void print(char *path)
       {
           //... ...
       }
       int main()
       {
           print("../../day02/code");
           return 0;
       }


    1.文件的管理
    chmod/fchmod
    truncate/ftruncate(重点)
    umask
    mmap/munmap(重点)
    link
    unlink
    rename
    remove
    2.目录的管理
    opendir 打开
    readdir 读取
    closedir 关闭

    mkdir
    rmdair
    chdir
    getcwd()
    3.进程的管理
    进程的基本概念
     程序 -放在磁盘上的可执行文件
     进程 -运行在内存中的程序
    基本命令
    ps
    ps -aux
    ps -aux | more
    ps -ef
    ps -ef | more
    kill -9 进程号
    各种Id的获取方式
    getpid()
    getppid()
    getuid()
    getgid()
    --------------------------------------------------------
    1.进程的管理
    1.1 进程的基本操作
     1) fork函数
        #include <unistd.h>
        pid_t fork(void);
     函数功能：
         主要用于复制当前正在调用进程的方式来启动一个新的进程，而其中启动的进程叫做子进程，原来的进程叫做父进程，函数调用成功时父进程返回子进程的进程号，子进程返回0,函数调用失败时直接返回-1,没有子进程被创建;

    注意：
        父子进程的执行次序由操作系统的调度算法决定;

     2) 父子进程的执行次序
        a.对于fork函数之前的代码，父进程执行一次;
        b.对于fork函数之后的代码，父子进程各自执行一次;
        c.fork函数的返回值由父子进程各自返回一次;


     3) 父子进程之间的关系
        a.父进程启动子进程，父子进程同时启动，如果子进程先于父进程结束，则给父进程发送信号，由父进程回收子进程的资源;
        b.如果父进程先于子进程结束，则子进程变成孤儿进程，子进程会变成父进程(一般重置init(1)为新的父进程)，init进程收养了孤儿进程，所以叫做孤儿院;
        c.如果子进程先于父进程结束，但是父进程由于各种原因没有接受到子进程发来的信号，也就没有回收子进程的资源，但是子进程已经结束，因此子进程变成将是进程;

     4) 父子进程之间的内存关系
        使用fork函数创建子进程后，子进程会复制父进程中除了代码区之外的其他内存区域，而代码区和父进程共享;
        使用fork函数创建子进程后，子进程回复之父进程呢个中的文件描述符总表，但不会复制结构，使得父子进程中的文件描述符对应同一个文件表结构;

    练习：
        使用open函数创建一个文件a.txt，使用函数创建子进程，分别使用父进程和子进程想文件a.txt 分别写入"hello"和"world",最后关闭文件;
        vi 04fd.c

     5) 扩展
        a.如何创建3个进程一共4个进程？
          fork();
          fork();
          4个进程 = 1个父进程 + 2个子进程 + 1个孙子进程;

        b.如何创建2个进程，一共3个进程？
          pid = fork();
          if(pid > 0)
          {
              fork();//只让父进程再调用fork函数
          }
          3个进程：1个父进程 + 2个子进程;

        c.俗称"fork炸弹"
          while(1)
          {
              fork();
          }

    1.2 进程的终止
     1) 正常终止进程的方式
        a.执行了main函数中的return语句;
        b.调用exit()函数进行终止;
        c.调用_exit()和_Exit()函数;
        d.最后一个线程返回;
        e.最后一个函数调用pthread_exit()函数;

     2) 非正常终止
        a.采用信号终止进程的执行;
        b.最后一个线程被其他线程取消;

     3) 终止进程相关的函数
        #include <unistd.h>
        void _exit(int status);//表示uc的函数
        #include <stdlib.h>
        void _Exit(int status);//表示标c的函数
     函数功能：
         主要用于立即终止当前正在调用的进程;关闭所有属于当前进程的打开的文件描述符;让该进程的子进程变更父进程为init进程;给父进程发送SIGCHLD信号让父进程帮其进行处理;
         参数ststus的数值被返回给当前进程的父进程作为当前进程的退出状态，如果父进程收集该状态信息，则需要调用wait系列函数进行收集;
         函数_Exit()函数和_exit()函数之间是等价关系;

         #include <stdlib.h>
         void exit(int status);
     函数功能：
         主要引起正常进程的终止;参数status & 0377之后的的结果返回给父进程作为该进程的退出状态信息，父进程可以使用wait系列函数进行获取;
         该函数会自动调用所有由atexit()和on_exit()函数注册过的函数，该用法主要用于进行善后工作;
         EXIT_SUCCESS 和 EXIT_FAILURE 作为函数exit()的实参可以表示正常结束和非正常结束程序的含义;但本之上就是0 和 -1;

         #include <stdlib.h>
         int atexit(void (*function)(void));
     函数功能：
         注册参数指定的函数，该`册函数会在正常进程终止时被调用，而正常进程终止的方式有:调用exit()函数 和 执行main函数中的return;
     返回值：成功返回 0;  失败返回 !0;

        #include <stdlib.h>
        int on_exit(void (*function)(int , void *), void *arg);
     函数功能：
         用来设置一个程序正常结束前调用的函数。当成需通过调用exit()函数或从main中返回时，参数function所指定的函数会先被调用，然后才真正由exit()结束程序，参数arg指针会传给参数function函数;
     返回值：成功返回 0;  失败返回 !0;

    1.3 进程的等待
     1) wait()函数
         #include <sys/types.h>
         #include <sys/wait.h>
         pid_t wait(int *status);
     函数功能：
         主要用于挂起当前正在执行的进程直到有一个子进程中为止;
         当参数status不为空时，则将获取到的退出状态信息存放到该参数指定的int类型存储空间中，为了正确的解析退出状态信息需要借助以下的宏定义:
         WIFEXITED(*status)  - 当子进程正常终止时，返回真;而子进程正常终止的方式有:调用exit()/调用_exit()/执行main函数的return语句;
         WEXITSTATUS(*status)  - 返回带参宏的状态信息;
     返回值：
         成功返回终止子进程的进程号，失败返回-1;

     2) waitpid()函数
        #include <sys/types.h>
        #include <sys/wait.h>
        pid_t waitpid(pid_t pid, int *status, int options);
     第一个参数：进程的编号(哪一个进程);
       < -1  表示等待任意一个进程组ID为pid绝对值的子进程(了解);
       = -1  表示等待任意一个子进程;(重点)
       = 0   表示等待任意一个进程组ID为当前正在调用进程ID的子进程;(重点)
       > 0   表示等待进程号为pid的子进程;
     第二个参数：指针变量，用于获取子进程的退出信息;
     第三个参数：等待的方式，默认给0,表示阻塞的效果;
       WNOHANG - 如果没有子进程退出则立即返回，不会等待;
     函数功能：
         主要用于等待参数指定的进程，并获取退出状态信息;
     返回值：
         如果使用阻塞的方式成功返回子进程号;
         如果使用非阻塞的方式成功返回0;
         无论使用何种方式只要失败都返回-1;

    注意：
        The call wait(&status)  is  equivalent to:
         waitpid(-1, &status, 0);

    练习：
        使用fork函数创建子进程，在子进程中申请int类型大小的动态内存，提示用户输入半径，根据用户输入的计算周长并打印，要求当子进程终止时自动释放动态内存，父进程等待子进程结束，并获取退出状态信息，并打印出来;

    明日预报：
        1) 进程的管理
        2) 信号的处理

    复习：
    1.进程管理
    1.1进程的创建
       fork  - 复制当前正在调用进程的方式启动一个新进程，新奇动的进程叫做子进程
       返回值：成功父进程返回子进程号，子进程返回0;失败返回-1
    根据函数的返回值判断父子进程，
        复制：使用fork函数创建子进程后，子进程会复制父进程除了代码区之外的其他内存区域，而代码区于父进程共享;
        复制文件描述符，但是不会复制文件标结构，使得多个进程中的文件描述符对应同一个文件表结构;

    1.2进程终止
       正常终止
       1.执行main中的return
       2.exit
       3._exit/_Exit
       4.最后一个线程返回
       5.调用pthread_exit
       非正常
       1.信号终止
       2.被其他线程终止
    1.3进程等待
       wait函数  - 等待任意一个子进程终止;
       waitpid函数 - 等待参数指定的子进程终止
     返回值：
         成功返回终止的子进程;失败返回-1;
    ------------------------------------------------------------
    今天内容：
        1.进程的管理
        2.信号的处理

    1.进程的管理
    1.1 进程管理的其他函数
     1) vfork函数
        #include <sys/types.h>
        #include <unistd.h>
        pid_t vfork(void);
     函数功能：
         主要用于创建当前正在调用进程的子进程，有关详细情况和返回值和错误信息参考fork函数;
         该函数创建子进程时不会复制父进程的内存空间，而是直接占用，导致父进程被挂起，直到子进程终止或者调用exec系列的函数为止，而子进程终止的方式不可以是：从当前函数返回以及调用exit()函数;而是应该调用_exit()函数来终止!
         vfork函数保证了子进程先执行;
     返回值：与fork函数相同;

     2) execl系列函数
         #include <unistd.h>
         extern char **environ;
         int execl(const char *path, const char *arg, ...);
     第一个参数：字符串形式的路径名;
     第二个参数：字符串形式的参数，一般制定具体的执行方式;
     第三个参数：可变长参数，最后使用NULL作为结尾标志;
     返回值：
         只有出错的时候才有返回值，并且返回值返回-1;
     函数功能：
         主要执行参数指定的文件，类似于跳转功能;

    注意：
        vfork函数本身没有太大的实际意义，一般与execl系列的函数搭配使用，该用法主要用于子进程需要执行于父进程完全不同的代码段的场合中，其中vfork函数专门用于创建子进程，execl函数专门用于执行全新的代码;
        fork函数虽然也可以和execl系列函数搭配使用，但是fork函数创建子进程会复制父进程中内存区域，因此会影响效率;

     3) system函数
        #include <stdlib.h>
        int system(const char *command);
     函数功能：
         主要用于执行参数指定的shell命令，成功返回命令的状态信息，失败返回-1;

    2.中断的概念和分类
      中断就是指停止当前程序的执行，转而执行其他程序或者处理意外情况的过程;
      中断方式：硬件中断 和 软件中断;

    3.信号的处理
    3.1 基本概念和特性
     1) 信号本质就是软件中断，他既可以作为两个进程间通信的一种方式，也可以中断一个程序的执行，他更多的被用于处理意外情况;

     2) 基本特性
        a.信号是异步的，进程并不知道信号何时会到达;
        b.进程既可以处理信号，也可以发送信号;
        c.每个信号都有一个名字，使用SIG开头;

    3.2 基本命令和分类
        kill -l  表示显示当前系统所支持的所有信号;
        在linux系统中支持的范围是:1~64，不连续，其中1～31之间的信号叫做不可靠信号，不支持排队，信号可能会丢失，也叫做非实时信号;其中34～64之间的信号叫做可靠信号，支持排队，信号不会丢失，也叫做实时信号;

     要求掌握的信号：
         SIGINT  2  -- 采用cttl+c来产生该信号，默认处理方式为终止进程;
         SIGQUIT 3  -- 采用ctrl+\来产生该信号，默认处理方式为终止进程;
         SIGKILL 9  -- 采用kill -9命令来产生，默认处理方式终止进程;

    3.3 信号的处理方式
     1) 默认处理，绝大多数信号的默认处理方式都是终止进程;
     2) 忽略处理
     3) 自定义处理/捕获处理

        #include <signal.h>
        typedef void (*sighandler_t)(int);
        sighandler_t signal(int signum, sighandler_t handler);
     函数原型解析如下:
        typedef void (*sighandler_t)(int);
     => typedef void (*)(int) sighandler_t;
        sighandler_t signal(int signum, sighandler_t handler);
     => signal是一个函数：
        具有两个参数：一个参数是int类型，另外一个是函数指针类型;
        返回值类型是函数指针;
        第二个参数和返回值类型的解析：
        是一个执行参数为int类型，返回值为void类型的函数指针;
     函数功能解析如下:
        第一个参数：信号值/信号名称(表示对哪个信号处理)
        第二个参数：函数指针类型，用于指定处理方式;
              SIG_IGN  - 忽略处理;
              SIG_DFL  - 默认处理
              自定义函数的地址  - 自定义处理
        返回值： 成功返回之前的处理方式;失败返回SIG_ERR(-1);
        函数功能：
            主要用于设置指定信号的处理方式;

    练习：
        使用signal函数设置对信号2进行自定义处理，设置信号3进行忽略处理，再使用fork函数创建子进程，打印子进程的进程号后，子进程进入无线循环，父进程直接结束，另起一个终端使用kill命令发送2，3，9，观察结果;

    3.4 父子进程对信号的处理方式
     1) 对于fork函数创建的子进程来说，子进程完全照搬父进程对信号的处理方式，也就是父进程默认，子进程也默认;父进程忽略，子进程也忽略;父进程自定义，子进程也自定义;
     2) 对于vfork函数和execl函数启动的子进程来说，父进程默认处理，子进程也默认处 额的理;父进程忽略处理，子进程也忽略处理;父进程自定义处理，子进程采用默认处理;

    3.5 发送信号的方式
     1) 采用键盘发送信号(只能发送部分特殊的信号);
        使用ctrl + c 发送 SIGINT 2
        ... ...
     2) 程序出错发送信号(只能发送部分特殊的信号);
        段错误 发送的信号 SIGSEGV  11;
        ... ...
     3) 使用kill命令发送信号(全部信号都可以发)
        kill -信号值 进程号
        kill -9  3305
     4) 采用系统函数发送信号(发送大部分信号)
        kill()/raise()/alarm()/sigqueue()

    3.6 发送信号的函数解析
     1) kill函数
        #include <sys/types.h>
        #include <signal.h>
        int kill(pid_t pid, int sig);
     第一个函数：进程号(给谁发信号);
         当 pid > 0  表示发送信号sig给进程号为 pid 的进程(单发，重点);
         当 pid = 0  表示发送信号sig给和当前正在调用进程再同一个进程组的每一个进程(群发，了解);
         当 pid = -1 表示发送信号给每一个当前进程拥有发送信号权限的进程，除了进程1(init)(群发);
         当 pid < -1 表示发送信号sig给进程组ID为-pid的每一个进程(群发，了解);
     第二个函数：信号值/信号名称(发送什么样的信号)
          0 表示不会发送信号，只是检查指定进程是否存在;
     函数功能：
         主要用于给指定的进程发送指定的信号;
     返回值：成功返回0; 失败返回-1;

     2) raise函数
        #include <signal.h>
        int raise(int sig);
     函数功能：
         主要用于给当前正在调用的进程/线程发送参数指定的信号，对于单线程的程序来说，等价于kill(setpid(),sig);
     返回值：
         成功返回0; 失败返回!0;

     3) sleep函数
        #include <unistd.h>
        unsigned int sleep(unsigned int seconds);
     函数功能：
         主要用于使得当前正在调用的进程进入睡眠状态，当指定的秒数睡够了则返回0,当之定的秒数没有睡够但一个不能忽略的信号到来了，则返回剩余没有来得及睡得秒数;

     4) alarm函数
        #include <unistd.h>
        unsigned int alarm(unsigned int seconds);
     函数功能：
         主要用于经过参数指定的秒数后给当前正在调用的进程发送SIGALRM信号，如果参数为0,则表示没有新的闹钟被设置，每次设置新闹钟都会取消之前的闹钟;
         如果之前有闹钟则返回之前闹钟没来得及想得剩余秒数，否则返回0;



    作业：
        查询sigaction函数
    明日预报：
        信号的处理
        进程间的通信技术

    1.信号的处理
    1.1 信号集的基本概念和特性
     1) 基本概念
        信号集本质就是由若干个信号组成的集合;
     思考：
        如何采用最节省内存的俄方是来设计信号集的数据类型？？？
        int arr[64];  => 4*64 = 256字节;
        short arr[64]; => 2*64 = 128字节;
        char arr[64];  => 1*64 = 64个字节;
        采用每个二进制位代表一个信号 => 64个二进制位 = 8个字节;
     结论：
         操作系统中提供的信号集类型，sigset_t类型，底层是一个草集大的整数，采用每一个二进制位来代表该信号是否存在，其中0表示不存在，1表示存在;
           typedef struct
            {
                unsigned long int __val[(1024 / (8 * sizeof(unsigned long int)))];
              } __sigset_t;
           typedef __sigset_t sigset_t;


     2) 基本操作
        -------------------------------------------------------
        sigemptyset()  - 主要清空信号集
        sigfillset()   - 主要用于填满信号集
        以上两个函数只有一个参数：信号集类型的指针
        ----------------------------
        sigaddset()    - 增加信号到信号集
        sigdelset()    - 删除信号集中指定的信号
        以上两个函数有两个参数：
        第一个参数：信号集类型的指针
        第二个参数：信号值/信号名称

        以上四个参数返回值：成功返回0；失败返回-1;
        ------------------------------------------------------
        sigismember()  -判断信号是否存在于信号集中;
        以上一个函数有两个参数：
        第一个参数：信号集类型指针
        第二个参数：信号值/信号名称
        返回值：存在返回1;不存在返回0; 函数调用失败返回-1;
        ------------------------------------------------------
    1.2 信号的屏蔽
        在某些特殊程序的执行过程中，是不能被信号打断的，此时需要使用信号屏蔽技术来解决问题;
     1) sigprocmask函数
        #include <signal.h>
        int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
     第一个参数：具体的屏蔽方式;
        SIG_BLOCK  - 表示进程中已经屏蔽的信号集 + 参数set的信号集(ABC + CDE => ABCDE);
        SIG_UNBLOCK - 表示进程中已经屏蔽的信号集 - 参数set信号集(ABC - CDE => AB);
        SIG_SETMASK - 表示进程中已经屏蔽的信号集被参数设置的信号集替代(ABC CDE => CDE);
     第二个参数：信号集类型的指针，用于传递新的信号集;
     第三个参数：信号集类型的指针;
         表示如果该参数不为空，则带出设置之前进程已经屏蔽的信号集;
         如果为空，则啥也不会带出;
     函数功能：
         主要用于提取/修改当前进程中的信号屏蔽集合;

    注意：
        信号屏蔽并不是信号的删除，只是相当于用一个隔板将所有的信号阻挡起来，对于可靠信号来说，发送多少次则排队等待的就是多少个信号;而对于不可靠信号来说，无论发送多少次，排队的信号只有一个，当心号屏蔽解除时，相当于将阻隔板移开，因此所有阻挡的信号都会被一次处理;

     2) sigpending函数
        #include <signal.h>
        int sigpending(sigset_t *set);
     函数功能：
         主要用于获取信号屏蔽期间来过但没有来得及处理的信号，将所有获取到的信号存放在参数指定的信号集set中，tongguo参数带出去;
     返回值：成功返回0; 失败返回-1;

    1.3 sigaction函数 => signal函数的增强版
        #include <signal.h>
        int sigaction(int signum, const struct sigaction *act,  struct sigaction *oldact);
     第一个参数：信号值/信号名称（设置哪个信号的处理方式）;
         可以指定任何有效的信号，但是不能只定SIGKILL和SIGSTOP;
     第二个参数：结构体指针，用于指定信号的最新处理方式;

     struct sigaction {
          void  (*sa_handler)(int);
       => 函数指针类型，设置信号的处理方式：
       => 取值可以是：SIG_DFL(默认)/SIG_IGN(忽略)/自定义函数地址;
       => 与signal函数的第二个参数取值一样，类型一样;
          void  (*sa_sigaction)(int, siginfo_t *, void *);
       => 函数指针类型，主要用于设置信号的处理方式
       => 取值可以是：SIG_DFL(默认)/SIG_IGN(忽略)/自定义函数地址;
       => 是否寻用改成员上则孩子信号的处理方式，取决于第四个成员;
          sigset_t  sa_mask;
       => 主要用于在执行信号处理函数期间需要屏蔽的信号集;
       => 自动屏蔽与触发信号处理函数相同的信号;
          int  sa_flags;
       => SA_SIGINFO 表示选择第二个函数指针作为信号的处理函数;
       => SA_NODEFER 表示解除对触发信号处理函数信号的屏蔽;
       => SA_RESETHAND 表示一旦调用信号处理函数则恢复默认处理方式;
          void  (*sa_restorer)(void);
       => 过时/保留的成员，暂时不被使用;
          };

     第三个参数：结构体指针，用于带出设置之前的信号处理方式;
     函数功能：
         主要用于检查和修改指定信号的处理方式;
      其中结构体指针的第二个参数：
        struc siginfo_t {
            ... ...
            pid_t    si_pid;  /* 发送信号的进程号 */
            sigval_t si_value;/* 伴随信号到来的附加数据*/
            ... ...
        }

    1.4 sigqueue函数
      #include <signal.h>
      int sigqueue(pid_t pid, int sig, const union sigval value);
     第一个参数：进程的编号(给谁发信号);
     第二个参数：具体的信号值/信号名称(发什么样的信号);
     第三个参数：伴随信号的附加数据;
         具体类型如下：
          union sigval {
              int   sival_int;
              void *sival_ptr;
          };
     函数功能：
         主要用于向指定的进程发送指定的信号和附加数据;

    1.5 计时器
        再Linux系统中，为每个进程都维护三种计时器，分别为：真实计时器，虚拟计时器，以及实用计时器，一般采用真实计时器进行计时;
        setitimer
        #include <sys/time.h>
        int getitimer(int which, struct itimerval *curr_value);
        int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value);
     第一个参数：计时器的类型(哪一个计时器)
         ITIMER_REAL  - 表示真实计时器，统计进程执行的真实时间;
                      - 该计时器通过产生SIGALRM信号进行工作;
         ITIMER_VIRTUAL - 虚拟计时器，统计进程在用户态消耗的时间;
                      - 该计时器通过产生SIGVTALRM信号进行工作;
         ITIMER_PROF - 实用计时器，统计用户态和内核态下消耗的时间;
                     - 通过产生SIGPROF信号进行工作;
     第二个参数：结构体指针，用于设置计时器的新值
     参数如下：
        struct itimerval {
            struct timeval it_interval; /* 间隔时间 */
            struct timeval it_value;    /* 启动/开始时间 */
        };

        struct timeval {
            time_t      tv_sec;         /* 秒 */
            suseconds_t tv_usec;        /* 微妙 1秒=10^6微妙 */
        };
     第三个参数：结构体指针，用于带出计时器之前的旧值
     函数功能：
         主要用于获取/设置计时器的参数信息;

    2.进程间的通信
    2.1 基本概念
        两个进程之间的信息交互 叫做进程间的通信;
    2.2 常用的进程间的通信技术
     1) 文件
     2) 信号
     3) 管道
     4) 共享内存
     5) 消息队列
     6) 信号量集
     7) 网络
     ... ...
      其中4),5),6)三种通信方式统称为 XSI IPC通信方式
     (X/open System Interface Inter-Process Communication)


    作业：
        使用计时器技术让控制台版的贪吃蛇动起来;

    明日预报：
        进程间的同信技术


    1.使用管道实现进程间的通信
    1.1 基本概念
        管道本质上就是文件，只是一种特殊的文件;
        管道分为两种:有名管道 和 无名管道
        有名管道  - 可以用于任意两个进程之间的通讯;
        无名管道  - 只能用于父子进程之间的通讯;

    1.2 使用有名管道实现进程间的通讯;
        使用mkfifo命令/函数来创建有名管道;
     如：
       touch a.txt
     =>创建普通文件;
       ls -l a.txt
     =>查看文件的详细信息，文件类型是 - ，表示普通文件;
       cat a.txt
     =>查看文件内容;
       mkfifo a.pipe
     =>创建管道文件
       ls -l a.pipe
     =>查看管道文件的详细信息，并且拥有黑色阴影
       echo hello > a.pipe
     =>写入数据hello到文件a.txt中写入法让是阻塞的，写不进去
       另起终端执行命令:cat a.pipe
     =>此时读取到的内容hello，另外一个终端的阻塞解除

        mkfifo函数
        #include <sys/types.h>
        #include <sys/stat.h>
        int mkfifo(const char *pathname, mode_t mode);
     第一个参数：字符串形式的路径名;
     第二个参数：具体的权限信息，如：0664
     函数功能：
         主要用于创建一个有名的管道;

    1.3 使用无名管道实现进程的通讯;
        #include <unistd.h>
        int pipe(int pipefd[2]);
     主要用于创建无名管道，提供一个单项的数据通道实现进程间的通信，通过参数带出两个文件描述符，其中pipe[0]代表读端，pipe[1]代表写端;

    注意：
        管道的特殊性旧在于仅仅作为进程间通信的媒介，但是管道本身并不会存放任何数据;

    2.使用共享内存
    2.1 基本概念
        共享内存本质就是一块由系统内核维护的内存空间，而该内存空间可以共享再两个进程之间，两个进程通过读写该内存区域从而实现通信;

    2.2 通讯的流程
     1) 获取key值，使用ftok函数
     2) 创建/获取共享内存，使用shmget函数
     3) 挂接共享内存，使用shmat函数;
     4) 使用共享内存;
     5) 脱接内存，使用shmdt函数
     6) 如果不再使用，则删除共享内存，使用shmtl函数

    2.3 相关函数的解析
     1) ftok函数
        #include <sys/types.h>
        #include <sys/ipc.h>
        key_t ftok(const char *pathname, int proj_id);
     第一个参数：字符串形式的路径名，要求文件必须存在，并且可以访问
     第二个参数：项目编号，要求非0,只取低八位;
     函数功能：
         主要根据参数的指定来生成一个key值，便于后续函数实现用
     返回值：
         成功返回key_t值; 失败返回-1;
    注意：
        使用相同的路径名，和相同的编号时，最终生成的key值也想同;

     2) shmget函数
        #include <sys/ipc.h>
        #include <sys/shm.h>
        int shmget(key_t key, size_t size, int shmflg);
     第一个参数：key值，ftok函数的返回值;
     第二个参数：具体共享内存大小;
        0 - 表示获取已经存在共享内存;
     第三个参数：具体的操作标志;
        IPC_CREAT   - 如果不存在则创建，存在打开;
        IPC_EXCL    - 与IPC_CREAT搭配使用，如果存在则创建失败;
        0         s  - 获取已经存在的共享内存;
     函数功能：
         主要用于创建/获取一个指定的共享内存;
     返回值：
         成功返回共享内存ID; 失败返回-1;
    注意：
         当使用该函数创建新的内存时，需要再第三个参数中指定该共享内存的权限信息，如：0664,指定的方式为桉位或运算;

     3) shmat函数
       #include <sys/types.h>
       #include <sys/shm.h>
       void *shmat(int shmid, const void *shmaddr, int shmflg);
     第一个参数：共享内存的id，shmget函数的返回值
     第二个参数：具体的挂接地址，给NULL则由系统选择位置;
     第三个参数：挂接的标志，默认给0即可;
     函数功能：
         主要用于将shmid指向的共享内存挂接到当前进程的地址空间中;
     返回值：
         成功返回挂接的起始地址;失败返回(void *)-1;

     4) shmdt函数
        #include <sys/types.h>
        #include <sys/shm.h>
        int shmdt(const void *shmaddr);
     函数功能：
         主要用于脱接参数指定的共享内存，参数为shmat函数的返回值;

     5) shmctl函数
        #include <sys/ipc.h>
        #include <sys/shm.h>
        int shmctl(int shmid, int cmd, struct shmid_ds *buf);
     第一个参数：共享内存的id，就是shmget函数的返回值;
     第二个参数：具体的操作命令;
          IPC_RMID  - 删除共享内存，此时内存段执行指定的操作;
     第三个参数：结构体指针;
     函数功能：
         主要用于对指定的共享内存段的执行指定的草组;

    2.4 常用的基本命令
        ipcs -m   - 表示查看当前系统中存在的共享内存段;
        ipcrm -m 共享内存段ID   - 表示删除指定的共享内存;

    3.使用消息队列实现进程间的通讯(重点)
    3.1 基本概念
        将通讯的数据打包成消息，使用两个不同的进程分别发送消息到消息队列中 和 接受消息队列中的消息，从而实现通信;

    3.2 通信模型
     1) 获取key值，使用ftok函数;(两个进程都需要获取key)
     2) 创建消息队列，使用msgget函数;
     3) 发送消息到消息队列中/接受消息队列中的消息，使用magsnd/msgrcv函数;
     4) 如果不再使用，删除消息队列，使用magctl函数

    3.3 相关函数的解析
     1) msgget函数
        #include <sys/types.h>
        #include <sys/ipc.h>
        #include <sys/msg.h>
        int msgget(key_t key, int msgflg);
     第一个参数：key值，ftok函数的返回值;
     第二个参数：具体的操作标志;
         IPC_CREAT  - 如果不存在则创建，存在则打开;
         IPC_EXCL   - 与IPC_CREAT搭配使用，如果存在则创建失败;
          0  - 获取已经存在的消息队列;
     函数功能：
         主要用于创建/获取消息队列;
     返回值：
         成功返回消息队列的ID; 失败返回-1;
    注意：
        当创建消息队列时，需要在第二个参数中指定权限信息，如：0664,指定方式桉位或运算;
     2) msgsnd函数
        #include <sys/types.h>
        #include <sys/ipc.h>
        #include <sys/msg.h>

        int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
     第一个参数：消息队列的ID，msgget函数的返回值;
     第二个参数：消息的起始地址;
     struct msgbuf {
         long mtype;       /* 消息的类型，must be > 0 */
         char mtext[1];    /* 消息内容，可以选择其他数据类型 */
     };
     第三个参数：消息的大小;
         该参数的大小仅仅包括消息内容的大小，不包括消息类型的大小;
     第四个参数：发送的标志，默认给0即可，表示发送不出去时阻塞;
         IPC_NOWAIT  - 表示发送不出去时，不会产生阻塞;
    函数功能：
        主要用于向指定的消息队列中发送指定的消息;
     3) msgrcv函数
        #include <sys/types.h>
        #include <sys/ipc.h>
        #include <sys/msg.h>
        ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);
     第一个参数：消息队列的ID，也就是msgget函数的返回值;
     第二个参数：存放消息的缓冲区首地址;
     第三个参数：期望接受消息的大小;
     第四个参数：期望接受消息的类型;
         如果给0,始终读取消息队列中的第一个消息;
         如果大于0,始终读取消息队列中第一个类型为msgtyp的消息;
         如果小于0,读取消息队列中第一个类型<=msgtyp绝对值的消息，其中最小类型的消息优先读取;
     第五个参数：具体的接受标志，默认给0即可;
     函数功能：
         主要用于从指定的消息队列中接受消息，并存放再指定的缓冲区中;
     4) msgctl函数
        #include <sys/types.h>
        #include <sys/ipc.h>
        #include <sys/msg.h>
        int msgctl(int msqid, int cmd, struct msqid_ds *buf);
     第一个参数：消息队列的ID，msgget函数的返回值;
     第二个参数：具体的操作命令;
         IPC_RMID - 删除消息队列，此时第三个参数给NULL即可;
     第三个参数：结构体指针;
     函数功能：
         主要用于操作参数指定的消息队列;

    3.4 常用的基本命令
        ipcs -q    --表示查看系统中已经存在的消息队列;
        ipcrm -q 消息队列中的ID  --表示删除队列;

    明日预报：
        使用信号量集实现进程间的通信;

    复习：
    1.使用管大实现进程间的通信
    基本概念：
        管道本质就是特殊特使万恶减
       有名管道  - 任意两个进程间的通信
       无名管到  - 只能实现父子进程间的通信
     使用有名管道实现通信;
     mkfifo的命令/函数
     mkfifo  xxx.pipe
     无名管道实现进程间的通讯
     pipe()  -- 创建无名管道
    2.共享内存实现进程间的通线
      基本通讯模型
     获取key值，使用ftok函数
     创建/获取共享内存，使用shmget函数
     挂节共享内存 使用shmat函数
     使用共享内存
     脱节内存，使用shmdt函数
     如果不咋使用，删除使用shmatl函数
    3.消息队列实现进程减的通信
      通讯模型
     获取key值，使用ftok函数
     创建/获取消息队列，使用msgget函数
     发送/接收消息，使用msgsnd函数
     接收消息，使用msgrcv函数
     删除消息队列msgctl函数
    ------------------------------------------------------------------
    1.信号量集实现进程间的通信
    1.1 基本概念
     1) 什么是信号量？？？
        信号量本身就是一种计数器，主要用于控制同时访问同种共享资源的进程/线程;
     2) 什么是信号量集？？？
        信号量集本质就是信号量的集合，主要用于控制多种共享资源分别被同时访问的进程/线程个数;

    1.2 信号量的工作方式
     1) 初始化信号量为最大值;
     2) 如果有进程申请到了一个共享资源，则信号量的数值减1;
     3) 当信号量的数值为0时，申请共享资源的进程进入阻塞状态;
     4) 如果有进程释放了一个共享资源，则信号量的数字加1;
     5) 当心号量的数值>0时，等待申请共享资源的进程可以继续抢
        占共享资源，抢不到共享资源的进程继续阻塞;

    1.3 适应信号量集实现进程间通信的模型
     1) 获取key值，使用ftok函数
     2) 创建/获取信号量集，使用semget还敢数
     3) 初始化信号量集，使用semctl函数;
     4) 操作信号量集控制进程/线程的个数，使用semop函数
     5) 如果不再使用，则删除信号量集，使用semctl函数

    1.4 相关函数的解析
     1) semget函数
        #include <sys/types.h>
        #include <sys/ipc.h>
        #include <sys/sem.h>
        int semget(key_t key, int nsems, int semflg);
     第一个参数：key值，ftok函数的返回值;
     第二个参数：信号量集的大小，也就是信号量的个数;
     第三个参数：具体的操作标志;
       IPC_CREAT - 如果不存在则创建，存在则打开;
       IPC_EXCL  - 与IPC_CREAT搭配使用，若存在则创建失败;
       0  - 获取已经返回信号量集;
     函数功能：
         主要用于创建/获取信号量集;
     返回值：
         成功放那会信号量集ID;失败返回-1;
     注意：
          当创建信号量集时，需要指定权限信息，如：0664,指定的方式为按位或在第三个参数中;

     2) semctl函数
        #include <sys/types.h>
        #include <sys/ipc.h>
        #include <sys/sem.h>
        int semctl(int semid, int semnum, int cmd, ...);
     第一个参数：信号量集的ID，就是semget函数的返回值;
     第二个参数：信号量集的下标，从0开始;
     第三个参数：具体的操作命令;
         IPC_RMID  - 删除整个信号量集，忽略sumnum，不需要第
                     四个参数;
         SETVAL  - 使用第四个参数的值，初始化下标为semnum的信号量
     第四个参数：可变长参数;
     函数功能：
         主要用于对指定的信号量集，执行指定的操作;
     3) semop函数
        #include <sys/types.h>
        #include <sys/ipc.h>
        #include <sys/sem.h>
        int semop(int semid, struct sembuf *sops, size_t nsops);
     第一个参数：信号量集的id,也就是semget函数的返回值;
     第二个参数：结构体指针，可以指向结构体变量，也可以指向数
                 组元素的个数;
     struct sembuf{
         unsigned short sem_num;  /* 信号量集的下标 */
         short sem_op;   /* 具体的操作，正数增加，负数减少，0不变 */
         short  sem_flg;  /* 操作的标志，默认给0 */
     }
     第三个参数：当结构体指针指向数组时，该参数表示数组元素的
                 个数;
    函数功能：
        主要用于操作指定的信号量;

    1.5 常用的基本命令
        ipcs -s    -- 表示查看系统中已经存在的信号量集;
        ipcs -a    -- 表示查看系统中所有的ipc结构，包括共享内存，消息队列，信号量集
        ipcrm -s 信号量集id  -- 表示删除信号量集;

    2.综合的小项目
    2.1 项目的名称
        银行账户管理系统(模拟ATM)

    2.2 项目的功能
        开户，销户，存款，存款，查询，转账;

    2.3 项目的架构
        采用 C(Client)/S(Server) 结构进行设计

    客户端：
          提供界面让用户选择具体的业务，将用户选择的业务编号发送给服务器进
          行处理，等待服务器的处理结果并显示给客户;

    服务器：
          根据用户客户端传来的业务编号，通过访问数据库的方式进行处理，并将
          最终的处理结果发送给客户端即可;

    2.4 项目的设计和分析
     1) 任何实现客户端和服务器之间的通信呢？？？
        采用两个消息队列实现进程间的通讯;
        消息队列一：客户端 => 服务器
        消息队列二：服务器 => 客户端
     2) 如何区分不同业务编号？？？
        采用消息的类型来区分不同的业务编号，需要8中类型;
        6种业务编号 + 成功 + 失败;
     3) 如何设计账户和消息的数据的类型呢？？？
        账户信息：帐号，账户名称，账户密码，余额;
        采用结构体类型来设计账户和信息的数据类型;
        使用账户信息发的结构体变量作为消息的数据内容;
     4) 以开户为例分析项目的执行流程
    客户端：
      a.绘制字符界面，供用户选择具体的业务编号;
        => 使用printf函数打印即可;
      b.根据用户的选择，进入不同的业务分支进行处理;
        => 使用scanf函数接收用户的输入，使用switch -- case结构进入不同的
           分支;
      c.提示用户输入开户信息，不需要输入帐号信息;
        => 使用结构体变量来保存用户的输入;
      d.打包用户输入的信息到消息的结构体中，发送给服务器;
        => 设置消息的类型为1中，代表开户业务;
        => 使用msgsnd函数将消息发送到消息队列一中;
      e.接收消息队列二中的下系，并显示处理结果;
        => 使用msgrcv函数接收消息;
        => 如果消息的类型为7,则表示处理成功;
        => 如果消息的类型为8,则表示处理失败;

    服务器：
      a.创建两个消息队列，作为服务器的初始化工作;
        => 使用msgget函数创建;
        => 使用ftok函数生成key值;
      b.接收客户端发来的消息，根据业务编号进行处理;
        => 使用msgrcv函数接收消息队列一中的消息;
        => 判断消息类型是否为1,若是则表示开户业务;
      c.自动生成一个帐号，补充完整账户信息;
        => 调用generator_id函数自动生成帐号;
      d.保存账户信息到文件中，并判断是否保存成功;
        => 每个账户信息都保存在一个独立的文件中里;
        => 采用帐号作为文件名来确保唯一性，使用sprintf函数;
      e.根据处理结果修改消息类型，并发送给客户端;
        => 如果处理成功，则修改消息的类型为 7;
           如果处理失败，则修改消息的类型为 8;
        => 使用msgsnd函数将小系发送到消息队列二中;
      f.要求服务器不断的运行，直到按下ctrl+c才能关闭服务器;
        => 使用无线循环保证服务器不停的工作;
        => 使用signal函数对SIGINT进行自定义处理;
        => 通过信号处理机制来删除两个消息队列，使用msgstrl函数;

    2.5 项目的要求
     1) 要求采用多函数多文件的方式编码，并支持Makefile文件;
     2) 要求实现开户功能即可，有余力的同学实现所有的功能;

    2.6 项目的提示
      vi bank.h  - 编写结构体的定义等公共代码;
      vi clinet.c  - 编写客户端的功能代码，打印界面的函数等;
      vi server.c  - 编写服务器的功能代码，创建消息队列的函数等;
      vi dao.c   - 编写自动生成帐号的函数;
      ... ...


    今天内容：
        网络相关的基本常识;
        基于socket的一对一通讯模型

    1.网络的相关的基本常识
     如：
        目前主流的网络通讯软件：QQ，微信，飞信，阿里旺旺...
    1.1 七层网络协议模型和常用的网络协议
     1) 七层网络协议模型
        一般来说，ISO将数据的传递从逻辑上划分为以下七层：
    应用层：主要用于将具体的数据内容传递给应用程序，如：QQ等;
    表示层：主要用于将数据按照一定的格式进行打包和封装;
    会话层：主要用于控制会话何时开始，何时终止;
    传输层：主要用于错误检查和重新排序等;
    网络层：主要用于选择具体的网络协议进行再次打包和发送;
    数据链路层：主要用于僵局踢得数据包转化为高低电平信号;
    物理层：主要指具体的交换机设备等物理设备;

     2) 常用的网络协议
     a. tcp协议
        - 传输控制协议，是一种面向连接的协议，类似打电话;
     b. upd协议
        - 是一种非面向连接的协议，类似写信;
     c. ip协议
        - 互联网协议，是上述两种协议的底层协议;

    1.2 IP地址，子网掩码(重点)
     1) IP地址
        IP地址 - 本质上就是互联网中的唯一标识;
        IP地址本质就是一个由32位二进制组成的整数(ipv4)，当然也有128位二进制组成的整数(ipv6);
        日常生活中采用点分十进制表示法来描述IP地址，也就是将每一个字节的二进制转换为十进制的整数，不同整数之间采用小数点分隔;
      如：0x01020304  => 1.2.3.4

        为了便于IP地址的管理，将IP地址分为两部分：网络地址 + 主机地址，根据网络地址和主机地址位数的不同分为以下4类：
        A类：0 + 7为网络地址 + 24位主机地址;
        B类：10 + 14位网络地址 + 16位主机地址;
        C类：110 + 21位网络地址 + 8位主机地址;
        D类：1110 + 28位多播地址;

        查看IP地址：
        windows系统：在dos窗口中使用ipcofig命令查看IP地址;
        Linux系统：在终端中使用ifconfig命令查看IP地址(inet 地址:192.168.66.179)，如果该命令不好使，则在/sbin/ifconfig命令即可;

     2) 子网掩码
        子网掩码主要用于划分IP地址中的网络地址和主机地址，也可以用于判断两个IP地址是否在统一局域网中，具体的划分方法为：
        IP地址 &(桉位与运算) 子网掩码 = 网络地址;
     如：
        IP地址：
          IP地址：192.30.100.64
        子网掩码：255.255.255.0 &
     -----------------------------------
                  192.30.100 - 网络地址
                          64 - 主机地址


    1.3 端口号和字节序(重点)
     1) 端口号
        IP地址  - 定位到具体的某一台主机/设备上;
        端口号  - 可以定义到主机/设备上的某一个进程;
        网络编程中需要提供两个信息：IP地址 + 端口号;
        端口号本质上就是unsigned short类型，范围 0～65535，其中0～1024之间爱你的端口号被系统占用，建议从1025开始使用;
     2) 字节序
        小端系统：主要指将低位字节诶数据保存在低位内存地址的系统;
        大端系统：主要指将低位字节数据据保存在高位内存地址的系统;
    如：0x12345678
       小端系统按照内存地址从小到大：0x78,0x56,0x34,0x12;
       大端系统按照内存地址从小到大：0x12,0x34,0x56,0x78;

    一般性原则：
        一般来说，将所有发送到网络中的多字节整数先转换为网络字节序再发送，而将所有从网络中接收过来的多字节整数，先转换为主机字节序再解析，其中网络字节序本质就是大端系统的字节序;

    2.基于socket的一对一通信模型
    2.1 基本概念
        socket 本意"插座"，在这里指用于通信的逻辑载体;
    2.2 通信模型
    服务器：
        1.创建socket，使用socket函数;
        2.准备通讯地址，使用结构体类型;
        3.绑定socket和通讯地址，使用bind函数;
        4.进行通信，使用read/write函数
        5.关闭socket，使用close函数;
    客户端：
        1.创建socket，使用socket函数;
        2.准备通讯地址，使用服务器的地址;
        3.链接socket和通讯地址，使用connect函数;
        4.进行通信，使用read/write函数;
        5.关闭socket，使用close函数;

    2.3 相关函数的解析
     1) socket函数
        #include <sys/types.h>
        #include <sys/socket.h>
        int socket(int domain, int type, int protocol);
     第一个参数：域/协议族，决定了本地通信还是网络通信;
         AF_UNIX, AF_LOCAL   -- 表示实现本地通信(同一台计算机间不同进程的通信)
         AF_INET  -- 用于实现基于ipv4的网络通信(不同主机之间)
         AF_INET6  -- 用于实现基于ipv6的网络通信(暂时用不上)
     第二个参数：通信的类型，决定了具体通信方式;
         SOCK_STREAM  -- 提供有序的可靠的双向的，面向链接的字节流通信方式，也就是基于tcp协议的通信方式;
         SOCK_DGRAM  -- 提供无连接的，不可靠的，非面向连接的数据报通信方式，也就是基于udp协议的通信方式;
     第三个参数：特殊的协议;
         默认给0;
     返回值：
         成功返回新的socket描述符; 失败返回-1;
     函数功能：
         主要用于创建可以实现通信的交流点，也就是socket通信载体;
     2) 通讯地址的数据类型
     a.struct sockaddr类型
       struct sockaddr
       {
             sa_family_t sa_family;
             char        sa_data[14];
       };
        -- 该结构体类型主要用于函数的形参类型，基本不会定义变量使用;
     b.struct sockaddr_un类型
       #include <sys/un.h>
       struct sockaddr_un
       {
            sa_family_t sun_family;//地址族/协议族
                 --与socket函数的第一个实参保持一致即可
            char   sun_path[];//socket文件的路径名
       };
       -- 该结构体主要用于实现本地通信模型中
     c.struct sockaddr_in
       #include <netinet/in.h>
       struct sockaddr_in
       {
           sa_family_t  sin_family;// AF_INET
           in_port_t  sin_port;  // 端口号
           struct in_addr sin_addr;// ip地址
       };
       struct in_addr
       {
            in_addr_t s_addr;//整数类型的ip地址
       };
       -- 该结构体主要用于实现不同主机之间的网络通信模型;

     3) bind函数
         #include <sys/types.h>
         #include <sys/socket.h>
         int bind(int sockfd, const struct sockaddr *addr,    socklen_t addrlen);
     第一个参数：socket的描述符，socket函数的返回值;
     第二个参数：结构体指针，可能需要做类型转换;
     第三个参数：通信地址的大小，使用sizeof计算即可;
     函数功能：
         主要绑定socket和具体的通信地址;

     4) connect函数
        #include <sys/types.h>
        #include <sys/socket.h>
        int connect(int sockfd, const struct sockaddr *addr,  socklen_t addrlen);
     函数功能：
         主要用于连接socket和指定的通信地址，参数和返回值参考bind函数即可;

     5) 主机与网络字节序的转换函数
        #include <arpa/inet.h>
        uint32_t htonl(uint32_t hostlong);
      =>主要用于将32位二进制的主机字节序转换为网络字节序;
        uint16_t htons(uint16_t hostshort);
      =>主要用于将16位二进制的主机字节序转换为网络字节序;
        uint32_t ntohl(uint32_t netlong);
      =>主要用于将32位二进制的网络字节序转换为主机字节序;
        uint16_t ntohs(uint16_t netshort);
      =>主要用于将16位二进制的网络字节序转换为主机字节序;

     6) IP地址的转换函数
        #include <sys/socket.h>
        #include <netinet/in.h>
        #include <arpa/inet.h>
        in_addr_t inet_addr(const char *cp);
      =>主要用于将字符串类型的IP地址转换为整数类型;
        char *inet_ntoa(struct in_addr in);
      =>主要是将结构体类型的IP地址转换为字符串类型;

    复习：
    1.网络的基本常识
    1.1七层网络模型
    应用层，表示层，会话层，传输层，网络层，数据链路层，物理层;
    TCP 传输控制协议，面向连接的协议，类似打电话;
    UDP 用户数据报协议，非面向连接的协议
    IP 上述的底层协议;
    1.2 IP地址，互联网中惟一的标识，本质是32位二进制组成的整数(ipv4),也有128位

    子网掩码：用于划分ip地址的网络地址和主机地址
    ip地址 &子网掩码 = 网络地址;
    1.3 端口号和字节序
       ip地址：定位到具体的某一台主机
       端口号 - 定位到主机中的具体某个进程
       端口号本质是unsiged int 嘞形范围是0～65536,其中0～1024 之间的端口号被系统占用;
       小端系统：将低位字节数据保存在低位内存地址;
       大端系统：
       一般来说，将发送到网络中的多姿接整数，先转换为网络字节序再发送，将所由从网络中接受到的多字节整数，先转换为主机字节序再解析，其中哦怕嗯网络字节序本质就是大选系统的字节序;
    2.基于socket的一对一通信模型
    服务器端：
    1.创建socket，使用socket函数
    2.准备结构体，通信地址
    3.绑定socket和通信地址
    4.进行通信，使用read/write函数
    5.关闭socket，使用close函数
    客户端：
    1.创建socket，使用socket函数
    2.准本通信地址，sghiyong结构体
    3.链接socket，使用connnect函数
    4.进行通信，使用read/write函数
    5.关闭socket，使用close函数;
    ----------------------------------------------------------
    今天的内容
    1.基于tcp协议的通信模型
    2.tcp协议和udp协议的比较
    3.基于udp协议的通信模型

    1.基于tcp协议的通信模型(重点)
    1.1 通信模型
    服务器：
    1.创建socket，使用socket函数;
    2.准备通信地址，使用结构体;
    3.绑定socket和通信地址，使用bind函数;
    4.监听使用listen函数;
    5.相应客户端的链接请求，使用accept函数;
    6.进行通信，使用send/recv函数(专业函数);
    7.关闭socket，使用close函数;
    客户端：
    1.创建socket，使用socket函数;
    2.准备通信地址，使用服务器地址;
    3.连接socket和通信地址，使用connect函数;
    4.进行通信，使用send/recv函数;
    5.关闭socket，使用close函数;

    1.2 相关函数的解析
     1) listen函数
        #include <sys/types.h>          /* See NOTES */
        #include <sys/socket.h>
        int listen(int sockfd, int backlog);
     第一个参数：socket的描述符，socket的返回值;
     第二个参数：主要用于指定悬而未决的连接队列的最大长度;
                (也就是已经发送连接请求，但没有来得及响应的最大数量)
     函数功能：
         主要用于监听指定socket上的连接请求，当用该函数后，该函数会将sockfd所指向的socket标记为被动socket，所谓的被动socket就是专门用于使用accpet函数接受即将到来的请求，也就是不能通信了;

     2) accept函数
        #include <sys/types.h>          /* See NOTES */
        #include <sys/socket.h>
        int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
     第一个参数：socket的描述符，也就是socket函数的返回值;
     第二个参数：结构体指针，用于带出接受的客户端通信地址;
     第三个参数：指针类型，用于带出通信地址地址大小;
     返回值：
         成功返回用于通信的socket描述符; 失败返回-1;
     函数功能：
         主要用于提取listen函数标记的socket中，悬而未决队列中的第一个连接请求，创建一个新的socket用于和响应的客户端进行通信，该socket并不会处于监听的状态;

     3) send函数
        #include <sys/types.h>          /* See NOTES */
        #include <sys/socket.h>
        ssize_t send(int sockfd, const void *buf, size_t len, int flags);
     第一个参数：socket描述符，accpet的返回值;
     第二个参数：具体的缓冲区首地址(即将发送数据的首地址)
     第三个参数：即将发送的数据大小;
     第四个参数：发送的标志，默认给0即可;
     返回值：
         成功返回实际发送的数据大小; 失败返回-1;
         当对方关闭时，该函数的返回值为0;
     函数功能：
         主要用于降至定的消息发送到指定的socket上;

     4) recv函数
        #include <sys/types.h>
        #include <sys/socket.h>
        ssize_t recv(int sockfd, void *buf, size_t len, int flags);
    第一个参数：socket描述符，accpet函数的返回值，主动的socket;
    第二个参数：缓冲区的首地址，用于存放接收到的消息;
    第三个参数：期望接受的数据大小;
    第四个参数：具体的接受方式，默认给0即可;
    返回值：
    函数功能：
        主要用于从之定的socket上接受指定的消息;

    练习：
       使用tcp协议的通信模型实现一对多的通信;
     a.要求服务器可以不断地响应客户端的链接请求
       =>使用无线循环
     b.要求服务器可以同时和多个客户端通信
       =>使用fork函数创建子进程来实现和客户端的通信;
     c.要求服务器和客户端不断地通信;
       =>使用无线循环
     d.当客户端发来"bye"时，对方下线
       =>使用strcmp函数
     e.服务器不断的工作直到，用户按下ctrl+c才结束
       =>使用signal函数;

    2.tcp协议和udp协议的比较
    2.1 tcp协议的概念和特性
        tcp - 传输控制协议，是一种面向连接的协议，类似于打电话;
            - 建立连接 => 进行通信 => 断开连接;
            - 再通信的整个过程中，全程保持连接;
            - 该协议保证了数据传递的可靠性，有序性;
            - 实现了流量的控制，避免数据发送方发送过多数据导致数
              据接收方缓冲区的溢出;
            - 属于全双工的字节流通信方式
              hello world => h e l l o w o r l d
            - 服务器压力比较大，资源消耗比较高，执行效率比较低;
    2.2 udp 基本概念和特性
        udp - 用户数据报协议，非面向连接的协议，类似写信;
            - 在通信过程中，不需要保持连接;
            - 不保证数据传递的可靠性和有效性;
            - 没有实现流量的控制;
            - 属于全双工的数据报通信方式;
            - 服务器压力比较小，资源消耗比较低，执行效率比较高;

    3.基于udp协议的通信模型
    3.1 通信模型
    服务器：
    1.创建socket，使用socket函数;
    2.准备通信地址，使用结构体;
    3.绑定socket和通信地址，使用bind函数;
    4.进行通信，使用send/recv/sendto/recvfrom函数;
    5.关闭socket，使用close函数;
    客户端：
    1.创建socket，使用socket函数;
    2.准备通信地址，使用服务器通信地址;
    3.进行通信，使用send/recv/sendto/recvfrom函数;
    4.关闭socket，使用close函数;

    3.2 相关函数的解析
     1) sendto函数
        #include <sys/types.h>
        #include <sys/socket.h>
        ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);
    函数功能：
        将指定的消息发送到指定的目标地址上，其中四个参数以及返回值和send函数完全一致，第五个参数用于指定收件人的地址，第六个参数用于指定通信地址的大小;

     2) recvfrom函数
        #include <sys/types.h>
        #include <sys/socket.h>
        ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
    函数功能：
        接收发来的消息，并保存消息发送方的通信地址，其中前四个参数以及 返回值和recv函数完全一致，第五个参数用于保存发送方的通信地址，第六个参数用于保存通信地址的大小;

    作业：
        使用udp协议的通讯模型编写一个时间服务器，也就是只要服务器收到客户端发来的消息，则将本机系统时间发给客户端;


    明日预报：
        多线程


    复习：
    tcp协议的通信模型
    服务器：
    1.创建socket，使用socket函数
    2.准备通信地址，使用结构体
    3.绑定通信地址和socket，使用bind函数
    4.监听，使用listen函数
    5.响应监听，使用accept函数
    6.进行通信，使用send/recv函数
    7.关闭socket，使用close函数
    客户端：
    1.创建socket，使用socket函数
    2.准备通信地址，使用服务器通信地址
    3.链接通信地址和socket，使用connect函数
    4.尽心通信，使用send/recv函数
    5.关闭socket，是哟嗯close函数;
    udp协议的通信模型
    服务器：
    1.创建socket，使用socket函数
    2.准备通信地址，使用结构体
    3.绑定socket和通信地址，使用bind函数
    4.进行通信，使用send/reck/sendto/recvfrom函数
    5.关闭socket，使用close函数
    客户端：
    1.创建socket，使用socket函数
    2.准备通信地址，使用服务器通信地址;
    3.进行通信，使用send/recv/sendto/recvfrom函数
    4.关闭socket，使用close函数
    ---------------------------------------------------------
    今天内容：
       1) 多线程的基本概念和操作
       2) 多线程的同步问题


    1.多线程的基本概念和操作
    1.1 基本概念
        目前主流的操作系统支持多进程，而每一个进程的内部又支持多线程，也就是说线程是隶属于进程内部的程序流，同一个进程中的多个线程并行处理;
        进程是重量级的，每个进程都需要独立的内存空间，因此新建进程对于资源的消耗比较大;而线程是轻量级的，新建线程会共享再进程的内存资源，但是每个线程都拥有一块独立的栈区;

    1.2 线程的创建
     1) pthread_create函数
        #include <pthread.h>
        int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);
     第一个参数：用于存放新线程的编号;
     第二个参数：用于指定线程的属性，给NULL表示采用默认属性;
     第三个参数：函数指针类型，用于指定新线程的处理函数;
     第四个参数：指针类型，用于第三个参数指向的函数传递实参;
     返回值：
         成功返回0;失败返回错误编号;
     函数功能：
         主要用于再当前正在调用进程中启动一个新线程;
         Compile and link with -pthread.

     2) 线程之间的关系
        执行main函数的起始线程 叫做 主线程;
        使用pthread_create()函数创建出来的新线程 叫做 子线程;
        当子线程创建成功后，两个线程各自独立运行，子线程执行对应的线程处理函数，主线成继续向下执行，两个线程之间的执行先后次序忧草座席同调用算法决定;
        两个线程之间相互独立，又相互影响，当主线程结束时，会导致整个进程结束，当整个进程结束时，又会结束进程内的所有线程;

    1.3 线程编号的获取和比较
     1) pthread_self函数(获取自身线程ID编号)
        #include <pthread.h>
        pthread_t pthread_self(void);
    函数功能：
        主要用于获取当前正在调用线程的编号，并通过返回值返回;
        Compile and link with -pthread.
     2) pthread_equal函数(两个线程编号的比较函数)
        #include <pthread.h>
        int pthread_equal(pthread_t t1, pthread_t t2);
    函数功能：
        主要用于比较两个线程的ID是否相等，如果相等返回非0,不相等返回0;
        Compile and link with -pthread.

    练习：
        使用pthread_create函数创建一个子线程，在子线程处理函数中根据参数传入的半径计算轴承河面集并打印;

    1.4 线程的汇合和分离
     1) pthread_jion函数
        #include <pthread.h>
        int pthread_join(pthread_t thread, void **retval);
    第一个参数：具体的线程ID;
    第二个参数：用于获取线程的退出状态;
    函数功能：
        主要用于等待参数thread指定的线程终止，如果参数thread指向的线程终止了，则该函数立即返回，当然要求该线程必须是可汇合/等待的;
        如果第二个参数不为NULL，则该函数会将目标线程的退出状态信息拷贝到*retval指向的位置中，也就是一级指针的内容;
        Compile and link with -pthread.

    练习：
        使用pthread_create函数创建子线程，在线程处理函数中计算1|～100之间的和并放到sum中，返回sum的地址，在主线程中调用pthread_join函数等待子线程结束，并获取退出状态，打印出来;
        vi 04join.c

     2) pthread_detach函数
        #include <pthread.h>
        int pthread_detach(pthread_t thread);
    函数功能：
        主要用于将参数指定的线程设置为分离状态的线程，当一个分离状态的线程终止时，他的资源会被自动释放给系统，不需要其他线程来汇合/帮助，也就是分离状态的线程无法被pthread_join函数等待/汇合;

        Compile and link with -pthread.

    1.5 线程的终止和取消
     1) pthread_exit函数
        #include <pthread.h>
        void pthread_exit(void *retval);
    函数功能：
        主要用于终止当前正在调用的线程，并通过参数返回当前线程的退出状态信息，可以使用同一个进程中其他线程调用pthread_join函数来获取该退出信息;
        Compile and link with -pthread.

    练习：
        vi 05exit.c 启动子线程，子线程的处理函数中负责打印1～20之间的整数，每隔一秒打印一次，当i的值为10时，终止当前线程，并返回i的值，主线负责等待并获取退出状态信息;

     2) pthread_cancel函数
        #include <pthread.h>
        int pthread_cancel(pthread_t thread);
    函数功能：
        主要用于给参数指定的线程，发送取消的请求，默认状态下是可以被取消的，是否被取消，何时被取消可以通过以下两个函数进行设置;
        Compile and link with -pthread.

        #include <pthread.h>
        int pthread_setcancelstate(int state, int *oldstate);
    第一个参数：用于指定最新的状态;
        PTHREAD_CANCEL_ENABLE  -- 可以被取消(默认)
        PTHREAD_CANCEL_DISABLE -- 不可以被取消
    第二个参数：用于带出设置之前的状态;
        给NULL表示不带出;
    函数功能：
        主要用于设置当前线程是否可以被取消;

        int pthread_setcanceltype(int type, int *oldtype);
    第一个参数：用于指定线程的新类型
        PTHREAD_CANCEL_DEFERRED   -- 表示延迟取消(默认);
        PTHREAD_CANCEL_ASYNCHRONOUS  -- 表示立即取消;
    第二个参数：用于带出线程旧类型，不想带出给NULL;
    函数功能：
        主要用于设置当前线程何时被取消;
        Compile and link with -pthread.

    2.线程的同步问题
    2.1 基本概念
        多线程之间共享所在进程的资源，当多个线程同时访问同一种共享资源时，需要相互协调，以避免造成数据的不一致和不完整问题，而线程之间的协调和通信就叫做线程的同步问题;

    2.2 使用互斥量实现线程的同步
     1) 定义互斥量
        pthread_mutex_t mutex;
     2) 初始化互斥量
        pthread_mutex_init(&mutex,NULL);
     3) 使用互斥量进行加锁
        pthread_mutex_lock(&mutex);
     4) 访问共享资源
     5) 使用互斥量进行解锁
        pthread_mutex_unlock(&mutex);
     6) 如果不在使用，则删除互斥量
        pthread_mutex_destroy(&mutex);

    2.3 使用信号量实现线程的同步
        信号量 - 本质上就是一个计数器，用于控制同时访问同一种共享资源的进程/线程个数;
        当信号量的初始值为一时，效果等同于互斥量;
     1) 具体流程：
        #include <semaphore.h>
        1.定义信号量
          sem_t sem;
        2.初始化信号量
          sem_init(&sem,0,信号量的初始值);
        3.获取信号量，也就是信号量数值减一
          sem_wait(&sem);
        4.访问共享资源
        5.释放信号量，也就是信号量数值加一
          sem_post(&post);
        6.如果不再使用，则删除信号量
          sem_destroy(&sem);

    作业：
        1.变成实现基于tcp协议通信模型的简易聊天室
      => 参考课堂上讲过的一对多通信模型案例
      => 采用多线程技术替换多进程
      => 将服务器每次收到的消息发给其他所有在线用户
      => 要求客户端启动时输入一个昵称
      => 要求客户端的收发消息功能各自独立运行

        2.在上述案例的基础上，实现文件的传输
        3.采用多线程和网络编程重构银行账户系统


    明日预报：
        学习oracle数据库


三、c++编程

标准C++语言
讲师：闵卫，minwei@tedu.cn
从C到C++语言
类和对象
操作符重载
继承和多态
异常
I/O流
一、C++语言背景介绍
1.致敬与缅怀
Ken Thompson，肯.汤普逊，B语言之父
Algo 68
- Fortran 77/90，数值计算
- CPL，系统编程，太复杂
- BCPL，CPL语言简化版
- B语言，第一个UNICS/UNIX操作系统内核，缺乏数据类型，缺少指针
Dennis Ritchie，丹尼斯.里奇，C语言之父，UNIX之父，黑客之父
Bjarne Stroustrup，本贾尼.斯特劳斯特鲁普，C++之父
simula/B语言
1979-Cpre，用C语言的宏定义模拟类型simula中类的概念
1983-C with Classes，纯粹的前端编译器，得名C++语言
1985-CFront 1.0，第一个商用C++语言编译器
1987-GNU C++发布
1990-Borland C++发布
1992-Microsoft C++发布，IBM C++发布
1998-ISO C++98标准
2003-ISO C++03标准，对98标准修订
2011-ISO C++11标准，对98标准革命性的改变和升级
2014-ISO C++14标准，对11标准的扩充
2017-预计推出最新的语言标准，期待中...
二、第一个C++程序——Hello, World !
1.编译器
g++ hello.cpp
gcc hello.cpp -lstdc++
2.扩展名
.cpp/.cc/.C/.cxx
也可以用.c，但是要加上-x c++编译选项
3.头文件
#include <iostream>
也可以用
#include <cstdio>
或者
#include <stdio.h>
4.I/O流对象
C++对象             C流指针  UC文件描述符
cin    - 标准输入 - stdin   - 0
cout - 标准输出 - stdout - 1
cerr  - 标准出错 - stderr  - 2
5.插入和提取运算符
<< - 插入，将右操作数对象插入到左操作数对象中
>> - 提取，从左操作数对象中提取数据到右操作数对象中
6.名字空间和作用域限定操作符
std - 所有标准C++提供的类型、函数、对象都位于该名字空间中
:: - 表示其右操作数隶属于其左操作数所表示的作用域——“的”
三、名字空间
1.为什么需要名字空间——WHY？
1)名字冲突
namespace ns1 {
int x = 10;
}
namespace ns2 {
int x = 20;
}
2)模块划分
namespace network {
   send
   recv
   connect
   ...
}
namespace biz {
   save
   draw
   query
   ...
}
2.什么是名字空间——WHAT？
namespace 名字空间名 {
    名字空间成员1;
    名字空间成员2;
    ...
}
名字空间成员：变量、函数或者类型，但是宏定义不受名字空间限制。
同名名字空间的成员无论被声明在同一个文件中还是不同的文件中，最终都会被编译器合并为一个名字空间：
namespace 名字空间名 {
    名字空间成员1;
}
namespace 名字空间名 {
    名字空间成员2;
}
namespace 名字空间名 {
    ...
}
名字空间中的函数，声明和定义如果分开书写，其定义部分必须借助作用域限定操作符“::”明确所定义的函数隶属于哪个名字空间，以与该函数的声明保持一致。
3.怎用用名字空间——HOW？
1)在名字空间内部访问本空间中的名字，可以直接访问，无需做任何限定。
2)在名字空间外部访问某空间中的名字
A.作用域限定操作符：名字空间名::名字空间成员名
如：icbc::save (10000);
B.名字空间指令：using namespace 名字空间名;
名字空间指令以后的代码，对指令中的名字空间中的所有成员均可见，在不发生冲突的前提下，可以省略作用域限定操作符，直接访问之。
C.名字空间声明：using 名字空间名::名字空间成员名;
将特定名字空间中的特定成员引入当前作用域，在不发生冲突的前提下，可以省略作用域限定操作符，直接访问之。
D.匿名名字空间：不属于任何有名空间的标识符，会被编译器缺省地置入匿名名字空间中，当存在名字冲突时，可以通过作用域限定操作符，指明所访问的标识符源自该匿名空间。
E:名字空间内部还可以定义名字空间，形成名字空间嵌套。访问内层空间中的标识符，需要通过作用域限定操作符从外到内逐层分解，也可以利用名字空间别名，简化空间路径的书写形式。
四、结构、联合和枚举
1.用这三种自定义类型声明变量，其前导关键字可以省略。
struct Student {
     char name[64];
     int age;
     int sex;
};
struct Student sa = {"张飞", 22, 1}, sc = {"赵云", 20, 0};
---^--
  前导
关键字
Student sa = {"张飞", 22, 1}, sc = {"赵云", 20, 0};
2.C++的结构体允许定义函数形式的成员，谓之成员函数，而变量形式的成员，则被称为成员变量。
3.C++增加了匿名联合的用法，所谓匿名联合其本质并不是定义数据类型，而是规定了变量在内存中的布局形式。
4.C++的枚举是独立的数据类型，和整型之间的类型转换需要服从编译器内置的转换规则：
枚举 -隐式-> 整型
枚举 <-显式- 整型
五、字符串
#include <string>
typedef basic_string<char> string;
string s1, s2;
六、布尔型
bool - true/false
1个字节，1就是true，0就是false。
任何类型的字面值、变量或表达式都可以被隐式转换为bool类型，其转换规则就是源值为零即假，非零即真。
七、操作符别名
{ - <%
} - %>
[ - <:
] - :>
&& - and
|| - or
! - not
& - bitand
| - bitor
^ - xor
...
int main (void) <%
    int a<::> = <%1,2,3,4,5%>;
    int b = a<:0:> xor a<:1:>;
    return 0;
%>
ISO-646标准
八、函数重载
1.同一个作用域中，函数名相同，参数表不同的函数，构成重载关系。
2.编译器根据调用函数是所提供实参的类型，在多个重载版本中挑选一个匹配程度最高的版本，以供调用，这个过程叫做重载解析。

八、函数重载
1....
2....
3.类型转换对重载解析的影响
加常转换>升级转换>有损转换>省略号匹配
4.C++换名
1)函数重载实际上是通过编译器对函数名的替换实现的，被换过的函数名中包含了参数表的类型信息，因此具有重载关系的函数，在目标模块中的函数名是不同的。
2)通过extern "C"关键字可以要求C++编译器按照C的方式处理函数接口，即不做换名，当然也就无法重载。
3)如果一个头文件同时被C和C++编译器处理，可以通过预定义宏__cplusplus加以区分，该宏仅在C++编译器中有定义。
------------------------------------------------------------------
一、缺省参数
1.可以为函数的部分或全部参数指定缺省值，调用该函数时如果未提供相应的实参，则该参数取缺省值。
2.如果函数的某一个参数带有缺省值，那么该参数后面的所有参数必须都带有缺省值。
3.函数的缺省参数是在编译阶段解决的，因此只能用常量、常量表达式或者全局变量等非局部化数值作为函数的缺省实参。
4.如果需要将函数的声明和定义分开书写，那么该函数参数的缺省值只能出现在函数的声明部分，函数定义不能带有缺省参数。
5.尽量避免缺省参数和重载发生歧义。
二、哑元
1.只有类型没有名字的函数形参，谓之哑元。
2.哑元主要用于向下兼容和构成重载。
三、内联
1.内联就是用函数已被编译好的二进制代码，替换对该函数的调用指令。
2.内联在保证函数特性的同时，避免了函数调用的开销。
3.内联通过牺牲代码空间，赢得运行时间。
4.内联除了作为编译器默认的优化策略以外，也可以人为指定：
1)在结构体和类中直接给出函数的定义
struct Dog {
    ...
    void who (void) { ... } // 隐式内联
    ...
};
2)通过inline关键字显式指定内联
inline void foo (void) { ... }; // 显式内联
struct Dog {
    ...
    inline void who (void); // 显式内联
    ...
};
void Dog::who (void) { ... }
无论隐式还是显式，所谓的“人为指定”内联并非强制，而是一种对编译器内联机制建议或者说是一种期望，最终是否真的会被内联，还是要有编译器的优化策略决定。而所谓编译器的优化策略简单讲就是对于频繁调用的简单函数进行内联，而对于稀少调用的复杂函数拒绝内联。另外，还有一些函数不能被内联，比如递归函数和带有动态绑定特性的函数(即只有到运行时才能确定入口地址的函数)。
自递归：
inline void digui (void) { // 编译器直接忽略inline
   ...
   digui ();
   ...
}
交叉递归：
void foo (void) {
    ...
    bar ();
    ...
}
void bar (void) {
    ...
    foo ();
    ...
}
循环递归：
void foo (void) {
    ...
    bar ();
    ...
}
void bar (void) {
    ...
    hum ();
    ...
}
void hum (void) {
    ...
    foo ();
    ...
}
四、动态内存分配
1.完全兼容C方式的动态内存分配
#include <stdlib.h>
malloc/calloc/realloc/free
2.独立的内存分配操作符
分配/销毁单个对象：new/delete
分配/销毁对象数组：new[]/delete[]
操作符都是编译器提供的，不需要标准库，也不需要头文件。
3.用malloc/calloc/realloc分配的内存通过free释放，用new分配的内存通过delete释放，用new[]分配的内存通过delete[]释放。不要混合使用分配和释放。
4.避免重释放。
free (p);
free (p);   // 吐核 \
delete p;               > double free
delete p;  // 吐核 /
5.与malloc/calloc/realloc函数通过返回空指针报告内存分配失败不同，new以抛出bad_alloc异常的方式向调用者通知错误。
6.new和malloc/calloc/realloc的不同之处在于除了分配堆内存以外，还会调用相应类型的构造函数，delete和free的不同之处在于除了释放所配分配的堆内存以外，还会调用相应类型的析构函数。
new = malloc+调用构造函数
delete = 调用析构函数+free
五、引用
1.概念：引用即别名。
int a = 10;
int& b = a; // b是a的引用(别名)
诸葛亮
孔明
卧龙
A.引用必须初始化
int a;
int& b; // 错误
B.引用不能为空
int* p = NULL; // 什么都不指向的指针，空指针
int& b = NULL; // 错误
C.引用的目标不能更换
int a, b;
int* p = &a; // p的目标是a
p = &b; // p的目标是b
-----------------------------
int a, b;
int& r = a; // r的目标是a
r = b; // 将b的值赋给a
2.应用
1)引用型参数
通过将函数的形参声明为对实参的引用，使函数得以修改实参变量的值，提供比指针传递更加简洁安全的数据输出方式。
2)常引用型参数
A.通过将函数的形参声明为对实参的常引用，一方面避免了参数传递过程中的内存复制开销，另一方面有效降低了在函数内部意外修改实参的风险。
B.常引用型参数还可以用于接收右值形式的实参。
可以放在赋值运算符左侧的就叫左值，只能放在赋值运算符右侧的就叫右值。其值可被修改的即左值，不可修改的即右值。
int a; // a是左值
int const a; // a是右值
cout << 10 << endl; // 10是右值
int a = 1, b = 2;
cout << a + b << endl; // a+b是右值
int a = 10;
double b = (double)a; // (double)a是右值
常引用亦称万能引用，既可以引用左值，也可以引用右值，但普通引用只能引用左值，不能引用右值。
3)返回引用
foo () = 100;
永远不要返回引用局部变量的引用，除非有特殊需要。

四、...
2....
4)初始化表
初始化表是类构造函数中的特殊结构，用于告诉编译器如何生成对成员变量进行初始化的代码。
class 类名 {
    // 构造函数
    类名 (形参表) : 成员变量1 (初始值), 成员变量2 (初始值) {
        ...             |<------------- 初始化表 --------------->|
    }
    数据类型 成员变量1;
    数据类型 成员变量2;
};
一般而言，对成员变量的初始化既可以在构造函数体中通过赋值完成，也可以在初始化表中完成，但是以下两种情况只能选择后者：
A.类类型的成员变量或基类子对象，如果没有缺省构造函数，那么它们就只能在初始化表中，显式指明所要调用的有参构造函数版本。
B.类中的常量或引用型成员变量也只能通过初始化表指定初值。
类的成员变量按其在类中的声明顺序依次被初始化，而与其在初始化表中的排列顺序无关。初始化表并不是可执行语句，它的作用仅仅是告诉编译器生成初始化代码时所引用的初始值是什么。
------------------------------------------------------------------
五、非内联的形式定义类
内联形式定义：将类的构造函数和成员函数直接定义在类的声明中，这些函数只要不是递归函数也不是动态函数，编译器会缺省地将其以内联的方式进行优化。
非内联形式定义：将类的声明放在头文件(.h)中，将类的实现，即函数定义，放在源文件中(.cpp)中，而将对类的实例化再放在一个独立的源文件(.cpp)中。现代版本的编译器，对非内联形式定义的类，也会进行必要的内联优化。
六、this指针
1.类的每个成员函数都有一个隐藏的指针型参数名为this，该指针指向调用这个成员函数的对象。类的构造和析构函数中同样有this指针，指向这个正在被构造或析构的对象。
2.在类的成员函数、构造函数以及析构函数中，对所有成员变量的访问，都是通过this指针进行的。
3.多数情况下，并不需要显式地使用this指针，除非在以下上下文中：
A.作用域名字冲突
B.从成员函数中返回调用对象的自拷贝或自引用
C.从成员函数内部向外传递调用对象自身
七、常函数
1.如果一个类的成员函数被声明为常函数，那么它的this指针就是一个常量指针，在该函数中一切试图修改成员变量的操作，都会被编译器视为非法，除非该变量带有mutable关键字。
2.原型相同的成员函数其常版本和非常版本可以构成重载关系，常对象、常引用、常指针匹配常版本，非常对象、非常引用、非常指针匹配非常版本，但是如果没有非常版本，那么非常对象、非常引用、非常指针也可以匹配常版本。
常 -> 常
      /
    /
非 -> 非
3.只要一个类的成员函数不修改该类的任何成员变量，也不调用任何可能修改成员变量的成员函数，那么该成员函数就可以被声明为常函数。
八、析构函数
1.析构函数是类中特殊的成员函数：
1)函数名就是类名前面加"~"；
2)没有返回类型
3)没有参数
4)不能重载
class 类名 {
public:
    ~类名 (void) {
        析构函数体;
    }
};
2.析构函数在对象被销毁时由系统自动调用
1)静态对象离开作用域时被销毁
2)动态对象由delete/delete[]操作符销毁
3)析构函数在对象的整个生命周期仅被调用一次
3.析构函数主要任务就是释放对象生命过程中所产生的资源
4.如果一个类没有显式定义析构函数，编译器也会提供一个缺省析构函数，该析构函数只负责调用类类型成员变量和基类的析构函数，对我们自己动态分配的资源不予理睬，因此有必要为这些资源编写自己的析构函数，予以释放，防止出现内存泄漏。
九、支持深拷贝的拷贝构造拷贝赋值
1.编译器提供的缺省拷贝只对对象进行浅拷贝，指针类型的成员只是按字节复制其本身，而不复制其目标内容，这样的结果就是，拷贝目标对象和拷贝源对象共享一份内容资源，不仅发生资源耦合，而且还有double free异常的风险。
2.通过自己定义拷贝构造函数和拷贝赋值操作符函数，可以实现同类型对象间的深拷贝语义，即分配独立资源并复制内容，既保证拷贝目标对象和源对象不发生资源耦合，同时避免了double free异常的风险。
3.只要一个类含有指针型成员变量，而且该变量所指向的内存是该类动态产生的，那么就有必要为其定义支持深拷贝的拷贝构造函数和拷贝赋值操作符函数。
4.拷贝构造和赋值不仅开销巨大而且还有浅拷贝风险，因此应该尽可能避免出现拷贝构造和赋值，比如通过引用传递参数，或者从函数返回。

局部变量       --- 栈区
静态局部变量 \
全局变量         > 静态区(数据区+BSS区)
静态全局变量 /
动态变量       --- 堆区
成员变量       --- 对象所在区
一、静态成员
1.静态成员变量
1)静态成员变量是类的一部分，而不是对象一部分，不存在于该类任何对象内部，却可为该类的任何对象所共享，和全局变量一样存放在静态区中，既可以通过对象访问，也可以通过类直接访问。
2)语法：声明时需要增加static关键字，定义和初始化必须在类的外部单独进行。
3)应用：既满足类型的封装和保护，同时又为该类的对象所共享。既象成员变量受类型和访问控制属性的限制，又象全局变量不拘泥于某一个具体的对象。
class Account {
public:
    string m_name;
    int m_id;
    string m_passwd;
    double m_balance;
    ...
    static void setRate (float rate) {
        m_rate = rate;
    }
    ...
private:
    static float m_rate;
};
2.静态成员函数
1)被声明为静态成员函数的成员函数，没有this指针，因此不需要通过对象来调用，当然也就无法访问任何与对象有关的资源。
2)静态成员函数只能访问静态成员，但是非静态成员函数既可以访问非静态成员也可以访问静态成员。
3.静态成员的应用——单例模式
1)构造函数私有化——禁止在外部创建对象
2)在类的内部创建唯一对象实例——内部可以访问私有构造函数(静态成员)
3)提供公开接口以方便在类的外部获取对象实例(静态成员)
二、成员指针
class Student { ... };
Student student;
string* pname = &student.m_name; // 不是成员指针
1.指向成员变量的指针
类型 类名::*成员变量指针;
成员变量指针 = &类名::成员变量;
对象.*成员变量指针 // .* : 成员指针解引用运算符
对象指针->*成员变量指针 // ->* : 间接成员指针解引用运算符
成员变量指针的本质，就是特定成员变量在类对象实例中的相对地址。成员变量指针解引用，就是根据类对象实例的起始地址，结合成员变量指针中的相对地址，计算出具体成员变量的绝对地址，并访问之。
2.指向成员函数的指针
返回类型 (类名::*成员函数指针) (形参表) [常属性];
成员函数指针 = &类名::成员函数名;
(对象.*成员函数指针) (实参表);
(对象指针->*成员函数指针) (实参表);
------------------------------------------------------------------
int foo (int a, int b) { ... }
int (*pfun) (int, int) = foo;
pfun (100, 200);
--------------------------------
int (*pfun) (int, int) = &foo;
(*pfun) (100, 200);
------------------------------------------------------------------
虽然成员函数并不存储在对象中，不存在根据相对地址计算绝对地址的问题，但也要通过对象或对象指针对成员函数指针解引用，其目的只有一个，即提供this指针。
三、操作符重载
1.基本思想：在特定条件下，C++编译器有能力把一个由操作数和操作符组成表达式，解释为一个全局或者成员函数调用，该全局或成员函数被称为操作符函数。程序设计者通过自己定义操作符函数，可以实现针对自定义类型的运算法则，并使之与内置类型一样参与各种表达式的运算。
复数：3+4i
2.运算类双目操作符
L#R
L.operator# (R); // 左调右参
::operator# (L, R); // 左一右二
3.插入提取操作符
cout << R;
::operator<< (cout, R);
cin >> R;
::operator>> (cin, R);
4.运算类单目操作符
#O/O#
O.operator# ();
::operator# (O);
5.自增减操作符
++O
O.operator++ ();
::operator++ (O);
O++
O.operator++ (0);
::operator++ (O, 0);

三、...
6.下标操作符([])
用于在容器类型中以下标方式访问其中的数据元素。
class 容器类型 {
public:
    元素类型& operator[] (int i) { ... }
    元素类型 const& operator[] (int i) const {
         return const_cast<容器类型&> (*this) [i];
    }
};
7.函数操作符(())
如果为一个类定义了形如：operator()的操作符函数，那么该类的实例化对象就可以被当做函数看待，所调用的就是operator()操作符函数，该操作符函数是唯一一种参数个数和返回值类型完全自由指定的操作符函数。一般把这种支持函数操作符的对象称为仿函数或函数子。
8.解引用(*)和间接成员访问(->)操作符
目标对象类型& operator* (void) {
    return 目标对象;
}
目标对象类型* operator-> (void) {
    return 目标对象的地址;
}
智能指针
#include <memory>
auto_ptr<T>: T可以是任何类型，用于封装一个动态对象的指针，通过局部智能指针对象在离开作用域时被析构的过程，delete动态创建的对象，避免内存泄漏。
9.自定义类型转换
1)类型转换构造函数
class 目标类型 {
    目标类型 (源类型 const& src) { ... }
};
2)类型转换操作符函数
class 源类型 {
   operator 目标类型 (void) { return 目标类型对象; }
};
3)源类型是基本类型，只能通过构造函数实现自定义类型转换；目标类型是基本类型，只能通过类型转换操作符函数实现自定义类型转换；源类型和目标类型都不是基本类型，两种自定义类型转换的实现方式可以任取其一，但是不要同时使用，避免歧义；源类型和目标类型都是基本类型，无法实现自定义类型转换，完全编译器的内置规则实现两种类型的转换。
4)explicit关键字的作用是将自定义类型转换强制为显式，C++98中该关键字只能被用于类型转换构造函数，C++2011则将其扩展到类型转换操作符函数。
10.new/delete操作符
11.操作符重载的限制
1)不是所有的操作符都能重载，以下操作符不允许被重载：
作用域限定操作符(::)
直接成员访问操作符(.)
直接成员指针解引用操作符(.*)
条件操作符(?:)
字节长度操作符(sizeof)
类型信息操作符(typeid)
2)所有操作数都是基本类型的操作符无法重载
int operator+ (int a, int b) {
    return a - b;
}
x = 1 + 1;
cout << x << endl; // 0 ?
3)操作符重载无法改变优先级
Integer const operator^ (Integer const& x, int y) { ... }
计算x的y次方
d = a + b ^ c; // (a + b) ^ c
4)操作符重载无法改变操作符的目数
double operator% (Integer const& i) {
    return i.m_i / 100.0;
}
x = 50%; // 0.5 ?
5)无法通过操作符重载发明新的操作符
Double const operator@ (Double const& a,
    Double const& b) {
    return Double (sqrt (a.m_d * a.m_d + b.m_d * b.m_d));
}
c = 3.0 @ 4.0; // 5.0 ?
6)重载操作符不要违背正常人类的习惯，不要破坏代码的可读性，不要使操作符重载成为炫耀语法特性的奇技淫巧。
------------------------------------------------------------------
一、类的继承
1.继承的基本概念
共性与个性
第一级抽象：从对象的属性和行为到类
学生：姓名、年龄、学号、吃饭、睡觉、学习
教师：姓名、年龄、工资、吃饭、睡觉、授课
第二级抽象：从不同的类型提取共同属性和行为
共性：类型间相同的属性和行为
个性：类型间不同的属性和行为
                          人：姓名、年龄、吃饭、睡觉—基类(父类)
                         /  \                               派生V^继承
学生：学号、学习    教师：工资、授课            —子类(派生类)
2.继承的语法
class 子类 ：继承方式1 基类1, 继承方式2 基类2, ... { ... };
                 |<-------------- 继承表 --------------->|
所有基类中的成员除了构造和析构函数以外都可以被子类所继承，无论是在子类内部还是在子类外部，只要所访问的基类成员不是私有成员，都可以和子类自身成员一样，直接访问——皆然性——一个子类对象就是一个基类对象(ISA)。
继承方式：
public       - 公有继承，最为常见
protected - 保护继承 \ 不多见
private     - 私有继承  / 应避免
3.公有继承
1)逻辑：子类即基类。
2)物理：父类的子类对象是其父类子对象的父对象。

一、...
3....
3)向上和向下造型
A.向上造型
把一个子类类型的指针或引用转换为其基类类型的指针或引用。
向上造型在编译器看来是安全的，因此可以隐式完成。
class Human { ... };
class Student : public Human { ... };
class Teacher : public Human { ... };
Student student (...);
Student* ps = &student;
Human* ph = ps; // 向上造型
B.向下造型
把一个基类类型的指针或引用转换为其子类类型的指针或引用。
向下造型在编译器看来是有风险的，因此必须显式完成。
Human human (...);
Human* ph = &human;
Student* ps = ph; // 向下造型，编译失败
C.编译器对类型安全所做的检测，仅仅基于指针或引用本身的数据类型，而与其目标对象的实际类型无关。基类类型的指针或引用实际目标对象的类型，究竟是否与需要转换的指针或引用的目的类型一致，完全由程序员自己判断。在确认安全性的前提下，可以通过静态类型转换（static_cast<>）实现显式的向下造型。
4)保护成员
被protected访问控制属性约束的成员被称为类的保护成员，该成员仅可以被声明该成员的类及其子类访问。
              类内部  子类中 类外部 友元中
公有成员    OK       OK      OK      OK
保护成员    OK       OK      NO      OK
私有成员    OK       NO      NO      OK
5)区分隐藏和重载
A.只要子类中含有和基类中同名的标识符即构成名字隐藏，在不使用任何作用域限定前提下，直接访问到的都是子类中的名字，通过作用域限定才可以访问到基类中的名称。
B.基类和子类虽然存在派生和继承的逻辑关系，但它们毕竟是两个不同的类型，即各自拥有独立的作用域，因此即使是同名异参的成员函数也不能构成重载关系，除非通过using声明强制其同处于一个作用域中。
4.私有继承和保护继承
1)继承方式对访问控制属性的影响
当通过一个子类类型的对象访问它从基类继承的成员时，不同的继承方式会影响该成员在子类中访问控制属性。
公有继承，成员在基类中的访控属性和在子类中访控属性完全一致。
私有继承，基类中的所有成员在子类中都被视为私有成员。
保护继承，基类中的公有成员在子类中被视为保护成员。
class DCT { // $100
public:
    void codec (void) { ... }
};
class Jpeg : /*private*/protected DCT { // $1
public:
    void render (const char* jpgFile) {
        ...
        codec ();
        ...
     }
};
class Jpeg2000 : public Jpeg {
public:
    void render (const char* jpgFile) {
        ...
        codec ();
        ...
     }
};
Jpeg jpeg (...);
jpeg.render ("sea.jpg");
jpeg.codec (); // 报错
私有继承：防止基类中的公有成员通过子类被扩散出去。
保护继承：防止基类中的公有成员通过子类被扩散到继承链的外部，但是并不妨碍子类的子类继续访问。
私有继承和保护继承在逻辑上不存在皆然性，即没有IsA的关系。因此无论哪种继承都不能隐式地向上造型。
5.子类的构造、析构、拷贝构造和拷贝赋值
子类对象中包含了基类子对象，因此子类的构造、析构、拷贝构造和拷贝赋值，就必须同时兼顾其基类子对象的构造、析构、拷贝构造和拷贝赋值。
1)子类的构造函数
A.隐式构造基类部分：如果子类的构造函数没有显式指明基类部分的构造方式，那么编译器会选择基类的缺省构造函数，构造该子类对象中的基类子对象。这样做的前提就是基类中必须有缺省构造函数，否则将导致编译失败。
B.显示构造基类部分：子类的构造函数可以在初始化表中显式指明其基类部分的构造方式，即通过其基类的特定构造函数，构造该子类对象中的基类子对象。
C.子类对象的构造过程：子类的构造函数执行如下步骤
a)首先，按照继承表的顺序，依次调用各个基类的构造函数，构造子类对象中的基类子对象；
b)其次，按照声明的顺序，依次调用各个类类型成员变量相应类型的构造函数，构造子类对象中的成员子对象；
c)最后，执行子类构造函数体中的代码，完成整个构造过程。
2)子类的析构函数
A.子类的析构函数，无论是自己定义的，还是编译器提供的，在执行完其中的析构代码，并析构完所有的类类型成员子对象以后，会自动调用其基类的析构函数，析构该子类对象中的基类子对象。析构的顺序和构造的顺序一定是严格对称的。
B.对一个指向子类对象的基类指针使用delete操作符，实际被调用的将是基类的析构函数，该函数不会调用子类的析构函数，其所析构的仅仅是子类对象中的基类子对象，而子类的扩展部分极有可能因此而形成内存泄漏。实践中可以通过静态类型转换对基类指针做向下造型，解决此问题。
3)子类对象的拷贝
A.如果子类没有定义拷贝构造/赋值函数，那么编译器为子类提供缺省拷贝构造/赋值函数，该函数会自动调用其基类的拷贝构造/赋值函数，拷贝子类对象中的基类子对象。
B.如果子类定义了拷贝构造/赋值函数，但是没有显式指明基类子对象的拷贝方式，那么编译器要么以缺省方式初始化该子对象，要么令该子对象保持原状，均无法获得完整意义上的子对象副本。
C.如果子类定义了拷贝构造/赋值函数，同时也显式指明了基类子对象的拷贝方式，那么子对象中基类部分和扩展部分将被一起复制，最终得到完整意义上的子类对象副本。
6.多重继承
1)概念
如果一个子类同时从多个基类继承，就形成多重继承的结构。
技术员    经理     销售员
         \  /      \   /
   技术主管   销售主管
学生     教师
      \   /
   项目经理
电话   播放器   计算机
      \      |      /
        智能手机
2)语法：在类的继承表中依次写出子类的每个基类及其继承方式。
class 子类 : 继承方式1 基类1, 继承方式2 基类2, ... { ... };
子类从多个基类中继承它们的成员，任意一个基类的成员都可以被当做子类的成员，在子类的内部或外部被访问，前提是不违背访问控制属性和继承方式的约束。
3)对象模型
A.子类对象中的多个基类子对象，按照继承表的顺序依次被构造，并从低地址到高地址排列，析构的顺序则与构造的顺序相反。
B.将继承自多个基类的子类类型的指针，隐式或静态转换为它的基类类型，编译器会根据各个基类子对象在子类对象中的内存布局，进行适当的偏移计算，以保证指针的类型与其所指向目标对象的类型一致，反之亦然。
4)名字冲突与重载
A.如果多个基类存在相同的标识符，将在子类中产生名字冲突，可以通过作用域限定解决。
B.在不同基类中声明的同名异参成员函数，由于存在名字冲突，且作用域不同，因而无法在子类中形成重载，除非通过using声明将其强制引入子类的作用域，构成重载关系。

一、...
3....
3)向上和向下造型
A.向上造型
把一个子类类型的指针或引用转换为其基类类型的指针或引用。
向上造型在编译器看来是安全的，因此可以隐式完成。
class Human { ... };
class Student : public Human { ... };
class Teacher : public Human { ... };
Student student (...);
Student* ps = &student;
Human* ph = ps; // 向上造型
B.向下造型
把一个基类类型的指针或引用转换为其子类类型的指针或引用。
向下造型在编译器看来是有风险的，因此必须显式完成。
Human human (...);
Human* ph = &human;
Student* ps = ph; // 向下造型，编译失败
C.编译器对类型安全所做的检测，仅仅基于指针或引用本身的数据类型，而与其目标对象的实际类型无关。基类类型的指针或引用实际目标对象的类型，究竟是否与需要转换的指针或引用的目的类型一致，完全由程序员自己判断。在确认安全性的前提下，可以通过静态类型转换（static_cast<>）实现显式的向下造型。
4)保护成员
被protected访问控制属性约束的成员被称为类的保护成员，该成员仅可以被声明该成员的类及其子类访问。
              类内部  子类中 类外部 友元中
公有成员    OK       OK      OK      OK
保护成员    OK       OK      NO      OK
私有成员    OK       NO      NO      OK
5)区分隐藏和重载
A.只要子类中含有和基类中同名的标识符即构成名字隐藏，在不使用任何作用域限定前提下，直接访问到的都是子类中的名字，通过作用域限定才可以访问到基类中的名称。
B.基类和子类虽然存在派生和继承的逻辑关系，但它们毕竟是两个不同的类型，即各自拥有独立的作用域，因此即使是同名异参的成员函数也不能构成重载关系，除非通过using声明强制其同处于一个作用域中。
4.私有继承和保护继承
1)继承方式对访问控制属性的影响
当通过一个子类类型的对象访问它从基类继承的成员时，不同的继承方式会影响该成员在子类中访问控制属性。
公有继承，成员在基类中的访控属性和在子类中访控属性完全一致。
私有继承，基类中的所有成员在子类中都被视为私有成员。
保护继承，基类中的公有成员在子类中被视为保护成员。
class DCT { // $100
public:
    void codec (void) { ... }
};
class Jpeg : /*private*/protected DCT { // $1
public:
    void render (const char* jpgFile) {
        ...
        codec ();
        ...
     }
};
class Jpeg2000 : public Jpeg {
public:
    void render (const char* jpgFile) {
        ...
        codec ();
        ...
     }
};
Jpeg jpeg (...);
jpeg.render ("sea.jpg");
jpeg.codec (); // 报错
私有继承：防止基类中的公有成员通过子类被扩散出去。
保护继承：防止基类中的公有成员通过子类被扩散到继承链的外部，但是并不妨碍子类的子类继续访问。
私有继承和保护继承在逻辑上不存在皆然性，即没有IsA的关系。因此无论哪种继承都不能隐式地向上造型。
5.子类的构造、析构、拷贝构造和拷贝赋值
子类对象中包含了基类子对象，因此子类的构造、析构、拷贝构造和拷贝赋值，就必须同时兼顾其基类子对象的构造、析构、拷贝构造和拷贝赋值。
1)子类的构造函数
A.隐式构造基类部分：如果子类的构造函数没有显式指明基类部分的构造方式，那么编译器会选择基类的缺省构造函数，构造该子类对象中的基类子对象。这样做的前提就是基类中必须有缺省构造函数，否则将导致编译失败。
B.显示构造基类部分：子类的构造函数可以在初始化表中显式指明其基类部分的构造方式，即通过其基类的特定构造函数，构造该子类对象中的基类子对象。
C.子类对象的构造过程：子类的构造函数执行如下步骤
a)首先，按照继承表的顺序，依次调用各个基类的构造函数，构造子类对象中的基类子对象；
b)其次，按照声明的顺序，依次调用各个类类型成员变量相应类型的构造函数，构造子类对象中的成员子对象；
c)最后，执行子类构造函数体中的代码，完成整个构造过程。
2)子类的析构函数
A.子类的析构函数，无论是自己定义的，还是编译器提供的，在执行完其中的析构代码，并析构完所有的类类型成员子对象以后，会自动调用其基类的析构函数，析构该子类对象中的基类子对象。析构的顺序和构造的顺序一定是严格对称的。
B.对一个指向子类对象的基类指针使用delete操作符，实际被调用的将是基类的析构函数，该函数不会调用子类的析构函数，其所析构的仅仅是子类对象中的基类子对象，而子类的扩展部分极有可能因此而形成内存泄漏。实践中可以通过静态类型转换对基类指针做向下造型，解决此问题。
3)子类对象的拷贝
A.如果子类没有定义拷贝构造/赋值函数，那么编译器为子类提供缺省拷贝构造/赋值函数，该函数会自动调用其基类的拷贝构造/赋值函数，拷贝子类对象中的基类子对象。
B.如果子类定义了拷贝构造/赋值函数，但是没有显式指明基类子对象的拷贝方式，那么编译器要么以缺省方式初始化该子对象，要么令该子对象保持原状，均无法获得完整意义上的子对象副本。
C.如果子类定义了拷贝构造/赋值函数，同时也显式指明了基类子对象的拷贝方式，那么子对象中基类部分和扩展部分将被一起复制，最终得到完整意义上的子类对象副本。
6.多重继承
1)概念
如果一个子类同时从多个基类继承，就形成多重继承的结构。
技术员    经理     销售员
         \  /      \   /
   技术主管   销售主管
学生     教师
      \   /
   项目经理
电话   播放器   计算机
      \      |      /
        智能手机
2)语法：在类的继承表中依次写出子类的每个基类及其继承方式。
class 子类 : 继承方式1 基类1, 继承方式2 基类2, ... { ... };
子类从多个基类中继承它们的成员，任意一个基类的成员都可以被当做子类的成员，在子类的内部或外部被访问，前提是不违背访问控制属性和继承方式的约束。
3)对象模型
A.子类对象中的多个基类子对象，按照继承表的顺序依次被构造，并从低地址到高地址排列，析构的顺序则与构造的顺序相反。
B.将继承自多个基类的子类类型的指针，隐式或静态转换为它的基类类型，编译器会根据各个基类子对象在子类对象中的内存布局，进行适当的偏移计算，以保证指针的类型与其所指向目标对象的类型一致，反之亦然。
4)名字冲突与重载
A.如果多个基类存在相同的标识符，将在子类中产生名字冲突，可以通过作用域限定解决。
B.在不同基类中声明的同名异参成员函数，由于存在名字冲突，且作用域不同，因而无法在子类中形成重载，除非通过using声明将其强制引入子类的作用域，构成重载关系。

一、钻石继承
1.派生一个子类的多个基类源于共同的祖先，这样的继承结构被称为钻石继承(菱形继承)。
   A     - 公共基类(总基类)
  /  \
B    C  - 中间基类/中间子类(中间类)
  \  /
   D     - 汇聚子类(混合类)
           员      工
          /     |      \
技术员    经理     销售员
         \  /      \   /
   技术主管   销售主管
       人
      /   \
学生     教师
      \   /
   项目经理
        电子设备
       /     |     \
电话   播放器   计算机
      \      |      /
        智能手机
问题：当通过汇聚子类沿着不同继承路径访问公共基类中成员，会出现数据不一致的问题。其原因就是在不同的中间子类存在多个独立的公共基类子对象。
2.虚继承
在继承方式中增加virtual关键字，这样得到的子类就是其基类的虚子类，所有中间子类中的公共基类子对象将只有一个实例，且同时为这些虚子类所共享。即使沿着不同的继承路径访问公共基类子对象中的数据，也不可能不一致。
1)解决钻石继承结构中的数据不一致问题。
2)阻断继承——禁止一个类被继承。
二、虚函数和多态
                          图形：位置、绘制
                         /     \
矩形：长宽、绘制      圆形：半径、绘制
1.虚函数
形如
class 类名 {
    virtual 返回类型 函数名 (形参表) [const] { ... }
};
的成员函数，称为虚函数或方法。
2.覆盖
如果子类的成员函数和基类中的虚函数具有相同的函数原型，那么该成员函数就也是虚函数，无论其是否带有virtual关键字，且对基类中的虚函数构成覆盖关系。
3.多态
如果子类提供了对基类虚函数的有效覆盖，那么通过一个指向子类对象的基类指针，或者引用子类对象的基类引用，调用该虚函数，实际被调用的是子类中的覆盖版本，而非基类中的原始版本，这种语法现象称为多态。
4.多态的意义
多态的重要意义在于，一般情况下，调用哪个类的成员函数是有调用者指针或引用本身的类型决定的，而当多态发生时，调用哪个类的成员函数则完全由调用者指针或引用的实际目标对象的类型决定。这样一来，源自同一种类型的同一种激励，竟然可以产生多种不同的响应，谓之多态。
高聚低耦
三、覆盖的条件
1.必须是(非静态)成员函数。
2.必须是虚函数。
3.函数的签名(函数名+形参表+常属性)必须相同。
4.一般而言返回类型也应该相同，但是有一个例外：类型协变。
如果基类中的虚函数返回的是一个类的指针或引用，那么其子类中的覆盖版本允许返回基类版本所返回的指针或引用的目标类型的子类的指针或引用，这就叫返回类型协变。
注意：基类的原始版本和子类的覆盖版本，它们的访问控制属性以一定非得一样。
四、多态的条件
1.多态特性除了需要在基类中声明虚函数以外，还必须借助指针或者引用调用该虚函数，才能表现出来。
2.调用虚函数的指针也可能是成员函数中的this指针，只要它是一个指向子类对象的基类指针，同样可以多态。
3.当基类的构造函数被子类的构造函数调用时，子类对象尚不能说是子类类型的，它只表现出基类类型的外观和行为。这时调用虚函数，没有多态性。
4.当基类的析构函数被子类的析构函数调用时，子类对象已不再是子类类型的了，它只表现出基类类型的外观和行为。这时调用虚函数，没有多态性。
五、纯虚函数、抽象类、纯抽象类
1.纯虚函数
形如
class 类名 {
    virtual 返回类型 函数名 (形参表) [const] = 0;
};
的虚函数，称为纯虚函数或抽象方法。
2.抽象类
至少包含一个纯虚函数的类称为抽象类。抽象类不能被实例化为对象。如果抽象类的子类不对基类中所有的纯虚函数都提供有效覆盖，那么它就会继承未被覆盖的纯虚函数，进而也成为抽象类。
3.纯抽象类
如果一个类除了构造函数和静态成员函数以外，所有的成员函数都是纯虚函数，那么这样的类就是纯抽象类。纯抽象类亦称接口类，旨在定义功能性接口，但是不需要提供接口的具体实现，具体实现由子类给出。
六、虚函数调用的工作原理
1.虚函数表
包含虚函数的类
class B {
    virtual int f1 (void);
    virtual void f2 (int);
    virtual int f3 (int);
};
编译器会为每个包含虚函数的类生成一张虚函数表，即存放每个虚函数地址的函数指针数组，简称虚表(vtbl)，每个虚函数对应一个虚函数表中的下标
0 -> B::f1
1 -> B::f2
2 -> B::f3
除了为包含虚函数的类生成虚函数表以外，编译器还会为该类增加一个隐式成员变量，通常在该类实例化对象的起始位置，用于存放虚函数表的首地址，该变量被称为虚函数指针，简称虚指针(vptr)
代码
B* pb = new B;
pb->f3 (12);
被编译为
pb->vptr[2] (pb, 12); // B::f3
虚表是一个类一张，而不是一个对象一张，同一个类的多个对象，通过各自的虚指针，共享同一张虚表
继承自B的子类
class D : public B {
    int f1 (void);
    int f3 (int);
    virtual void f4 (void);
};
子类覆盖了基类的f1和f3，继承了基类的f2，增加了自己的f4，编译器同样会为子类生成一张专属于它的虚表
0 -> D::f1
1 -> B::f2
2 -> D::f3
3 -> D::f4
指向子类虚表的虚指针就存放在子类对象的基类子对象中，通常在起始位置
代码
B* pb = new D;
pb->f3 (12);
被编译为
pb->vptr[2] (pb, 12); // D::f3
这就是多态的工作原理。
2.动态绑定

六、...
2.动态绑定
当编译器“看到”通过指针或者引用调用基类中的虚函数时，并不急于生成有关函数调用的指令，相反它会用一段代码替代该调用语句，这段代码在运行时被执行，完成如下操作：
1)根据调用指针或引用的目标对象找到其内部的虚表指针；
2)根据虚表指针找到其所指向的虚函数表；
3)根据虚函数名和函数指针在虚函数表中的索引，找到所调用虚函数的入口地址；
4)在完成函数调用的准备工作以后，直接跳转到虚函数入口地址处顺序执行函数体指令序列，直到从函数中返回。
3.动态绑定对性能的影响
1)虚函数表和虚指针的存在势必要增加内存空间的开销。
2)和普通函数调用相比，虚函数调用要多出一个步骤，增加运行时间的开销。
3)动态绑定会妨碍编译器通过内联优化代码，虚函数不能内联。
鉴于以上三点，只有在确实需要多态特性的场合下才会使用虚函数，否则还是尽量使用普通函数。
七、运行时类型信息
1.typeid操作符
typeid操作符可以作用于任何类型的对象或变量，既可以是类类型的，也可以是基本类型的。该操作符会返回一个类型为typeinfo的对象的常引用，通过该对象可以获得有关类型的信息。
typeinfo::name()：返回类型名标签
typeinfo::operator ==/!=：类型比较
typeid操作符既可以在静态模式下工作，获取有关类型的静态信息，也可以在动态模式下工作，获取运行时类型信息。但是为了获取运行时类型信息，必须存在多态继承。
2.dynamic_cast动态类型转换
将多态基类的指针或引用造型为其子类类型的指针或引用，如果该指针或引用的目标对象确实为所要求的类型，则造型成功，否则造型失败，返回空指针(指针)或抛出异常(引用)。
八、虚析构
1.delete一个指向子类对象的基类指针，实际被调用的仅仅是基类的析构函数，该函数只负责析构子类对象中的基类子对象，而基类的析构函数不会调用子类的析构函数，因此在子类中分配的资源将形成内存泄漏。
2.如果将基类的析构函数声明虚函数，即虚析构，那么当delete一个指向子类对象的基类指针时，实际被调用的将是子类的析构函数。子类的析构函数将首先析构子类对象的扩展部分，然后在通过基类的析构函数析构该对象的基类部分，最终实现完美的资源释放。
3.没有分配任何资源的类，无需定义析构函数。没有定义析构函数的类，编译器会为其提供一个缺省析构函数，但缺省析构函数并不是虚函数。为了保证delete一个指向子类对象的基类指针时，能够正确调用子类的析构函数，就必须把基类的析构函数声明为虚函数，即使它是一个什么也不做的空函数，谓之空虚析构。
4.一般而言，只要一个类包含了虚函数，而且有可能从该类派生出子类，那么就应该将该类的析构函数声明为虚函数，至少不会有坏处。
哪些函数可以是虚函数？
全局函数(不虚)
静态成员函数(不虚)
非静态成员函数(可虚)
构造函数(不虚)
析构函数(可虚)
成员函数形式的操作符函数(可虚)
友元函数形式的操作符函数(不虚)
九、异常
1.异常的作用
解决在分析、设计、编码和测试阶段都无法预见故障和错误。
2.异常的处理
1)通过返回值表示异常
利：调用路径中各级函数的局部对象都能得到正确的析构
敝：调用路径中逐层判断返回值，流程复杂，源代码量大
2)通过setjmp/longjmp远程跳转处理异常
利：无需逐层判断返回值，流程简单，源代码量小
敝：调用路径中各级函数的局部对象得不到正确的析构
3)C++异常——两全其美的解决之道
既无需逐层判断返回值，流程简单，源代码量小，同时沿着函数调用的逆序做调用栈的辗转开解(即依次执行调用路径中每个函数的右花括号)，保证所有的局部对象都能得到正确的析构。
3.异常语法
1)抛出异常：throw 异常对象;
异常对象既可以是基本类型，也可以是类类型。
throw -1;
throw "文件打开失败！";
throw FileError (...); // 抛出匿名对象(建议)
FileError ex (...);
throw ex; // 抛出有名对象(不推荐)
2)捕获异常
try {
    可能抛出异常的语句;
}
catch (异常类型1& 异常对象) {
    针对异常类型1的异常处理;
}
catch (异常类型2& 异常对象) {
    针对异常类型2的异常处理;
}
...
catch (...) {
    处理其它异常;
}
4.异常流程
1)不发生异常时
两个执行：throw之后的代码执行，try块中引发异常语句之后的代码执行。
两个不执行：throw语句不执行，catch块不执行。
2)发生异常时
两个执行：throw语句执行，catch块执行。
两个不执行：throw之后的代码不执行，try块中引发异常语句之后的代码不执行。
检查异常条件->执行throw语句->沿着所调函数的右花括号一路回溯，析构局部对象->直到try的右花括号->匹配catch块的异常类型->执行catch块中的代码，处理所捕获的异常->执行try-catch结构以后的代码。


九、...
5.异常说明
1)异常说明是函数原型一部分，旨在说明函数可能抛出的异常范围。
函数原型：返回类型+函数名+形参表+常属性+异常说明
异常说明：throw (异常类型表)
void foo (int x, int y) throw (MemoryError,
    FileError, DivedByZero) {
    ...
    void* pv = malloc (1024);
    if (! pv)
        throw MemoryError (...);
    ...
    FILE* fp = fopen ("none", "r");
    if (! fp)
        throw FileError (...);
    ...
    if (y == 0)
        throw DivedByZero (...);
    ...
}
异常说明是一种承诺，承诺函数不会抛出异常说明以外的异常类型。如果函数违背承诺，抛出了异常说明以外的异常，那么所抛出的异常无法被该函数的调用者捕获，最终这些异常会被C++标准库捕获，直到杀灭进程，同时将与该异常有关的类型信息打印在标准输出(1)或标准出错(2)上。
2)异常说明的两个特殊形式
A.throw() - 该函数不抛出任何异常
B.没有异常说明 - 该函数可以抛出任何异常
3)如果基类中的虚函数带有异常说明，那么该函数在子类中的覆盖版本不能说明比基类版本抛出更多的异常。
6.异常的特殊用法
1)不处理异常：如果一个函数对于可能引发的异常不与捕获，那么该异常会向这个函数的调用者继续抛出，直到被捕获。如果直到main函数都没有捕获此异常，那么标准库会捕获它，同时杀灭进程。
2)捕获并继续抛出异常：在catch块中继续抛出所捕获的异常。
throw;
3)在构造函数中抛出异常：在对象的初始化或者资源分配过程中遇到的各种错误，但是要注意，如果构造函数抛出异常，那么该对象的析构函数就不会被执行，有关动态资源释放的操作必须在构造函数抛出异常之前手动完成。基类子对象、成员子对象以及通过auto_ptr<T>管理的动态对象，无需考虑内存泄漏问题，因为构造函数的自动回滚机制，可以保证这些对象的析构函数在异常抛出的同时被正确执行。
4)忠告：最好不要从析构函数中抛出异常。因为析构函数本身就是异常处理的一部分，如果在析构函数抛出异常，就会打断函数栈帧辗转开解的过程，进而引发更多的异常，最终导致进程崩溃。为了防止被析构函数调用的其它函数抛出的异常从析构函数中被继续抛出，还应该在析构函数返回以前，尽可能捕获所有可能捕获到异常。
十、I/O流
1.I/O流类库
1)文件I/O
#include <fstream>
ifstream - 读文件
ofstream - 写文件
fstream - 读写文件
2)内存I/O
#include <sstream>
istrstream - 读内存
ostrstream - 写内存
strstream - 读写内存
2.I/O流的打开和关闭
1)直接利用I/O流类的构造函数打开I/O流
I/O流类名 I/O流类对象 (路径, 模式);
fstream fs ("/some.txt", ios::in | ios::out);
2)调用I/O类所提供open成员函数打开I/O流
I/O流类对象.open (路径, 模式);
fstream fs;
fs.open ("/some.txt", ios::in | ios::out);
3)调用I/O类所提供close成员函数关闭I/O流
I/O流类对象.close ();
fs.close ();
4)直接利用I/O类的析构函数关闭I/O流
{
    fstream fs ("/some.txt", ios::in | ios::out);
    // ...
}  -> fstream::~fstream() -> 关闭fs所对应的I/O流
其中模式：
ios::in // C: fopen (..., "r")
打开文件用于读取，不存在则失败，已存在不清空
适用于ifstream(缺省)/fstream
ios::out // C: fopen (..., "w")
打开文件用于写入，不存在则创建，已存在则清空
适用于ofstream(缺省)/fstream
ios::app // C: fopen (..., "a");
打开文件用于追加，不存在则创建，已存在不清空
适用于ofstream(缺省)/fstream
ios::trunc
打开时清空原内容
适用于ofstream/fstream
ios::ate
打开是定位到文件尾
适用于ifstream/ofstream/fstream
ios::binary // C: fopen (..., "b")
以二进制方式读写
适用于ifstream/ofstream/fstream
打开模式可以组合使用：ios::in | ios::out - 既读又写
无意义组合结果未定义：ios::in | ios::trunc - 清空了怎么读？
合理的组合结果有定义：ios::in | ios::trunc | ios::out - 清空原内容，写入新内容，读取新写入的内容
3.I/O流的状态
每个I/O流对象内部都有一个表示状态的成员变量，通常就是一个unsigned int，其中每个二进制位表示一种状态，常用状态：
good，好，状态位全零，表示流对象正常可用
流对象->bool = true
bad，坏，文件系统发生致命错误       \
eof，文件尾，文件位置到达文件末尾   > 流对象->bool = false
fail，失败，最后一次I/O出错             /
ios::clear() - 复位流状态，是流对象继续工作
4.I/O流的格式化
1)流函数：在ios总基类里定义的一组与输入输出格式控制有关的成员函数，调用这些函数会对以后的输入输出格式造成不同影响。
A.浮点数的精度
int ios::precision (int); // 设置，设置新值返回旧值
int ios::precision (void) const; // 获取，返回当前值
对于浮点小数而言，精度是指有效数字的位数。
123.4567000 - 精度10
对于科学计数法表示的定点小数，精度是指小数部分的位数。
1.234567000E2 - 精度9
B.域宽
int ios::width (int);
int ios::width (void) const;
C.填充字符
char ios::fill (char);
char ios::fill (void) const;
D.格式标志
long ios::setf (long); // 添加标志位，返回原标志
// 先清除互斥域(第二个参数)，再添加标志位，返回原标志
long ios::setf (long, long);
long ios::unsetf (long); // 清除标志位，返回原标志
标志位                互斥域                 说明
---------------------------------------------
ios::left                                        左对齐
ios::right           ios::adjustfield   右对齐
ios::internal                                 两端对齐，左号右数
---------------------------------------------
ios::dec                                        十进制
ios::oct              ios::basefield      八进制
ios::hex                                        十六进制
---------------------------------------------
ios::fixed           ios::floatfield      普通定点小数
ios::scientific                                科学计数法
---------------------------------------------
ios::showpos                                显示正号
ios::showbase                              显示进制前缀0/0x
ios::showpoint                             显示小数点和尾数0
ios::uppercase                              数字中的字母大写
ios::boolalpha                               用字符串显示布尔值
ios::unitbuf                                   每次插入刷流缓冲
ios::skipws                                    以空白字符作为分隔符
2)流控制符：直接插入到流对象中，控制输入输出格式，其作用与流函数相当。如果使用流控制带有参数，需要包含头文件：
#include <iomanip>
left/right/internal
dec/oct/hex
fixed/scientific
showpos/noshowpos
showbase/noshowbase
showpoint/noshowpoint
uppercase/nouppercase
boolalpha/noboolalpha
unitbuf/nounitbuf
skipws/noskipws
ends(空字符)/endl(换行)/flush(刷流)
setprecision (int) // 设置精度
setw (int) // 设置域宽
setfill (char) // 设置填充字符
5.二进制I/O
istream& istream::read (char* buf, size_t num);
从输入流中读取num个字节到buf缓冲区中。返回时输入流对象本身。可以通过istream::gcount()函数最后一次读取到的字节数。如果实际读取的字节数和num参数相等，输入流状态就是good，否则就是bad/eof。
ostream& ostream::write (char const* buf, size_t num);
从buf缓冲区中向输出流写入num个字节。写入成功输出流状态为good，否则为bad/fail。
6.随机I/O
// 设置读位置
istream& istream::seekg (int offset, int origin);
// 设置写位置
ostream& ostream::seekp (int offset, int origin);
origin:
ios::beg - 从文件头(SEEK_SET)
ios::cur - 从当前位置(SEEK_CUR)
ios::end - 从文件尾(SEEK_END)
int istream::tellg (void); // 获取读位置
int ostream::tellp (void); // 获取写位置
7.字符串流
istringstream/ostringstream


四、stl的知识

静态类型系统：标识符的类型在运行期不可改变。
动态类型系统：标识符的类型在运行期可动态变化。
int i;
C/C++是静态类型语言，类型信息都是编译期间确定的，运行时不可改变与类型相关的一切属性。
优点：性能卓越。底层操作。
缺点：缺乏灵活性，不适于编写与类型无关的通用算法和数据结构。
一、模板起源
1.针对具体类型的实现
C/C++语言的静态类型系统，在满足效率和安全性要求的同时，很大程度上也成为阻碍程序员编写通用代码的桎梏。它迫使人们不得不为每一种数据类型编写完全或几乎完全相同的代码，虽然它们在抽象层面上是一致的。
2.借助参数宏摆脱类型的限制——Live free or die !
宏定义指示在预处理器的作用下，针对源代码的文本替换，其本身并不具备函数语义。因此借助于参数宏可以在某种程度上是程序的编写者摆脱那些源于类型的约束和限制，但同时也因此丧失了类型的安全性。
3.两全其美的解决之道
利用宏定义构建通用代码框架，让预处理器将其扩展为针对不同类型的具体版本。将宏的一般性和函数的类型安全性"完美"地结合起来。美中不足的是，必须显式调用所定义的宏，否则预处理器不会扩展出针对具体类型的函数定义，而且宏无法单步调试。
二、函数模板
1.定义
template<typename 类型形参1, typename 类型形参2, ...>
返回类型 函数名 (调用形参表) [常属性] [异常说明] { 函数体; }
类型形参可以用于函数的返回类型、形参表以及函数体，表示一种参数化的类型。
2.使用
函数名<类型实参1, 类型实参2, ...> (调用实参表);
类型实参即用于传递个模板类型形参的各种具体类型，如：int/float/double/string/Student/Teacher ...
3.实例化
编译器根据调用函数模板时所提供的类型实参，按照从前到后的顺序，依次结合函数模板的类型形参，得到一个针对类型实参的具体函数，并编译之，这个过程叫做函数模板的实例化。函数模板并不代表一个具体函数，也不存在与目标模块，当然也不参加链接，它实际上表示的是一组具有重载关系的函数族。
4.类型参数
无论基本类型，还是类类型都可以作为函数模板的类型实参，唯一的条件就是该类型必须要满足函数模板的要求，否则将导致编译失败。
5.二次编译
与普通函数不同，函数模板事实上至少要被编译两次，第一次是在实例化之前，先检查模板代码本身，做与类型参数无关的语法处理，生成该函数模板的内部表示。第二次是在实例化期间，用所提供的类型实参结合内部表示中的类型形参，在完成与类型相关的语法处理以后，生成二进制形式的机制指令。有时候，编译器会将本来应该在第二次编译时处理的问题，提前到第一次编译时处理，由于此时的类型参数尚不明确，可能引发编译失败，需要使用特殊的处理手段予以避免。
6.隐式推断
如果函数模板的调用参数的类型相关于该模板的类型参数，那么在调用该函数模板时，即使不显式指定传给模板的类型实参，编译器也有能力根据调用参数的类型隐式推断出正确的模板参数，以获得与普通函数调用一致的语法形式。但是，有时候隐式推断出的类型可能和程序设计者所期望的类型不一致，导致结果异于预期，需要引起注意。
7.函数模板的重载
函数模板和函数模板，以及函数模板和普通函数之间也可以构成重载关系，与普通函数之间的重载不同，函数模板的重载在解析规则中增加了类型针对性越强越优先匹配的条件。
三、类模板
1.定义
如果一个类中的成员变量、成员函数、成员类型，乃至基类中使用了参数化的类型，那么这个类就是一个类模板。
template<typename 类型形参1, typename 类型形参2, ...>
class 类模板名 { ... };
template<typename M, typename R, typename A,
    typename V, typename T, typename B>
class MyClass : public B {
    M m_mem;
    R function (A arg) { ... V var; ... }
    typedef T* PT;
};
2.使用
类模板名<类型实参1, 类型实参2, ...> 对象 (构造实参表);
类模板名<类型实参1, 类型实参2, ...>& 引用 = 对象;
类模板名<类型实参1, 类型实参2, ...>* 指针 = &对象;
|<--------------- 类 --------------->|
MyClass<char, short, int, float, double, string> mc;
MyClass<char, short, int, float, double, string>& r = mc;
MyClass<char, short, int, float, double, string>* p =&mc;
MyClass mc; // 错误！
MyClass& r = mc; // 错误！
MyClass* p = &mc; // 错误！
类模板本身不是一个类型，当然也不是一个合法作用域，因此既不能用于对象、引用和指针的声明，也不能放在作用域限定操作符(::)前面，只有带上足够的类型实参，这才是一个完整的类，可以用在一切类可以出现的上下文中。

三、...
3.两步实例化
           编译期        运行期
类模板-实例化->类-实例化->对象
           编译器         处理器
               V
        成员函数的
        第一次编译
               V
        看到对成员
        函数的调用
        第二次编译
4.类型参数
1)与函数模板不同，类模板并不要求实例化该模板的类型实参满足模板对类型的所有要求，实例化该模板的类型实参只需要满足用到的成员函数对它的要求即可。
2)作为类模板的设计者，对实例化该模板的类型要求的越少越好。而作为类模板的使用者，对于用不着的功能可以不与支持。
5.类模板的静态成员变量
类模板的静态成员变量，既不是一个模板一份实例，也不是一个对象一份实例，而是在该模板的每个实例化类中各有一份实例，且为该类的每个对象所共享。
class A { int x; };
      A
   /  |  \
a1 a2 a3
x   x   x
class A { static int x; };
      A
      x
   /  |  \
a1 a2 a3
template<typename ...> class M { static int x; };
                    M
          ________^_________
         /           |             \
       A            B             C
       x             x             x
    /  |  \      /  |  \       /  |  \
 a1 a2 a3 b1 b2 b3 c1 c2 c3
6.递归实例化
用一个类模板的实例化类型，实例化该类模板自身。主要用于表示在空间上具有递归特性的数据结构，如：多维数组、二叉树等等。
7.完全特(例)化
一个类模板在满足大多数类型要求的同时，可能对一些特殊类型无法给出正确的结果，或者虽然能给出正确的结果，但性能不佳。这时候可以提供一个针对特殊类型的特殊实现，以弥补通用版本在功能和性能方面的不足。
1)全类特化
template<>
class 类模板名<特化所针对的类型> { 定义一个具体类 };
当用户用特化所针对的类型实例化该类模板时，编译器将选择特化的版本而非通用版本。在特化版本中，程序设计者可以完全依赖所针对的特殊类型进行功能设计和性能优化。
2)成员特化
如果与特殊类型相关的仅仅极个别的成员函数，那么也可以只针对这些成员函数做专门的特化。
template<>
返回类型 类模板名<特化所针对的类型>::成员函数名 (
    形参表) [常属性] [异常说明] { 定义一个具体函数 }
成员特化只是给出一个成员函数针对特殊类型的新的定义，其声明依然在通用版本中，因此特化版本的原型和通用版本的原型，除了一个是具体类型，一个是参数类型以外，必须完全一致。
3)从类模板的设计角度讲，不要将特化作为模板缺乏一般性的借口。所谓类模板特化应该被视为一致无奈之举，或者是一种权宜之计，而不应作为设计原则。
8.局部特(例)化
template<typename A, typename B>
class X { ... }; // 通用版本
template<>
class X<int, short> { ... }; // 完全特化
template<typename A>
class X<A, short> { ... }; // 局部特化
类模板可以被局部地特例化，即一方面为类模板指定特定的实现，另一方面又允许用户对部分类型参数自行指定。
9.案例：std::auto_ptr<T>的简化实现
int i = 100;
int* p = &i;
int* q = p;
四、模板参数的缺省值
template<typename A = int, typename B = double> ...
模板的参数可以带有缺省值，实例化该模板时，如果提供了实参，就用所提供的实参，如果没提供实参，就取相应的缺省值。如果某个模板参数带有了缺省值，那么它后面的所有参数必须都带有缺省值。
void foo (int x, int y = 10) { ... } // OK
void foo (int x, int y = x) { ... } // ERROR
函数的参数，后面参数不能用前面的参数作为其缺省值。
模板的参数，后面参数可以用前面的参数作为其缺省值。
template<typename A, typename B = A> ...
C++98中，函数模板不能带有缺省参数，但是C++2011可以，如果使用GNU的C++编译器需要加上编译选项：
-std=c++0x // 4.8以下版本
-std=c++11 // 4.8和4.8以上版本
当函数模板隐式推断的参数类型与模板参数的缺省值不一致时，以隐式推断的类型为准，忽略其缺省值。
五、模板的非类型参数
void foo (int x) { ... }
foo (10);
int i = 10;
foo (i);
模板的参数并不局限于类型参数，普通的数值也可以作为模板的参数，但这些参数前面不要写typename，而要注明其具体类型。传递给模板非类型参数的实参，可以是常量、常量表达式、带有常属性(const)的变量，但是不能同时具有挥发性(volatile)。此外，关于模板的非类型参数还有以下额外限制：
1.不能是浮点类型：float/double/long double；
2.不能是非标量类型：Student/Teacher/Cat/Dog；
3.可以是字符串但是只能用字符指针作为形参，且只能用非静态的全局字符数组作为实参，否则无法通过编译。
六、typename关键字
1.声明模板的类型参数
template<typename T, ...> ...
等价于class关键字
template<class T, ...> ...
2.解决嵌套依赖
所谓嵌套依赖，就是依赖于模板类型参数的类型的嵌套类型。在做这种用法的场合，不能换成class关键字。
七、template关键字
1.声明模板
template<...> ...
2.解决嵌套模板
所谓嵌套模板，就是依赖于模板类型参数的类型的内部模板。而且有时还需和typename关键字配合使用。

三、...
3.两步实例化
           编译期        运行期
类模板-实例化->类-实例化->对象
           编译器         处理器
               V
        成员函数的
        第一次编译
               V
        看到对成员
        函数的调用
        第二次编译
4.类型参数
1)与函数模板不同，类模板并不要求实例化该模板的类型实参满足模板对类型的所有要求，实例化该模板的类型实参只需要满足用到的成员函数对它的要求即可。
2)作为类模板的设计者，对实例化该模板的类型要求的越少越好。而作为类模板的使用者，对于用不着的功能可以不与支持。
5.类模板的静态成员变量
类模板的静态成员变量，既不是一个模板一份实例，也不是一个对象一份实例，而是在该模板的每个实例化类中各有一份实例，且为该类的每个对象所共享。
class A { int x; };
      A
   /  |  \
a1 a2 a3
x   x   x
class A { static int x; };
      A
      x
   /  |  \
a1 a2 a3
template<typename ...> class M { static int x; };
                    M
          ________^_________
         /           |             \
       A            B             C
       x             x             x
    /  |  \      /  |  \       /  |  \
 a1 a2 a3 b1 b2 b3 c1 c2 c3
6.递归实例化
用一个类模板的实例化类型，实例化该类模板自身。主要用于表示在空间上具有递归特性的数据结构，如：多维数组、二叉树等等。
7.完全特(例)化
一个类模板在满足大多数类型要求的同时，可能对一些特殊类型无法给出正确的结果，或者虽然能给出正确的结果，但性能不佳。这时候可以提供一个针对特殊类型的特殊实现，以弥补通用版本在功能和性能方面的不足。
1)全类特化
template<>
class 类模板名<特化所针对的类型> { 定义一个具体类 };
当用户用特化所针对的类型实例化该类模板时，编译器将选择特化的版本而非通用版本。在特化版本中，程序设计者可以完全依赖所针对的特殊类型进行功能设计和性能优化。
2)成员特化
如果与特殊类型相关的仅仅极个别的成员函数，那么也可以只针对这些成员函数做专门的特化。
template<>
返回类型 类模板名<特化所针对的类型>::成员函数名 (
    形参表) [常属性] [异常说明] { 定义一个具体函数 }
成员特化只是给出一个成员函数针对特殊类型的新的定义，其声明依然在通用版本中，因此特化版本的原型和通用版本的原型，除了一个是具体类型，一个是参数类型以外，必须完全一致。
3)从类模板的设计角度讲，不要将特化作为模板缺乏一般性的借口。所谓类模板特化应该被视为一致无奈之举，或者是一种权宜之计，而不应作为设计原则。
8.局部特(例)化
template<typename A, typename B>
class X { ... }; // 通用版本
template<>
class X<int, short> { ... }; // 完全特化
template<typename A>
class X<A, short> { ... }; // 局部特化
类模板可以被局部地特例化，即一方面为类模板指定特定的实现，另一方面又允许用户对部分类型参数自行指定。
9.案例：std::auto_ptr<T>的简化实现
int i = 100;
int* p = &i;
int* q = p;
四、模板参数的缺省值
template<typename A = int, typename B = double> ...
模板的参数可以带有缺省值，实例化该模板时，如果提供了实参，就用所提供的实参，如果没提供实参，就取相应的缺省值。如果某个模板参数带有了缺省值，那么它后面的所有参数必须都带有缺省值。
void foo (int x, int y = 10) { ... } // OK
void foo (int x, int y = x) { ... } // ERROR
函数的参数，后面参数不能用前面的参数作为其缺省值。
模板的参数，后面参数可以用前面的参数作为其缺省值。
template<typename A, typename B = A> ...
C++98中，函数模板不能带有缺省参数，但是C++2011可以，如果使用GNU的C++编译器需要加上编译选项：
-std=c++0x // 4.8以下版本
-std=c++11 // 4.8和4.8以上版本
当函数模板隐式推断的参数类型与模板参数的缺省值不一致时，以隐式推断的类型为准，忽略其缺省值。
五、模板的非类型参数
void foo (int x) { ... }
foo (10);
int i = 10;
foo (i);
模板的参数并不局限于类型参数，普通的数值也可以作为模板的参数，但这些参数前面不要写typename，而要注明其具体类型。传递给模板非类型参数的实参，可以是常量、常量表达式、带有常属性(const)的变量，但是不能同时具有挥发性(volatile)。此外，关于模板的非类型参数还有以下额外限制：
1.不能是浮点类型：float/double/long double；
2.不能是非标量类型：Student/Teacher/Cat/Dog；
3.可以是字符串但是只能用字符指针作为形参，且只能用非静态的全局字符数组作为实参，否则无法通过编译。
六、typename关键字
1.声明模板的类型参数
template<typename T, ...> ...
等价于class关键字
template<class T, ...> ...
2.解决嵌套依赖
所谓嵌套依赖，就是依赖于模板类型参数的类型的嵌套类型。在做这种用法的场合，不能换成class关键字。
七、template关键字
1.声明模板
template<...> ...
2.解决嵌套模板
所谓嵌套模板，就是依赖于模板类型参数的类型的内部模板。而且有时还需和typename关键字配合使用。

八、子类模板访问基类模板
在子类模板中直接访问那些依赖于模板参数的基类模板的成员，编译器在第一次编译时，通常会因为基类类型不明确而只在子类和全局作用域中搜索所引用的符号。通过显式注明基类的作用域限定，或者显式使用this指针，可以迫使编译器在第二次编译时根据基类的声明检查所引用的符号，避免编译失败。
九、模板中的模板
十、模板型的模板成员和模板参数
十一、零初始化
十二、类模板与虚函数
1.类模板中可以包含虚函数，但是一定要注意，实例化该模板所用的类型实参一定不能违背有效覆盖的条件，否则将导致编译错误，或者丧失多态特性。
2.如果一个类或者类模板的成员函数带有自己的类型参数，那么该函数就是一个类或类模板的模板型成员函数，这样的成员函数不能同时又是虚函数。其原因就在于，模板函数的二次编译会阻碍虚函数表的静态构建。
十三、编译模型
1.单一模型：将模板的声明与实现放在同一个编译单元中。
template<typename T>
class A {
    void foo (T arg) { ... }
};
2.分离模型：将模板的声明与实现分别放在.h和.cpp文件中。
xxx.h
// 声明
template<typename T>
class A {
    void foo (T arg);
};
xxx.cpp
// 实现
template<typename T>
void A<T>::foo (T arg) { ... }
是否可行？不可行！
3.包含模型
在模板的声明文件末尾包含该模板的实现文件，强制模板的声明、实现和实例化都同处于一个编译单元，保证对模板的二次编译能够正确执行，满足链接器的要求。但是，包含模型延长编译时间，而且模板的实现代码必须公开。
4.实例模型
在模板实现文件中使用实例化指示符，强制编译器在编译该文件时，即根据特定的模板实参对模板进行实例化，满足链接器的要求。编译速度快，而且模板的实现代码不必公开，但是，实例模型的实例化类型总是有限的，对于用户自定义的各种类型无法提供完全的支持。
5.导出模型
大多数编译器不支持！
GNU/Microsoft/IBM/HP/Oracle
Edison Design, Inc.
C++2011彻底删除了该特性，export关键被移作它用。
十四、预编译头文件
common.h
#include <unistd.h>
#include <stdio.h>
#include <iostream>
...
g++ -c common.h -> common.h.gch (预编译头文件)
a.cpp
#include "common.h"
...
微软：
stdafx.cpp -> <项目名>.pch
#include "stdafx.h"
十五、多态
1.动态多态：基于虚函数和动态绑定的多态。
2.静态多态：基于参数类型和模板的多态。
十六、容器、迭代器和泛型算法
1.容器：双向线性链表
2.迭代器：正向顺序迭代器
3.泛型算法：线性查找算法

标准模板库(Standard Templates Library, STL)
容器：以类模板的形式实现不同的数据结构：数组、链表、堆栈、队列、二叉树，等等。
线性容器：向量(vector)、双端队列(deque)、列表(list)
适配器容器：堆栈(stack)、队列(queue)、优先队列(priority_queue)
关联容器：映射(map)、多重映射(multimap)，集合(set)、多重集合(multiset)
每个容器都提供四个迭代器：
正向迭代器：iterator
常正向迭代器：const_iterator
反向迭代器：reverse_iterator
常反向迭代器：const_reverse_iterator
只有向量和双端队列这种连续的内存的容器才会提供随机迭代器，其它容器都只提供顺序迭代器。
基于迭代器，在与具体数据结构无关的前提下，以一种一般化的方式访问不同类型的容器，得到了一组泛型算法函数。一种容器是否可适用于特定的泛型算法，唯一的条件就是该容器满足算法对迭代器的要求。
一、向量
#include <vector>
1.连续内存、下标访问、动态内存管理、静态内存预留。
2.随机迭代器：可以和整数做加减运算、同型迭代器之间可以比较大小也可以相减，但是不能相加。
3.成员函数
front()/back()
push_back()/pop_back()
insert()/erase()
clear()/size()/capacity()/empty()
begin()/begin() const - 可写/只读起始正向迭代器
end()/end() const - 可写/只读终止正向迭代器
rbegin()/rbegin() const - 可写/只读起始反向迭代器
rend()/rend() const - 可写/只读终止反向迭代器
4.类类型向量元素
如果向量中的元素类型是自定义类，往往该类需要支持如下特性：缺省构造函数、深拷贝的拷贝构造函数和拷贝赋值运算符函数，如果需要搜索功能，还需要支持"=="运算符，如果需要做排序，还需要支持"<"运算符，或者提供小于比较器。
二、双端队列(deque)
#include <deque>
1.双端队列无论是实现还是功能几乎和向量完全一样。在存储结构上，双端队列也是连续内存，也支持下标访问和随机迭代，但是和向量不同，动态存储区的首端是开发，可以通过push_front()/pop_front()成员函数，在容器的首端做元素的压入和弹出。
2.双端队列无论是内存空间还是操作时间都会略逊于向量。
三、列表(list)
#include <list>
1.唯一化
void unique (void);
连续重复出现元素做唯一化。
10 10 20 20 10 20 30 20 20 10 10
| unique()
v
10      20      10 20 30 20      10
2.排序
void sort (void);
通过元素类型的“<”比大小。
void sort (less cmp);
通过小于比较器cmp比大小。

三、...
3.拆分
将参数列表的部分或全部剪切到调用列表的指定位置。
void splice (IT pos, list& lst);
将参数列表lst中全部元素剪切到调用列表pos迭代器之前。
void splice (IT pos, list& lst, IT del);
将参数列表lst中del迭代器所指向的元素剪切到调用列表pos迭代器之前。
void splice (IT pos, list& lst, IT begin, IT end);
将参数列表lst中位于begin和end两个迭代器之间的元素剪切到调用列表pos迭代器之前。
注：在STL中凡是用两个迭代器表示一个范围，其终止迭代器一定是范围中最后一个元素的下一个位置。
4.合并
将有序的参数列表的全部元素合并到有序调用列表中，合并后的调用列表依然有序，参数列表为空。
void merge (list& lst);
void merge (list& lst, LESS less);
四、堆栈
#include <stack>
statck<元素类型, 底层容器>
底层容器：vector/deque(缺省)/list
push -> push_back
pop -> pop_back
top -> back
size -> size
clear -> clear
empty -> empty
五、队列
#include <queue>
queue<元素类型, 底层容器>
底层容器：deque(缺省)/list
push -> push_back
pop -> pop_front - 向量(vector)不能适配队列
front -> front
back -> back
size -> size
clear -> clear
empty -> empty
六、优先队列
#include <queue>
priority_queue<元素类型, 底层容器, 小于比较器>
默认通过元素类型的“<”比大小，以大者优先，通过小于比较器可以自定优先级。
底层容器：vector/deque(缺省)
每次压入元素，优先队列调整元素位置，保证优先级越高的元素越靠近队首，以保证优者先出的规则。
小于比较器是优先队列类模板的类型参数，优先队列内部负责将该类实例化为对象，因此只能使用定义“()”操作符的类，而不能使用函数指针。
注意：任何容器的迭代器都存在有效期，任何一种对容器内存布局构成影响的操作，都因该重置该迭代器。
七、映射
#include <map>
map<键类型, 值类型>
现实世界中普遍存在某正一一对应的关系，如
居民身份证号码 -> 个人信息
学号 -> 成绩
查询线索称为键，被查询的信息称为值。在映射中，可以根据键在对数时间(O(logN))内找到和它相对应的值。
映射在逻辑层用一个平衡有序二叉树保存每个节点中的键和值。
平衡有序二叉树：每个节点左右子树中的元素个数最多相差一个的有序二叉树。
5 4 3 2 1
            5
           /
         4
        /
      3
     /
   2
  /
1
单连枝树，退化成链表，O(logN)->O(N)
           3
         /   \
       2      4
      /          \
    1             5
平衡有序树，保证搜索过程中的最优时间复杂度=最差时间复杂度=平均时间复杂等=O(logN)。
映射基本元素是pair，每个pair包含键和值两份数据。
template<typename FIRST, typename SECOND>
class pair {
public:
    pair (FIRST const& f, SECOND const& s) :
        first (f), second (s) {}
    FIRST first;
    SECOND second;
};
映射节点中存放pair对象，其中first表示键，second表示值，依据键构成有序树。
投票选举系统
五个候选人
十个人投票
A-E五个字符分别对应每个候选人
map<char, Candicate>
可以通过比较器类型自定义键的排序规则。
八、多重映射
允许键重复的映射。表示一对多的关系。不支持下标访问。
IT lower_bound (KEY const& key);  // 返回匹配下限
IT upper_bound (KEY const& key); // 返回匹配上限
键   值
A - 100
A - 200
B - 300 <- lower_bound ('B')
B - 400
B - 500
C - 600 <- upper_bound ('B')
C - 700
pair<IT, IT> equal_range (KEY const& key);
// 返回匹配范围，其中first是匹配下限，second是匹配上限
九、集合
#include <set>
set<键类型>
没有值的映射。
十、多重集合
#include <set>
multiset<键类型>
没有值的多重映射。
十一、其它工具
遍历：for_each


五、ARM的基础知识

开发板：

核心板（小）：
CPU：S5pv210（三星），核心：ARM公司的ARM Cortex-A8核
     单核，1Ghz
存储器：
    非持久性记忆体
    易失性存储器 RAM（内存）：小的并排的4个长方形（8个）
    （掉电就丢失）            另外4个在另外一面
                              DDR，1G bytes

    持久性记忆体
    非易失性存储器（掉电不丢失）：
                闪存，三星，Nand Flash
                1G bytes

核心板上晶振是哪个？
    金黄色的（长方形的）或者银白的。

底板（大）：
  电源输入，电源拨码开关（ON，开），
  485接口，摄像头接口
  存储卡座（小的，一个大SD）
  小卡，打卡中间有个白色的按键（电源）
    注意：如果你的板子电源接通后，CPU没有运行
          按这个白键（长按，3秒）
          按住不放：cpu接通电源，如果继续按，切断电源。
  拨码开关（4个）
    ON，DIP
    拨码报道ON端是ON，反之就是OFF
    这个拨码开关的作用是什么吗？
      控制CPU的启动方式的。
      举例：PC（笔记本）启动时可以选择
            从硬盘读取操作系统、U盘、光盘、网络
            电脑怎么知道到哪里去读取操作系统？
              BIOS设置
    S5PV210这个微处理器也可以从不同的设备
    上读取系统（启动程序）,如闪存，SD卡，通过USB从
    电脑上读取，还可以同通过串口读取。
    S5pv210怎么知道从哪个设备读取启动程序呢？
       通过cpu的某几个管脚（引脚）的高低电平组合
       来确定从哪个设备读取启动程序。
       体现在开发板上：
         拨码开关
    问题：如何知道拨码在什么状态，对应的从哪个
          设备启动（读取启动程序）？
          现在只有知道看哪个文档就可以了。
          1、看开发板的电路图（原理图）
             知道拨码开关连接到CPU的哪个管脚
             拨码拨到ON接的是高还是低
          2、从CPU手册看，某个几个接高或者低的组合
             和某个设备启动的对应关系。
    蜂鸣器，蜂鸣器旁边有个跳线。
            如果要让蜂鸣器响，必须短接跳线。

    按键：通用功能按键8个
    复位按键
    复位键旁边有个黑色的，红外头
    红外头旁边有个黄色中间能旋转的，电位器。
    电位器旁边有个黑色的小的器件：温度传感器。
    usb（主）
    音频座
    网卡座
    usb（从） OTG
    串口（2个）

    串口我们实验使用的上靠近usb口这个。
    屏
    问题：我们的屏是几个屏？
          一个
          两个
          模组：包括显示屏（LCD），触摸屏（电容）


   拨码开关：
   1 -->ON
   2 -->OFF
   3 -->OFF
   4 -->OFF
    从开发板的闪存启动
   1-->OFF
   2-->ON
   3-->ON
   4-->OFF
    从大的SD卡启动

   1->ON
   2->OFF
   3->OFF
   4->ON
     先通过USB获取启动代码，

   问题：程序在内存还是硬盘中运行？
         内存
   对于我们的开发板程序在哪里运行？
         内存
         不是闪存

完成任务：向开发板安装软件（假定开发板上什么都没有）
          向开发板的闪存（Nand Flash）中安装。
          （下载或者烧写）
          被安装的软件是u-boot.bin
          （嵌入式linux的一个引导程序）
          安装完之后，开发板设置成从闪存启动，上电
          u-boot.bin应该能在开发板上运行起来。
          （u-boot.bin 我们预先做好的可以在开发板山上
            运行的程序）

   我的电脑上有几个软件可以拷贝一下。
   开发板连线：
      1、串口线
      2、网线
      3、usb线
      4、电源

   S5PV210三星出厂内部集成了一块ROM，里面放置了三星
   已经开发好的一个软件。
   三星把这块ROM称为IROM，里面放的软件IROM程序。
   S5PV210微处理器内部集成了一块SRAM（RAM），三星称为
   IRAM。
   IROM和IRAM我们用眼睛是看不见的。

   S5PV210微处理器上电，先执行IROM中程序。
   IROM中从的程序就对微处理器做最基本的配置
   然后运行，运行后，IROM程序会检测决定启动
   方式的几个管脚的状态，根据管脚的状态决定
   从哪个存储设备上读取启动程序。
   S5PV210 支持从
      闪存上读取启动代码（从闪存启动）
      从SD卡启动
      支持从USB启动
      支持从UART启动

   我们先用从USB启动方式启动，然后安装u-boot.bin
   到开发板闪存。
   1、拨码开关设置为USB启动方式
      1->ON
      2->OFF
      3->OFF
      4->ON
   2、PC端发送程序
      DNW
      当运行DNW无法运行时，弹出一个对话框（... 内存不能读）

      如何解决：
      看看C盘根目录下有没有dnw.ini
      如果有删除它
      然后重新运行dnw

      DNW软件是三星提供的一个集
         USB通信和串口通信的一个软件
         该软件可以通过USB和IROM程序通信
         还可以通过串口和开发板上软件通信
      用该软件首先要配置
        1、配置串口参数
           usb下载地址暂时不用处理
           等到后面是一usb下载时再配置
        2、dnw软件连接串口
           此时dwn软件就开始监听所使用的串口了
           如果开发板端向pc端发送数据，dnw将接收
           并在dnw窗口显示
    3、通过DNW软件的USB发送功能，向开发板发送启动程序
       拨码开关拨到usb启动后，PC端启动
       DWN软件，
       启动开发板，IROM程序运行，然后检查启动配置管脚的
       状态，此时应该是USB启动，IROM程序就监听USB，
       如果连接成功，就从USB口接收数据，放到S5PV210微处理器
       内部的IRAM，PC通过DWN的USB发送功能发送。
       发送和接收完成，IROM程序去执行接收到IRAM的代码。

    4、如果你的电脑上之前没有使用过该方式下载的话
       会发现usb的新硬件
       如果出现该现象，说明usb口OK，然后提示安装驱动
       按照提示安装驱动：
       驱动在哪里？

       如果已经安装好驱动，dnw标题条会有变化 USB:OK
       此时说明USB连接成功

       其他情况失败
          1、开发板的USB口不好使
          2、PC的USB有问题
          3、USB线有问题

          换PC端的USB口
          换线
          换板子

     安装驱动、等成功后

     配置DNW的USB下载地址：0xd0020010
     接下来通过DNW的USB下载功能，向开发板发送程序
     arm\day01\x210_usb.bin

     配置DNW的下载地址为0x23e00000
     通过DNW的USB发送功能向开发板发送u-boot.bin
     程序

     当dnw窗口出现打印字符，等待按键时，按pc的空格键
     就停在 tarena#界面

     到此为止u-boot.bin在开发板的内存中运行起来。

任务：向开发板安装u-boot.bin程序
      1、向开发板什么地方装？
         闪存（Nand Flash），CPU旁边两边有管脚的
                             TSOP封装
      2、在我们的开发板上，程序在哪里运行？
         内存（DDR和SRAM）
         SRAM称为静态RAM（构造，结构）
              内部是门电路构成
           上电就可以工作
           速度快
           成本高
         DRAM称为动态RAM
              内部是电容构成
            如果内容需要保持的化，需要周期性的
            给电流刷新。
            DRAM控制器
            上电以后我们需要对DRAM控制器进行配置
            之后DRAM才能工作（供我们读写）
            速度慢（SRAM）
            成本低（容量比）

      我们开发板上有哪些内存？
          IRAM（SRAM）
          DDR（DRAM）
      IRAM在哪里？
          S5PV210 微处理器内部，看不见
          片内
          IRAM有多大？

      DDR在哪里？
          开发板上（核心板上）
          片外
          1 Gbytes



     在实施安装的动作时，我们几个提前条件？
        1、CPU本身的特性
        2、开发板怎么做的

     S5PV210微处理器有个特性：
        内部集成了ROM（IROM），三星出厂时在IROM中
        固化一段程序。
        当S5PV210处理器上电后，首先执行IROM程序
        IROM对硬件做个基本的配置，然后检测
        启动配置管脚的状态，根据状态来从不同的设备
        上读取启动代码。
        支持的设备包括：
            闪存
            SD卡（我们板子上是大卡）
            USB
            UART
    如果通过usb启动方式安装，需要PC端有配套的USB发送程序
    如果通过SD卡启动方式，我们就需要有SD卡系统制作软件。

    实施步骤：
    1、连线（电源，串口，USB）
    2、拨码开关拨到USB启动
       1->ON
       2->OFF
       3->OFF
       4->ON
    3、PC端启动DNW
       配置DWN的串口参数
       连接串口
           使DNW软件开始监控串口，如果开发板端
           通过串口发送数据过来，DWN就能接收到。
           我们实验中（人机交互的作用）
           DNW标题条有变化
    4、启动开发板
       如果PC端第一次使用这种方式，会提示发现新硬件
       需要安装USB驱动。
       电脑端换个USB口？
       DNW标题条会有变化：USB：OK
    注意：电源开启后CPU没运行，按白色的电源键（1秒）

    5、配置DNW的USB下载地址：0xd0020010
    6、使用DWN的USB发送功能，发送x210_usb.bin文件
       dnw发送x210_usb.bin，谁接收？
          IROM程序接收（三星写）

       x210_usb.bin 发送到哪里去了？
          IROM程序接收x210_usb.bin，并存放到
          0xd0020010地址处（内存）
          IROM程序执行内存中的x210_usb.bin

    7、配置DNW的USB下载地址: 0x23e00000

    8、通过DNW的USB下载功能发送 u-boot.bin文件
       IROM程序接收u-boot.bin，并存放都内存中
       内地地址为0x23e00000
       IROM程序接收完，执行内存中的u-boot.bin

    9、在dnw窗口按空格键
       tarena #

       说明我们的u-boot.bin已经在内存中运行起来
       OK.... tarnea #这些信息都是u-boot.bin
       通过串口发送出来的。

   问题：我们怎么确定数据是写入到IRAM还是DDR？（在我们
            的开发板上）

   问题：4根地址线能访问多大存储空间？
            16个字节
         10根？
            1024 1K
         32根？
            4 G bytes

         我们使用的S5PV210微处理器内部由32根地址线
          存储空间4G字节。
          采用平板式管理

          S5PV210处理器管理的存储空间！！4G
          这里面也包括内存
          开发板上内存1G字节。


    x210_usb.bin被放到IRAM（0xD0020010）
    u-boot.bin被放倒DDR（0x23e00000） 0x20000000--- 1Gbyte

    u-boot.bin为什么放到DDR？
       IRARM只有96K，放不下u-boot.bin
       u-boot.bin有300多K。

    问题我们把u-boot.bin放到开发板内存（DDR中）
    经过一个动作，先把x210_usb.bin放到0xd0020010（IRAM）
    中并执行。然后再把u-boot.bin放到0x23e00000（DDR）中
    执行。为什么这样做?

    为什么不直接把u-boot.bin放到DDR中？
       上电后，IROM程序没有配置DDR控制器，DDR不可以访问
       所以此时不能b-boot.bin直接放到DDR中。
    下载x210_usb.bin（放到IRAM），并执行后，x210_usb.bin
    对DRAM控制器进行了配置，使DDR可以工作，可以访问了。
    之后才可以把u-boot.bin放到DDR中。

    x210_usb.bin 配置DRAM控制器是只配置了300多K呢，
    还是都配置？
    x210_usb.bin 配置好DRAM控制器后，1G DDR都可以用了。


     10、把u-boot.bin写到开发板的闪存中
        u-boot运行
        u-boot命令：print 显示u-boot环境变量
               ipaddr=192.168.1.6
               ipaddr环境变量指定开发板的ip地址
               （只在u-boot执行时有效）

               serverip=192.168.1.8
               serverip 服务器IP地址（开发主机的ip地址）

               环境变量的值是可以改写
               setenv 命令可以改环境变量的值

                      闪存环境变量 setenv 环境变量的名

               saveenv 把环境变量保存到闪存


               help 查看帮助的命令
               help可以不跟参数，显示所有的命令
               help 命令名 显示某个命令的帮助

               dnw 是三星提供的，和PC端dnw配合使用的
                   usb下载命令


           通过u-boot.bin的dnw命令把pc端的u-boot.bin
           下载到开发板内存 0x20008000处

           通过PC端DNW的usb发送命令，发送u-boot.bin
           到开发板内存。

           如果提示校验和 OK说明下载成功
           至此，内存0x20008000处是不是就有了个和pc端
           一样的u-boot.bin。

           接下来我就把内存0x20008000处的u-boot.bin
           写入到闪存中去。

           闪存有个特性，如果闪存中有数据，再写入数据
           需要先擦除原来的数据，然后再写。

           我们需要先擦除指定位置的数据，然后再写。
           我们向闪存什么位置写呢？
           向闪存最开始写。
           我们系统中把闪存最开始2M 字节空间给
           u-boot.bin了。

           所以我先擦除闪存最开始的2M字节
           然后把u-boot.bin写入到闪存最开始。

           nand  erase 闪存擦除命令

           nand  erase  起始地址 大小

           nand  erase 0x0  0x200000
              从闪存最开始擦除，擦除2M大小

           注：u-boot命令中里面数值 0x0 0x200000
               0  200000 效果一样，默认是16进制

           nand write 命令把开发板内存中的值
                      写入到闪存中去。

           nand write 内存地址  闪存起始位置 大小

           nand write 0x20008000  0  100000


       dnw 0x20008000
       nand erase 0 0x200000
       nand write 0x20008000 0 0x100000

       至此 我们已经把pc上u-boot.bin写入到
       开发板闪存最是的300K，如果没出错。
       安装完成，可以检验。

       11、关电源
       12、拨码开关
           1->ON
           2->OFF
           3->OFF
           4->OFF
       13、开机
           按空格键，进入到u-boot命令行
           如果不按空格，延时结束后，u-boot自动去闪存
           加载linux内核到内存并执行。

      1、当我执行nand write命令向闪存写数据的时候
         开发板内存中有几个u-boot.bin?
         两个。
         一个正在运行，一个是存放在内存中。
         0x23e00000           0x20008000

         0x23e00000地方的接收者：IROM程序
            IROM程序接收完后，自动运行此u-boot。

         0x20008000地方的接收者：u-boot的dnw命令
            dnw命令只负责接收。
      2、我们写入到闪存的是哪个？
         0x20008000

      3、为什么多做一遍，费事？
         直接0x23e00000处的u-boot写入闪存可以不？

         原则：我们希望写入到闪存里面的u-boot.bin
               和PC上的应该是完全一样。

         因为0x23e00000处的u-boot.bin已经运行了，
         不能保证和pc上u-boot.bin完全一致了。
         所以我单独下载一次，并入写入。


         u-boot.bin 里面至少包括:
         代码  （code段）
         有初值的全局变量（data段）

任务：
     编写代码控制开发板上LED1的亮和灭。
     （裸板的软件开发）
     1、看图
        原理图
        目的：找到LED1在电路上的连接关系
        1、找出控制LED1亮和灭的CPU的管脚
           GPC1_3
           融汇广泽的 GPC0_3

        2、CPU的管脚输出高或者低 LED1亮或者灭
            输出高电平，LED1亮
            输出低电平，LED1灭

     2、S5PV210的说明书（手册）
        来知道如何控制CPU对应的管脚输出高和低电平


    为了控制LED1的亮和灭
    我们需要操作3个GPIO的寄存器
       GPC0CON
       GPC1CON    配置寄存器
                  配置管脚的功能的
                  我们需要配置成输出
                  GPC1 3
                  GPC0 3
                  BIT[15:12]
                      0001
      GPC0PUD
      GPC1PUD     上下拉电阻寄存器
                  我们实验里面禁止上、下拉电阻
                  GPC0  3 或者GPC1 3
                  BIT[7:6]
                       00
      GPC0DAT
      GPC1DAT     数据寄存器
                  GPC0 3  或者 GPC1 3
                  BIT[3] = 1  输出高电平
                  BIT[3] = 0  输出低电平



      通过网络方式把PC上的文件传到开发板内存
      tftp方式传输，需要tftp服务器，需要一个tftp客户端
      在我们的开发方式中谁作为服务器？谁作为客户端？
        电脑（开发主机）作为服务器，需要tftp服务器软件
        开发板端需要一个tftp客户端，u-boot的tftp命令

        u-boot 的tftp命令如何使用？
        tftp 下载地址   下载的文件名

             下载地址是开发板的内存地址
                把下载的文件存到开发板什么位置
             下载的文件名
                把服务器上的文件下载到开发板
                这个文件应该在tftp服务器端存在

        tftp  0x20008000  u-boot.bin

             把tftp服务器上的u-boot.bin下载到
             开发板内存中，内存地址是0x20008000

       为了使用tftp命令下载需要
          1、pc端需要安装tftp服务器，配置服务器
             tftpd-hpa

             配置 /etc/default/tftpd-hpa

          2、启用tftp服务器

             sudo /etc/init.d/tftpd-hpa  restart

          3、使用u-boot的tftp命令下载服务器上的文件
             到开发板内存。
             需要保证网络是连同。
             需要对网络做一个配置
             如果ping不同：
               1、网线
               2、pc端网口
               3、开发板端的网口
               4、可以尝试关闭pc端防火墙
         4、把u-boot.bin放到ubuntu的 tftp 服务器目录中
             /tftpboot

             tftp 20008000 u-boot.bin

通过网络把PC上的文件发送到开发板内存
1、配置PC的网络
   配置win的网络（IP地址，子网掩码）
       和开发板的IP在一个网段
   配置比虚拟机的网络设置
       网络方式使用桥接方式
       指定桥接到的和开发板连接的网卡
   配置ubuntu系统的IP地址
       和u-boot里面的serverip是相同的
       192.168.1.8

2、验证网络
   使用u-boot的ping命令
   如果ping不通
       1、先检查软件配置
       2、可以尝试关闭PC端的防火墙
       3、检查硬件
          网线、网卡（PC端和开发板端）

3、使用u-boot的tftp命令下载
   需要服务端：我们是在ubuntu里面
   安装、配置
   我们用的工作目录 /tftpboot

   开发板端在u-boot中使用：

   tftp 内存地址  文件名

   tftp 0x20008000 u-boot.bin

任务：编写C程序控制LED1的亮和灭
      一、通过看原理图
          1、LED1的控制端和S5PV210微处理器的管脚的
             连接关系
             GPC1 3
             GPC0 3
          2、S5PV210微处理器的管脚输出高电平
             LED1亮还是低电平LED1亮
             高电平  LED1 亮
             低电平  LED1 灭
     二、通过看微处理器的手册
         如何控制对应管脚输出高电平或者低电平
         GPC0 3   GPC1 3
         1、配置GPIO口
            配置寄存器  （地址）
                 配置成输出口
            上下拉电阻寄存器
                 禁止上、下拉电阻寄存器
         2、控制GPIO口输出高或者低电平
                 数据寄存器
                 如果输出高电平  数据寄存器对应位搞给1
                 如果输出低电平  数据寄存器对应位搞给0

   关于寄存器（GPIO寄存器类似的）访问：
   注意事项：
     保证我只修改我要修改的位，不修改其他的位
     读取->修改->写回


     /opt/

     压缩包，解压就可以了


     设置 PATH，把arm-linux-gcc的执行文件路径加进去。

     把led.c变成可以在开发板内存中运行的程序
     1、编译
     arm-linux-gcc -march=armv5te  -nostdlib  -c
                   -o led.o  led.c

                   -march=armv5te  指定生成的指令集
                                   使用arm的armv5te版本
                   -nostdlib  告诉gcc不使用C语言的标准库
    2、链接

    arm-linux-ld -nostartfiles -nostdlib
                 -Ttext=0x20008000
                 -e led_test led.o  -o led


                 -nostartfiles  指定不是有启动文件
                 -nostdlib      不用使用标准库
                 -Ttext=0x20008000 指定代码段的起始位置
                                   0x20008000
                 -e led_test    通常指定和你的第一个运行的
                                函数就可以了
                                （入口点）
                                在我们的案例里面没有用

     3、把链接生成的程序，转换成二进制的文件

        arm-linux-objcopy -O binary led led.bin
          把led转换成led.bin    led.bin是二进制的
                                去掉了格式信息

           -O binary 指定转换成二进制

     4、把led.bin放到开发板上运行，测试
        可以通过usb下载，串口下载，网络下载

        用网络
        把led.bin复制到 /tftpboot

        开发板端u-boot中执行tftp

        tftp 0x20008000 led.bin

        如果下载不下来，出问题，
           1、检查网络
           2、配置
           3、重新启动tftp服务器
      5、在u-boot中运行led.bin
         使用u-boot的go命令运行
         go 0x20008000


        奇校验： 0000 0000  1
                 0000 0001  0
                 0101 1000  0

        偶校验： 0000 0000  0
                 0000 0001  1
                 1010 1000  1



        看S5PV210串口的寄存器：

          ULCON0
          UCON0

          UFCON0    禁止FIFO，值给0
          UMCON0    禁止FIFO，值给0

          UTRSTAT0

          配置串口波特率
          UBRDIV0
          UDIVSLOT0


          UTXH0
          URXH0

          串口的发送和接收管脚
            看看GPIO章节
            把对应的管脚配置为串口功能

串口参数：
1、起始位  一个周期的0

2、停止位：1、1.5、2 个周期的0
3、数据的位数 5、6、7、8
4、校验位（奇偶校验）
5、速度（传输的速率）每秒钟多少位

ULCON0
UCON0
UFCON0    = 0
UMCON0    = 0

UTRSTAT0  状态寄存器（只读）

配置串口波特率
UBRDIV0
UDIVSLOT0

UTXH0    W
URXH0    R

串口的发送和接收管脚
    看看GPIO章节
    把对应的管脚配置为串口功能

计算波特率：
    我们串口编程时使用：PCLK做时钟源
    PCLK=66500000 Hz
    波特率是115200
    请计算 UBRDIV0  UDIVSLOT0寄存器的值
    UBRDIV0 = 35
    UDIVSLOT0 = 0x80


 完成任务：
    编写程序通过开发板串口向PC发送字符，
    （PC端DNW软件就能收到）
    1、串口参数：
       1、停止位个数 1
       2、不使用校验
       3、数据位数是8位
       4、波特率是115200
    2、我们需要指定开发板和PC连接的串口是
       S5PV210的哪个串口（S5PV210有四个）
       我们查到用的 S5PV210的 UART0

       座的2脚（PC串口的2脚）  RxD 接收
       座的3脚（PC串口的3脚）  TxD 发送

       PC3--->S5PV210的 RxD0
       PC2--->S5PV210的 TxD0

       1、和S5PV210微处理器的哪个串口连接
       2、使用交叉串口线还是直连串口线

链接脚本问题：
   1、连接脚本里面已经指定了 .o文件，ld命令行
      给定的*.o文件还需要不需要写。

      不可省

      命令的 main.o led.o 等等是指定给ld的输入文件

      链接脚本里面指定：根据给定的输入文件（*.o）
         确定*.o 里面的内容在执行文件中的位置。
   2、链接脚本里面
       .text :
       {
          *.o (.text);
       }
       *.o 情况下链接文件的顺序，由命令行给定.o的顺序
          决定的。

       如果命令行和链接脚本文件中都指定顺序，链接脚本
       文件中的顺序优先。

   3、ld命令的命令行可以通过 -T 来指定代码段、数据段
      的位置，链接脚本文件中也可以通过. = ????
      来指定代码段、数据段等的位置
      哪个有线？
      命令行优先

闪存特性：
       NOR  NAND Flash
            开发板上的
1、在出厂时（里面没有数据时）里面每个位都是1
2、已经写入数据后，再写数据，需要擦除原有的内容
   然后再写。
3、数据有块的概念，每次擦除有擦除的单位（通常称为块）
4、写入和擦除需要专门的命令
   有他们自己规定的指令
5、写入数据是把里面的1->0
     不能把0->1
     如果已经写入数据了，需要擦除
     擦除的动作就是把0->1  一块擦除完毕把整块都改成1
6、块有坏的
7、闪存一般（nand flash）需要ECC错误纠正处理
   读取的时候有可能发生位翻转。
8、块的擦除有次数限制

   我们使用闪存，注意：
       记录管理 坏块（软件：坏块管理算法）
       需要使用ECC纠错
           1BIT ECC，4BIT ECC, ... 40BIT ECC
           访问一组数据时（2K或者512字节），能
           识别1BIT位翻转，1BIT ECC算法
           识别4BIT位翻转，4BIT ECC算法
           决定系统中使用几BIT ECC需要看闪存的手册。
       写均衡

 回顾：
     写LED驱动，需要看图，CPU手册
     UART驱动， 需要看图，CPU手册
     nand flash驱动，看图，看闪存手册，看CPU手册

     tarenacode
     code_2013

     int page_offset;
     int page_num;

     CMDADDR = (page_offset & 0xFF);
     CMDADDR = ((page_offset >> 8) & 0xF);

     CMDADDR = (page_num & 0xFF);
     CMDADDR = ((page_num >> 8) & 0xFF);
     CMDADDR = ((page_num >> 16) & 0x7);






     TACLS    CLE由低到高开始--->nWE由高变低
              Tcls -  Twp
              12ns - 12ns
              =0

              1/HCLK 时钟周期  时间 ns

              15 * 1/HCLK >= ??


     TWRPH0   nWE低电平的时间
              =Twp
              =12ns

              12ns/(1/HCLK)  = TWRPH0



     TWRPH1   nWE由低变高--->CLE由高变低
              =Tclh
              =5ns

     到闪存手册里面找到对应的时间长度
     然后根据CPU的说明来计算三个值

游成伟
15801588497
409025260@qq.com

1.三个要求：
  安装纯linux系统
        建议：ubuntu,fedora,kali
        友情提示：备份重要资料,建议安装32位系统

  安装必要的软件
        建议采用网络安装命令：
                ubuntu安装命令：apt-get install
                fedora:yum install
        必要安装的软件：以ubuntu为例
        sudo apt-get install vim
        sudo apt-get install minicom kermit //串口工具
        sudo apt-get install tftpd-hpa //tftp网络服务
        sudo apt-get install nfs-kernel-server //nfs网络服务
        sudo apt-get install ctags cscope //源码阅读工具
        sudo apt-get install openssh-server //远程登录软件

  注意：遇到问题先搜索,先尝试自己解决！

  每天半小时笔试题：MS.rar
  将重复次数多的笔试题摘抄到笔记本上(纸质),务必背下来！
  例如：阐述static作用

2.回顾ARM裸板开发相关内容
  面试题：为什么要学嵌入式？
  面试题：谈谈对嵌入式系统的认识？
  面试题：谈谈对嵌入式软件开发的认识？

  明确：嵌入式软件开发形式：
  裸板程序开发：
              软件开发框架：
              main(void) {
                xxx_init(); //各种硬件初始化
                ....

                while(1) {
                        处理业务
                }
              }
              ARM裸板程序开发关键点找到main函数即可！

  带操作系统的程序开发：
            必须严格按照操作系统的编程规范进行,不能随便
            任何编写代码
  主流的嵌入式操作系统：
        linux
        vxworks
        wince

  明确：计算机组成形式
  从硬件层面分析：由CPU和外设组成
  “外设”：不仅仅包括肉眼在开发板上看到的硬件设备
          还包括处理器内部集成的各种硬件控制器
  切记：CPU一天到晚都是在跟外设进行数据的通信！
  细分：以CPU通过UART访问BT外设(蓝牙)整个过程：
  访问过程如下：
  1.研究CPU核访问BT外设
  2.转移到研究CPU核访问BT对应的UART控制器
  3.转移到研究CPU核通过访问控制器对应的寄存器
    注意：这些集成的寄存器同样的外设！
  4.切记切记：CPU核访问外设都是以地址指针的形式访问即可
    也就代表只要搞清楚外设的基地址,即可软件编程访问这个
    外设；
    注意：如果搞不清楚基地址,咨询硬件工程师！

  5.总结：CPU核通过软件访问UART的寄存器,后序的访问都是
    硬件自动化完成！

  从软件层面上："CPU一天到晚,软件做什么事情呢"
  不是处理进程就是处理中断！

  面试题：谈谈进程和线程的区别

  案例：以DM9000网卡的访问为例：
  分析过程：
  1.掌控硬件信息：
    粗看："把玩"
        把握外设DM9000网卡芯片在开发板的位置(标签)
        可以用放大镜观察,观察芯片上方的型号！
        如果不清楚,问硬件工程师！
        结果：记住DM9000网卡在开发板上的标签(UT2)

    细看：
       1.打开原理图,根据标签在原理图上找到对应的位置
         马上建立一个CPU访问DM9000的连接图出来
       2.根据CPU和DM9000网卡的硬件连接图确认它们之间的
         通信方式，计算机硬件通信方式：
         1.GPIO通信,例如LED
           就是输入和输出操作
         2.UART通信,例如BT
           CPU只要访问UART控制器即可
         3.总线方式,有地址线和数据线
           只需搞定基地址即可,基地址由管脚CS(chip select)(=CE chip enable)
           来决定
           只要有了基地址,将来以地址指针的形式访问DM9000网卡
           即可,访问完全类似内存,需要额外配置相关的寄存器
           DM9000网卡的CS管脚连接到CPU的Xm0CSn1

           根据CPU的Xm0CSn1管脚确定DM9000网卡的基地址
           此时此刻打开CPU的芯片手册P29
           切记:Xm0CSn1对应的就是SROMC_BANK1
           最终确定：SROMC_BANK1的基地址为0x88000000
           也就是DM9000网卡的基地址为0x88000000
           将来访问DM9000网卡：
           *(unsigned long *)(0x880000000+地址偏移量) = 0x55；

           不会找的问硬件工程师

         4.I2C通信方式
         5.SPI通信方式
         6.1-Wire通信方式
           ...
      3.根据不同的通信方式进行操作
        除了总线方式,其他都是访问控制器对应的寄存器即可！

    3.打开CPU的芯片手册查阅控制器对应的寄存器的使用
      关键找两点：
      寄存器的基地址
      寄存器的使用(每一个BIT的功能)
      当然还要结合DM9000网卡本身的芯片手册

**********************************************************
3.回顾Nand相关操作
  面试题：阐述Norflash和Nandflash的区别
  面试题：谈谈对UART的理解
          一定要画时序图,以CPU通过UART发送数据0x95为例,画出
          时序操作图,UART的配置信息：115200 8e1
  场景：CPU如何去读写Nand
  实施步骤：
  1.明确NandFlash的作用
    存储数据,类似硬盘
  2.掌控Nand的硬件信息
    粗看：
        肉眼观察Nand的位置,找到Nand的标签
        结论：
        1.Nand型号：K9K8G08U0B
          注意：容量的单位(Byte,bit)
          8Gb = 1GB
        2.标签MU1

    细看：
        1.打开核心板的原理图,根据标签MU1找到连接图位置
        2.掌控Nand的硬件连接
          Nand     S5PV210               功能
          IO0~IO7  Xm0DATA0~Xm0DATA7    用来传输数据
          #WE	   Xm0FWEn		写使能
          #RE	   Xm0FREn		读使能

          #CE1	   Xm0CSn2		使能芯片
          (chip enable=片选使能)
          注意CE:由于CPU的8根数据线Xm0DATA0~Xm0DATA7即连接到
          DM9000网卡又连接到Nand,通过CE(CS)片选管脚来决定8根
          数据线上传输的数据给哪个芯片,例如：
          如果将Nand的CE拉低,表示使能Nand,8根数据线上传输的
          数据给Nand,同时DM9000网卡的CS管脚必然拉高(拉高可以认为
          这个DM9000网卡芯片没有焊接一样)

          R/#B0	  Xm0FRnB0		判断Nand是否准备就绪
          如果Nand准备就绪,R/B0为高电平
          如果Nand忙,R/B0为低电平

          注意：由于Nand采用GPIO接口,只有数据线,无地址线,所以
                CPU不能像访问内存一样,以地址指针的形式访问,
                没有地址线,怎么访问Nand的存储空间呢？
                答：没关系,Nand的访问操作只需三步骤即可：
                1.CPU先发命令
                2.CPU再发要访问的Nand存储空间的地址
                3.CPU最后发送(读取)要访问的数据
                4.命令,地址,数据都要经过8根数据线进行传输
                5.问：8根数据线如何区分到底传输的是命令,地址还是数据呢？
                  答：通过CLE和ALE进行区分
          CLE:当CLE为高电平时,数据线上传输的命令
          ALE:当ALE为高电平时,数据线上传输的Nand芯片内部的存储空间地址
          当ALE和CLE都是低电平时,数据线上传输的数据

        3.慢慢品味Nand的芯片手册
          掌控Nand的硬件特性：
          1.存储容量1GB
          2.采用GPIO通信接口
          3.以页为单位，1页=2048B
            以块为单位, 1block=64个页
          4.存储空间地址的划分：
            行地址：页编号(第几个页)
            列地址：页内偏移
            注意：这些地址在访问的时候同样需要8根数据线传输

          例如：CPU想访问Nand片内8000这个存储空间对应的地址
          分析：
          1.首先换算8000这个地址对应的行地址和列地址
          2.明确地址换算出来以后,只能通过8根数据线上传输

          行地址：8000/2048=3=0x3
          列地址：8000-2048*3=1856=0x740

          第一次：CPU发送0x740&0xff=0x40
          第二次：CPU发送(0x740>>8)&0x0f=0x7
          第三次：CPU发送0x3 & 0xff = 0x3
          第四次：CPU发送(0x3 >> 8)&0xff=0x00
          第五次：CPU发送(0x3 >> 16) & 0x07=0x00

          CPU通过8根数据线将地址发送给Nand,就等价于告诉nand
          ,我要访问你8000这个地址

       4.Nand的操作无非就是读,写,擦除
         CPU如何读,写,擦除这些操作,具体要参见Nand的操作时序图
         "时序图"：就是14根信号线的操作电平状态
         以CPU读取Nand ID信息为例,画出时序图P35

     4.最后品味S5PV210的芯片手册,只看Nand控制器相关的章节
       研究对象的转移：
       1.CPU操作Nand
       2.CPU操作14根信号线
       3.CPU操作控制器(控制器会帮你操作14根信号线)
       4.CPU操作控制器对应的寄存器
       5.打开CPU的芯片手册,掌握Nand控制器的寄存器的操作特性
         把握两点,P692：
         1.抓住寄存器的基地址,将来要以地址指针的形式访问
         2.抓住寄存器的操作功能

案例：编程实现CPU读取Nand ID信息,并且打印ID信息

回顾：
1.Nand相关内容
  作用：存储数据
  比较对象：NorFlash
  内部特性：
        页
        块
        行地址
        列地址
  硬件连接：
        14根信号线
                画出简要的连接图
  操作步骤：
        命令
        地址
        数据
                画出操作时序图(画出CPU读取Nand ID信息的时序图)
  软件编程：
        研究对象转移：
        CPU操作Nand芯片
        CPU操作14根信号线
        CPU操作Nand控制器
                以上三步骤,将来由硬件自动完成！
        CPU操作寄存器(控制器)：软件编程,结合CPU的芯片手册和Nand的芯片手册
                画出硬件操作框图

        软件编程的方法：
        1.CPU绕开Nand控制器,直接采用GPIO模拟Nand时序
        2.CPU直接操作控制器对应的寄存器,将来控制器硬件
          自动发起Nand时序
        3.对比：
          方法1：虽然能够实现对Nand芯片的访问,但是效率极其低下
                 但是对Nand的访问过程极其之明确
          方法2：访问Nand效率势必高效,但是访问过程比较朦胧
  切记：嵌入式软件开发,只要涉及硬件外设的操作,必须要看硬件外设的
        操作时序图！这才是王道！
        将来可以通过示波器抓取时序图,做进一步的分析

案例：用户需求读取Nand一页的数据信息,并且打印数据信息
      分析：
      1.掌握Nand读的时序图P27
      2.提示将读取的数据放到内存的0x20018000地址空间

案例：用户需求能够擦除Nand一块数据信息
      时序图：P32

案例：用户需求向Nand写一页的数据
      时序图：P29

面试题：谈谈对UART的认识
其中必须画出UART的时序操作图
以CPU通过UART发送0x95数据为例,并且UART的工作参数115200,8e1

********************************************************
2.面试题：谈谈对ARM处理器的理解
1.ARM概念
  1.1.既可以认为是一家公司,ARM公司,设计和卖IP授权,不生产具体处理器
  也可以认为是一种处理器架构,类似X86架构

  1.2.常见生产ARM处理器的芯片厂家：
  华为海思
  全志
  联芯
  联发科(MTK)
  英伟达
  三星：消费类电子
  飞思卡尔：军工,汽车电子
  TI(德州仪器)：达芬奇系列,OMAP系列
  ATMEL:工控
  高通：消费类电子
  博通：网络功能相当强悍！树莓派

  1.3.其余特性
  1.ARM架构采用RISC设计思想
    RISC:精简指令集,ARM
    CISC:复杂指令集,X86
    前者是硬件做的事比较少,软件做的事比较多
    后者是硬件做的事比较多,软件做的事比较少

  2.ARM核版本的划分
    明确：ARM核仅仅指CPU核,不包括外设(寄存器,控制器等)
          由ARM公司设计
    ARM核大版本        ARM核小版本      具体处理器(芯片厂家)
     ARMV4             ARM7		S3C4510(三星)
                       ARM9		at91rm9200(Atmel)
     ARMV5	       ARM10		S3C6410(三星)
                       XScale		pxa270(intel)

     ARMV6	       ARM11		MSM7200(高通)
     ARMV7	       CORTEX-A8	S5PV210(三星)
                       CORTEX-M3	STM32(ST)

     ARMV8(支持64位)   CORTEX-A53       MTK6732(联发科,4核)

   3.ARM7核特性
     3级流水线
     冯.诺伊曼：地址数据共用,处理时需要进行区分,ARM7
     哈弗：地址数据分开,ARM9以后

   4.ARM 3级指令流水线
     明确：
        “指令”：给CPU下达的动作指令(二进制)
        “流水线”：提高CPU处理指令的效率
        "3级指令流水线":CPU相应指令需要经过3步骤
                        类似生产电视机的流水线
        指令就相当于电视机
        指令最终让CPU得到执行需要经过三个硬件,三步骤去完成：
        第一步骤：取指,对应的硬件叫取值器,类似电视机组装
        第二步骤：解码,对应的硬件叫解码器,类似电视机包装
        第三步骤：执行,最终由CPU执行,类似电视机搬移

        说明：
        取指：取值器将指令(二进制代码)由内存拷贝到CPU
        解码：解码器将指令最终翻译成CPU能够识别的语言
        执行：结果取指,解码以后,CPU最终执行
        注意：以上三个硬件都是在CPU核内部
        切记：ARM核里面由一个寄存器,叫PC,永远保存取指指令的地址
        注意：寄存器分类：
        一类是特殊功能寄存器,就是之前咱们编写时使用的控制器
        内部的一大堆寄存器,这些寄存器的访问必须以地址指针的
        形式访问；
        另一类寄存器又称ARM寄存器,这些寄存器仅仅存在于ARM核
        内部(例如pc),访问无需通过地址指针的形式访问,通过名字
        来访问

        注意：画出3级流水线的处理示意图

     5.3级流水线的特例
       ldr指令功能：cpu根据这个指令,将内存中的数据拷贝到CPU核中
                    但是ldr指令不是3级流水线,而是5级流水线
                    F(取值)->D(解码)->E(执行)->M(访存,访问内存地址)->W(如果地址ok,将地址存储空间中的数据拷贝到CPU核中)
                    ldr指令执行时,在M和W阶段,后序两条指令将处于等待状态
       bl指令功能：跳转指令,CPU根据这条指令能够跳转到某个
                   地方去"执行"(取值,解码,执行),同样经过5级流水线：
                   F(取值)->D(解码)->E(执行)->L(跳转)->A(保存返回地址)
                   同样后序两条指令不会得到处理

       中断处理：
       问：何为中断
       答：
       1.中断是计算机一个相当重要的机制

       问：为什么有中断机制呢？
       答：明确CPU一天到晚都在跟外设进行数据的通信,由于CPU的
       处理速度远远快于外设,这里存在数据处理的速度不一致的问题
       为了保证CPU能够正常和外设进行数据通信,一种最简单的办法就是
       CPU轮询(死等)获取外设的数据,采用轮询可以保证数据正确，但是
       相当耗费CPU资源,大大降低了CPU的利用率,因为CPU不能干其他的事情
       只能死等死读这个外设！
       此时此刻可以采用中断机制来解决此类问题,这里以CPU读取
       UART数据为例,当CPU读取UART数据时,发现数据没有准备就绪,
       CPU不再轮询读取UART,而是做其他的事情(比如处理一个进程),
       一旦UART准备好数据了,UART会给CPU发送一个中断电信号(嗨,我这边有数了,请来处理)
       CPU一旦接收到了这个中断电信号,会停止手头的工作,转去处理UART
       ,处理UART完毕,CPU继续接着执行原先被打断的事情,在这个过程中
       CPU至少做2件事,大大提高了CPU的利用率！

       英文缩写：IRQ
       总结：轮询和中断永远是死对头！

       中断的流水线处理：4级：DI->EI->L->A

       总结：能够画出3级流水线的示意图即可
             ldr,bl,中断仅作了解即可！

   4.ARM9以后的版本一律采用5级流水线
     3级流水线没有把M和W合法化,仅仅是ldr指令才有M和W；
     但是5级流水线的任何一个指令都有M和W,换句话就是任何
     一个指令将M和W合法化！

     画出5级流水线的示意图即可！
     复习数组的方括号[]
     a[3] = *(a + 3);
     []运算经过2步骤：
     1.先求地址：a + 3
     2.在从地址中取数据:*(a + 3)

3.ARM编程模型
  3.1.ARM工作模式
  明确：有7中工作模式,CPU同一时刻只能处在一种工作模式下
  分别是：
  SVC管理模式：当系统Reset复位,CPU自动切换到SVC管理模式
               当软件调用svc指令,触发软中断,CPU自动切换到SVC管理模式
               当CPU进入这个模式下,此时CPU的执行权限最高！

  FIQ快速中断模式：当外设给CPU发送的中断信号以FIQ发给CPU是
                   CPU一旦接收到这个中断信号,CPU自动切换到
                   FIQ模式
  IRQ中断模式：当外设给CPU发送的中断信号以IRQ发给CPU时
                   CPU一旦接收到这个中断信号,CPU自动切换到
                   IRQ模式
               问：外设的中断信号如何指定为FIQ还是IRQ呢？
               答：通过中断控制器来指定

  Abort终止模式：当CPU访问某个非法地址或者访问某个非法数据时
                 CPU自动切换到Abort终止模式

  Undef未定义指令模式：当CPU执行某个CPU不认识的指令时,CPU
                自动切换到未定义指令模式,例如：CPU执行zhangsan指令

  System系统模式：
  User用户模式：
                以上两个模式是一样的,区别仅仅是权限不一样,
                前者的权限高于后者,例如：一个程序在运行时
                一般处于User模式

  3.2.ARM的工作状态
  分ARM状态和THumb状态
  当CPU处于ARM状态时,对应的指令为ARM指令,宽度为32位
  当CPU处于THumb状态时,对应的指令为THumb指令,宽度为16位
  注意：一般CPU都是处于ARM状态！

回顾:
面试题：谈谈对ARM处理器的认识
1.ARM概念
  公司
  处理器架构,类似X86
        常见的嵌入式处理器：
        ARM
        Powerpc
        MIPS
        DSP+ARM核
        FPGA+ARM核
        低端单片机(51)
  回忆：嵌入式系统概念
        以用户需求为中心,满足用户的基本需求
        软件和硬件可以进行裁剪(可以加也可以减)
             本质：硬件依赖用户需求
                   软件依赖硬件
        功能合适即可
        可靠性要好
        体积？
        功耗要低
        成本要合理
        一定要举例子：以iphone手机和诺基亚的5230(低端)
                      为例,进一步说明概念
   常见ARM处理器的芯片厂家

2.ARM核版本划分
  明确：ARM核由ARM公司设计,各个芯片厂家根据IP授权造处理器
  大版本和小版本
  例如：S5PV210:
                某款处理器,三星
                CORTEX-A8
                ARMV7

3.ARM指令流水线
  ARM7之前采用3级流水线：取指F->解码D->执行E
  画出一个3级流水线的处理示意图

  ARM9以后采用5级流水线：取指F->解码D->执行E->访存M->写回W
                                            并不是所有的指令都有M
                                            但是这个动作必须要有
  画出一个5级流水线的处理示意图

4.ARM的7种工作模式
  明确：中断机制
        产生的根本：外设的处理速度远远慢于CPU
        可以考虑使用轮询方式(死等)
        也可以考虑使用中断机制
  场景				CPU工作模式
  复位或者代码调用svc指令       SVC管理模式
  外设给CPU发送FIQ中断信号      FIQ快速中断模式
  外设给CPU发送IRQ中断信号      IRQ中断模式
  切记：外设产生的中断电信号不是直接给CPU核,这个中断电信号
        一定要先到达中断控制器,由中断控制器来决定将来这个
        中断电信号以什么样的方式(FIQ/IRQ)发给CPU核
  访问地址或者数据不合法	Abort终止模式
        *(int *)0 = 0;
  CPU执行一个不认识的指令       未定义指令模式
  应用程序正常运行时		User模式
                                System模式

5.ARM的2个工作状态
  ARM状态：
        CPU执行的指令为ARM指令,宽度32位
  Thumb状态：
        CPU执行的指令为Thumb指令,宽度16位
  注意：CPU在两个状态的切换只需执行执令BX即可
        例如：
        BX  地址
        地址[0] = 1:CPU进入Thumb状态
                BX 0x20008001
        地址[0] = 0:CPU进入ARM状态
                BX 0x20008000

6.ARM核寄存器的组织方式
  明确：一款处理器不仅仅包括ARM核(CPU核),还包括一大堆的
        控制器(控制器里面又有一堆的寄存器)
  控制器里面的一堆寄存器又称特殊功能寄存器,这些寄存器的访问
  通过地址指针的形式访问；
  ARM核内部同样包含了一大堆的寄存器,又称ARM寄存器,这些寄存器的
  访问通过名字访问即可
  不管是什么寄存器,它们的作用都是一样,用来暂存数据

  6.1.ARM的37个寄存器
      通用寄存器：
      r0~r15:通用
      r15=pc:永远保存取指指令的地址,只有一个
      r14=lr:保存返回地址
      r13=sp:保存栈指针
      FIQ模式有单独自己的r8~r14
      IRQ,SVC,Abort,Undef有单独自己的r13和r14
      寄存器在使用时,通过名字来区分,注意不区分大小写！

      程序状态寄存器：cpsr,只有一个
                例如：
                int a = 1;
                int b = a  - 1; //程序的运算结果b=0
                将来会根据运算结果b影响cpsr,也就是cpsr
                保存的b的运算结果,例如结果为0

      保存程序状态寄存器：spsr,除了system和user其余模式都有单独的spsr
                          当CPU发生模式切换时,CPU会自动将
                          cpsr的值保存在spsr,将来再切换回去,
                          再将spsr恢复到cpsr

     重点关注CPSR程序状态寄存器：保存程序的运行状态
     BIT[4:0]:保存CPU的工作模式
     BIT[5]:保存CPU的工作状态
            =1：THumb状态
            =0：ARM状态
     BIT[6]:禁止或者使能FIQ
            =1：禁止CPU核相应FIQ中断
            =0：让CPU相应FIQ中断
     BIT[7]:禁止或者使能IRQ
            =1：禁止CPU核相应IRQ中断
            =0：让CPU相应IRQ中断
     BIT[28]:保存程序运算的结果是否发生过溢出
            =1:溢出
            =0:没溢出
            V位
     BIT[29]:保存程序运算的过程是否发生过进位或者借位
            =1:发生过
            =0:没有
            C位
     BIT[30]:保存程序运算的结果是否为0
            =1：运算的结果为0
            =0: 结果不为0
            Z位
     BIT[31]:保存程序运算的结果是否是负数或者小于
            =1:负数或者小于
            =0:正数或者大于
            N位
     结果：N,Z,C,V又称条件标志位
     切记：指令后面加S,程序的运算结果会影响N,Z,C,V
     例如：
     add r0, r0, r1 //即使r0的结果为0,也不会影响cpsr
     adds r0, r0, r1 //将来r0的结果会影响cpsr

7.ARM的7种异常
  “异常”：事件的发生具有随机性
  7.1.7种异常
  1.Reset复位异常
    当按复位键,系统重启时触发,一旦发生复位异常,CPU硬件自动
    跳转到0x00地址去“运行”(取指,解码,执行)
  2.undefine未定义指令异常
    CPU执行一个不认识的指令时触发,一旦发生这种异常,CPU硬件
    自动跳转到0x04地址去运行
  3.软中断异常
    软件代码调用svc指令时触发,一旦触发这种异常,CPU硬件自动
    跳转到0x08地址去运行
  4.预取异常
    当CPU访问某个地址或者指令非法(权限不够),一旦发生这种
    异常,CPU硬件自动跳转到0x0c地址去运行
  5.数据异常
    当CPU处理数据时（权限不够）触发,CPU硬件自动跳转到
    0x10地址去运行
  6.IRQ异常
    当CPU接收到IRQ中断信号时触发,CPU硬件自动跳转到
    0x18地址与运行
  7.FIQ异常
    当CPU接收到IRQ中断信号时触发,CPU硬件自动跳转到
    0x1C地址与运行

 7.2.异常处理
 明确：一旦异常发生了,CPU必须要响应和处理异常,ARM核处理
 异常的步骤：
 ARM核硬件将要做以下动作：
 1.将cpsr的值备份到对应模式下的spsr
   spsr_mode = cpsr
 2.设置cpsr相关的状态
   bit[4:0]设置为对应的模式
   bit[5]设置为0,切换到ARM状态
   bit[6]设置为1,禁止FIQ
   bit[7]设置为1,禁止IRQ
 3.将下一条指令的地址保存在对应模式的lr中
   将来便于返回
 4.设置PC的值,让PC执行对应异常的处理入口地址
   例如,如果是IRQ中断异常,PC=0x18,也就代表着让CPU跑到
   0x18地址去运行
 5.一旦PC指向某个异常处理的入口地址,后序的事情都是
   软件来实现,具体里面做什么事,完全由你来决定

 6.异常一旦处理完毕,最终面临要返回的命运,返回处理
   不能是由硬件完成,而是软件操作返回，软件只需做两件事：
   1.从spsr_mode恢复cpsr
     cpsr=spsr_mode
   2.从lr_mode恢复pc
     pc=lr_mode(保存原先指令地址)

  7.3.异常向量表
  异常向量表：就是将你自己写的一个函数地址分别放在7个异常
  对应的处理入口地址,将来一旦异常发生了,CPU最终调用执行
  对应的函数！此向量表格式由ARM公司定死,由软件编程实现！
  画出异常向量表

8.ARM的数据类型
  字节
  半字
  字
  双字
  内存对齐：字节,半字和字对齐
  笔试题：
  struct Stu{
        char a;
        int b;
        char c;
  };
  请问：sizeof(struct Stu) = ?

  笔试题：编程实现判断当前处理器是大端模式还是小端模式？

9.ARM汇编编程框架
  9.1.参考代码：
      .text  @代码段的起始
      .code 32 @采用ARM指令
      .global  start @声明一个全局标号,名称为start
start : @标号起始
        mov  r0,  #10	@r0=10
        ldr    r1,  =3  @r1=3
        add   r0,  r0,  r1 @r0=r0+r1=10+3=13
        b       .  @while(1);
       .end  @代码段的结束

    切记：PC的值是如何变化的,通过一下三条指令,掌握PC寄存器
        指令内存地址   指令
        0x8000         mov  r0,  #10	@r0=10
        0x8004         ldr    r1,  =3  @r1=3
        0x8008         add   r0,  r0,  r1 @r0=r0+r1=10+3=13
        问：当mov指令执行的时候,PC寄存器的值为？
        答：明确：PC寄存器就是流水线中的"监工",永远指向取指
            当mov指令执行的时候,PC=0x8008,这个赋值过程由硬件
            自动完成
        问：如果已知PC,问执行指令的地址为？
            执行指令的地址=PC-8

  9.2.影响CPSR条件标志位N,Z,C,V的情形
  1.指令后面加S,指令的运算结果会影响CPSR的N,Z,C,V
    mov r0, #1
    sub r0, r0, #1 @即使运算的结果r0=0,也不会影响cpsr的Z位
    或者
    subs r0, r0, #1 @运算的结果r0=0,势必影响cpsr的Z位=1
  2.特例：cmp指令,这条指令不加S也会影响cpsr的Z位
    cmp r0, #0
    addeq r0,r0,#1 @add执行的前提是r0和0比较的结果相等
    subne r0,r0,#1 @sub执行的前提是r0和0比较的结果不相等

  案例：编写汇编代码,实现两个数相加
  实施步骤：
  1.在linux虚拟机中安装qemu-arm模拟器
    1.1.从ftp下载qemu.rar安装包
    1.2.windows解压缩,把qemu拷贝到linux虚拟机中
        sudo chown tarena /opt -R
        sudo chgrp tarena /opt -R
        将/opt目录的用户和组改为tarena用户和tarena组
        cp qemu /opt/ -frd
    1.3.安装qemu
        cd /opt/qemu
        sudo dpkg -i *
  2.编写汇编代码,实现两个数的加或者减
    mkdir /opt/arm/day09/1.0 -p
    cd /opt/arm/day09/1.0
    vim do_sub.s //汇编文件都是以.s结尾 添加如下内容：
    .text @代码段
    .code 32
    .global _start
    _start:
        mov r0, #0
        mov r1, #9
        mov r2, #2
        sub r0, r1, r2 @r0 = r1 - r2
        b . @while(1)
        .end @结束
    保存退出
    编译：
    arm-linux-as -g -o do_sub.o do_sub.s
                            -g:添加调试信息
    arm-linux-ld -o do_sub do_sub.o
                    do_sub就是二进制可执行文件

  3.利用qemu-arm和arm-linux-gdb调试器运行do_sub
    在虚拟机中开一个终端,输入：
    cd /opt/arm/day09/1.0
    qemu-arm -g 1234 do_sub //-g 1234:指定端口号为1234

    再虚拟机中打开一个终端,输入：
    cd /opt/arm/day09/1.0
    arm-linux-gdb do_sub //开始运行do_sub程序
    此时此刻会出现(gdb)提示符,接着输入：
    (gdb)target remote localhost:1234
    开始利用gdb的命令调试do_sub，接着输入：
    (gdb)l  //list查看代码命令
    (gdb)b 行号 //在对应的某行设置一个断点
    (gdb)s  //下一步,如果有子函数,将会进入子函数去跟踪代码执行
    或者
    (gdb)c  //也是下一步,如果有子函数,不会进入子函数去跟踪代码执行
    (gdb)info reg //查看ARM所有寄存器的值
                    打印r0,r1,r2...cpsr,spsr的值
    (gdb)quit //退出arm-linux-gdb

10.ARM汇编指令集
   10.1.ARM核(CPU核)跳转的方法3种：
   方法1：发生异常
          按复位键,CPU毫无条件到0x00地址运行
   方法2：调用b或者bl指令
          bl helloworld //让CPU跳转到helloworld标签与"运行"
          ....
          helloworld:
                add r0,r0,#1

   方法3：直接给pc赋值
          pc = 0x20008000 //让CPU到0x20008000"执行"

   10.2.ARM指令集之跳转指令b和bl
   b指令：不带返回的跳转指令(一去不复返)
   例子：
        b loop   @无条件执行
        ...
        loop:
                ...
        或者：
        beq loop @如果上一条指令的运算结果相等(Z=1),那么就会跳转到loop,否则不跳转
            ...
        loop:
                ...

  bl指令：带返回的跳转指令
          切记：当CPU执行bl执行时,CPU硬件自动将下一条的指令的
          地址保存在lr寄存器中,返回时需要软件手动返回,代码如下：
          mov pc, lr
        例如：
     START:
        MOV	R0, #1
        MOV	R1, #2
        BL	DoAdd  @硬件自动将B .这条指令的地址保存在lr
        B	.
             …
     DoAdd:
        ADD	R0, R0, R1
        MOV	PC, LR @让CPU到B .这条指令去"运行"

  案例：编写汇编代码,实现1+2+3+...+10
  实施步骤：
  1.mkdir /opt/arm/day09/2.0 -p
  2.cd /opt/arm/day09/2.0
  3.vim sum.s 添加如下内容
    .text
    .code 32
    .global _start
    _start:
        mov r0, #0
        mov r1, #10

    sum:
        add r0, r1, r0
        sub r1, r1, #1
        cmp r1, #0
        bne sum

    .end
  4.编译
    arm-linux-as -g -o sum.o sum.s
    arm-linux-ld -o sum sum.o
  5.运行
    qemu-arm -g 1234 sum
    arm-linux-gdb sum
    target remote localhost:1234
    l
    b 行号
    s
    info reg
    s
    info reg
    ...
    s
    info reg

回顾：
面试题：谈谈对ARM的认识
1.ARM概念
2.ARM流水线
  画图
3.ARM工作模式
  7种
4.ARM工作状态
  2种
5.37个ARM寄存器
  画图
  cpsr:
        bit[4:0]
        bit[5]
        bit[6]
        bit[7]
        bit[31:28]=NZCV
6.ARM异常
  7种
  情景          工作模式        异常        CPU运行地址
  复位           SVC            复位异常     0x00
  指令不识别     undefine       undefine     0x04
  代码调svc指令  SVC            软中断       0x08
  预取出错	 Abort          预取         0x0c
  数据出错       Abort          数据         0x10
  保留           保留           保留         0x14
  IRQ中断        IRQ            IRQ          0x18
  FIQ中断        FIQ            FIQ          0x1C

  切记：如果异常发生,CPU到对应异常处理入口地址去执行,可以在
  在对应的入口地址放置相关的软件处理代码,最终形成所谓的异常
  向量表,画出异常向量表的示意图

7.ARM汇编编程框架
  .text
  .code 32
  .global _start
  _start:
        汇编指令代码
  .end

8.ARM指令集
  推荐书籍<<ARM体系结构与编程>>杜春雷
  切记：CPU跳转的方式方法
  发生异常
  调用跳转指令:b/bl
  直接给PC寄存器赋值
  条件助记符：eq/ne/...
  指令加s和不加s,除了cmp
  跳转指令:
        b:不带返回跳转
        bl:带返回跳转
           切记：CPU执行bl,CPU硬件自动将下一条指令的地址
           保存在lr,将来返回时,只需pc=lr(软件完成)

9.ARM指令集之数据处理指令
  9.1.分类：
  数据传送指令
  算术运算指令
  位操作指令
  比较指令
  切记切记：数据处理指令操作的数据仅仅是在CPU核内部玩！
            这些指令不会跟外设(控制器,内存,Nand等)进行交互通信

  9.2.移位操作符
      lsl
      lsr
      ...
  9.3.数据传送指令：mov,mvn
  例如：
        moveqs    r0， r1
        1.先判断上一条指令的运算结果是相等(Z=1)
        2.如果相等,执行movs r0,r1=>r0=r1
        3.根据运算结果r0,影响cpsr的NZCV

        mvn  r0, #0x80
        将0x80取反给r0=>r0 = ~0x80
   注意：数据传送指令的立即数范围一般为0x00~0xff
         例如：
         mov r0, #0 //合法
         mov r0, #0x1ff //编译失败,立即数0x1ff不合法
         注意：如果数据比较大,将来可以利用ldr伪指令进行数据的传送

         例子：
         mov r0, 0xffffffff //不合法
         mvn r0, 0 //r0 = 0xffffffff

  切记切记：指令加s,影响CPSR的两种情形
  1.如果目标寄存器是PC,将来这条指令会做两件事：
    实现跳转
    实现恢复cpsr
    例如：
    movs pc, lr
    此指令做两件事：
    1.pc=lr @实现返回
    2.cpsr=spsr @恢复程序状态

    subs pc, lr, #4
    此指令做两件事：
    1.pc=lr-4 @实现返回
    2.cpsr=spsr @恢复程序状态

  2.目标寄存器不是pc
    subs r0, r1, #4
    此指令做：
    1.r0=r1-4,根据运算结果r0,影响cpsr的NZCV位

10.数据处理指令之算术运算指令
   加法指令：add(不带进位的加法),adc(带进位的加法)
   add r0, r1, r2 @r0 = r1 + r2
   adds pc, r0, #4 @pc=r0+4;cpsr=spsr
   adc r0, r1, r2 @r0=r1+r2+C位(上一条指令的运算结果)

   案例：两个64位数据相加,结果保存在r0,r1
   思路：将两个数的低32位和高32位分别保存在两个寄存器中即可
   数据1：高32    低32
          r0      r1
   数据2：r2      r3
   adds r1,r1,r3
   adc  r0,r0,r2

   减法指令：sub(不带借位的加法),sbc(带借位的加法)
   例子参见ppt

11.数据处理指令之位运算指令
   and:位与
   orr:位或
   eor:异或
   bic:位清除
   例如：
   biceqs r0, r0, #0x7
   1.判断上一条运算结果是否相等
   2.如果相等执行：bics r0, r0, #0x7
   3.将r0的bit[2:0]=000
   4.根据运算结果r0影响cpsr

12.数据处理指令之比较指令(影响cpsr)
   cmp r0, r1 @本质做减法运算r0-r1,根据运算的结果影响cpsr
   cmn r0, r1 @本质做减法运算r0-(-r1),根据运算结果影响cpsr

   tst:位测试指令,本质做位与运算
   例如：tst r0, #0x80 @r0 & 0x80
         测试r0的bit7是否为0,如果为0,Z=1

   teq:位相等测试指令,本质做位异或运算
         teq r0, #0x80 @r0 ^ 0x80
         测试r0的bit7是否为1,如果为1,Z=1

案例：求两个数的最大公约数(例如:20,12)
      提示：
      20    12
            12    8
                  8    4
                       4   4
实施步骤：
1.mkdir /opt/arm/day10/1.0 -p
2.cd /opt/arm/day10/1.0
3.vim gcd.s 添加如下内容
  .text
  .code 32
  .global _start
  _start:
        mov r0, #20
        mov r1, #12

  loop:
        cmp r0, r1
        beq loop_end
        subcs r0, r0, r1
        subcc r1, r1, r0
        b loop

  loop_end:
        b .
  .end

  保存退出
4.arm-linux-as -g -o gcd.o gcd.s
  arm-linux-ld -o gcd gcd.o
5.qemu-arm -g 1234 gcd
  arm-linux-gdb gcd
  target remote localhost:1234
  l
  b 行号
  s
  info reg
  s
  info reg
  s
  info reg
  ...

13.存储加载指令
   13.1.明确数据处理指令仅仅是在ARM核(CPU核)内部玩,无法
        和外设进行数据通信！
        问：ARM核如何通过指令跟外设进行数据通信呢？
            例如:通过指令如何访问GPIOCON,GPIODATA(各种寄存器)
            答：必须利用存储加载指令
        存储加载指令的功能就是为了实现CPU和外设的数据通信！
        “存储指令”：将CPU核寄存器中的数据拷贝到外设中
        "加载指令"：将外设的数据拷贝到CPU核中寄存器中

   13.2.存储加载指令
   ldr:用于加载数据(4字节)
   ldrb:用于加载数据(1字节)
   str:用于存储数据(4字节)
   strb:用于存储数据(1字节)

   例如：CPU读写内存
   mov r1, #0x20008000 @将内存地址0x20008000放到r1
   ldr r0, [r1] @以r1寄存器的值为地址,从这个地址中取出4字节数据加载
                 到r0中(r0=*(unsigned long *)0x20008000)
   str r0, [r1] @将r0中的数据存储到以r0寄存器中的值为地址的内存空间中
                 存储4字节数据(*(unsigned long *)0x20008000 = r0)

   参考代码：
   ldr r0,[r1]
   ldr r0,[r1, #0x8]
   ldr r0,[r1,r2]
   ldr r0,[r1,r2, lsl #2]
   ldr r0,[r1,#0x8]!
       1.r0 = [r1+0x8]
       2.r1 = r1 + 0x8 //更新r1
       类似：
       int *p
       *p++;
   ....
   其余参看PPT

   画出存储加载指令的内存操作示意图！

   案例：用汇编实现字符串的比较函数strcmp
   实施步骤：
   1.mkdir /opt/arm/day10/2.0
   2.cd /opt/arm/day10/2.0
   3.vim strcmp.s 添加如下内容
     .text
     .code 32
     .global my_strcmp
     my_strcmp:
        @获取字符串的首地址
        ldr r0, =str1 @将标签str1对应的地址给r0,也就是将"hello\0"的首地址给r0
        ldr r1, =str2 @将标签str1对应的地址给r1,也就是将"hfllo\0"的首地址给r1

     loop: @循环一个一个字符比较
        ldrb r2,[r0],#1
        ldrb r3,[r1],#1
        cmp r2,#0
        beq cmp_end
        cmp r2, r3
        beq loop

     cmp_end:
        sub r0, r2, r3
        @r0 = 0:str1=str2
        @r0 > 0:str1>str2
        @r0 < 0:str1<str2
        b .

     .end

    @切记：只要是标签,标签就是地址
    str1: @定义字符串标签str1,字符串内容"hello\0",类似char *str1 = "hello\0"
        .ascii "hello\0"

    str2: @定义字符串标签str2,字符串内容"hfllo\0",类似char *str2 = "hfllo\0"
        .ascii "hfllo\0"

    保存代码
    编译
    单步测试

14.ARM指令集之栈操作指令
   14.1.明确：栈的作用用于保存数据
         栈的空间位于外设内存中！
         栈的操作指令将来势必访问外设内存,效率不高的！
         通用的栈操作时压栈和弹栈！
         栈指针用寄存器sp(r13)来保存
   14.2.ARM栈的种类
   减栈：栈指针sp向内存地址减小的方向变化
   加栈：栈指针sp向内存地址增加的方向变化
   满栈：先调整栈指针sp然后再压数
   空栈：先压数然后再调整栈指针sp
   组合得到4四种栈：
   FD:满减栈,只记忆FD即可
   FA:满加栈
   ED:空减栈
   EA:空加栈
   老的栈操作指令：
   stmfd sp!, {r0,r1} @压栈，将寄存器r0,r1的数据压栈处理,存到sp指向的内存空间
   ldmfd sp!, {r0,r1} @弹栈,从sp指向的内存空间恢复数据到r0,r1

   新的栈操作指令：
   push {r0,r1} @压栈
   pop {r0,r1} @弹栈

   注意：寄存器编号大的放在内存的高地址处！

回顾：
面试题：谈谈对ARM的理解
1.ARM概念
2.ARM流水线
3.ARM工作模式
4.ARM工作状态
5.ARM异常,异常向量表
6.ARM异常处理和异常返回
7.ARM寄存器
8.ARM汇编编程框架
9.ARM跳转的方法
10.ARM指令集
   10.1.跳转指令
   10.2.数据处理指令
        传送指令
        算术运算指令
        位操作指令
        比较指令
        仅仅在ARM核内部玩,不能跟外设进行数据通信！
   10.3.指令加s,影响cpsr的两种情形
   10.4.存储加载指令ldr/str
        目的：CPU利用指令能够跟外设进行数据通信
   10.5.栈操作指令压栈(stmfd=push),弹栈(ldmfd=pop)
   10.6.cpsr寄存器操作指令mrs和msr
        例如：
        mrs r0, cpsr @将cpsr寄存器的值给r0
        msr cpsr, r0 @将r0寄存器的值给cpsr
        案例：禁止CPU相应FIQ快速中断
        思路：只要将cpsr的bit[6]置1即可
        编程思路：
        1.先读取cpsr到某个寄存器中,比如r0
        2.修改r0寄存器的值
        3.将修改以后的r0再回写到cpsr

11.ARM伪指令之adr
   明确：CPU是不会直接执行伪指令,需要汇编器经过一个翻译过程
         就是将伪指令翻译成CPU能够执行的真实指令
   adr:小范围的地址加载指令(用来加载地址)
   用法：
   adr r1, Delay @将Delay标签的地址给r1
                  也可以认为将指令mov r0,r14的地址给r1
   mov r0, #0
   mov r2, #1
   mov r3, #2
   Delay:
        mov r0, r14

   切记：cpu是不会直接执行adr,要经过汇编器进行翻译
   例如：			指令地址    真实指令
   ADR    R1, Delay  翻译---->   0x20    add r1, pc, #0x3c   @r1=pc+0x3c=0x20+8+0x3c=0x64
   ...                           ...
   Delay:                        ...
   MOV     R0, R14               0x64    mov r0, r14

   案例：编写汇编代码adr.s,然后反汇编查看反汇编的信息
   实施步骤：
   1.mkdir /opt/arm/day11/1.0 -p
   2.cd /opt/arm/day11/1.0
   3.vim adr.s 添加如下内容
     .text
     .code 32
     .global _start
     _start:
        adr r0, Delay @将Delay的地址给r0
        mov r1, #2
        sub r1, r1, #1
     Delay:
        b  .
     .end
   4.arm-linux-as -g -o adr.o adr.s //此时as汇编器就会翻译adr伪指令
     arm-linux-objdump -D adr.o > adr.dis
   5.vim adr.dis  //进行分析
     00000000 <_start>:
 指令地址 机器码(CPU用)   机器码对应的指令(给人看)
     0:   e28f0004        add     r0, pc, #4 @r0=pc+4=8+4=12=0xc
     4:   e3a01064        mov     r1, #100        ; 0x64
     8:   e2411001        sub     r1, r1, #1
     0000000c <Delay>:
     c:   eafffffe        b       c <Delay> @自己跳到自己的位置,死循环

12.ARM伪指令之ldr
   明确：ldr既可以是真实的指令也可以是伪指令,关键看你怎么用
   例如：
        ldr r0,[r1] @真实的加载指令

   ldr作为伪指令的两种情形：
   情形1：
        mov r0, #0x1ff @编译不通过,0x1ff立即数不合法
        改造：
        ldr r0,=0x1ff @将立即数0x1ff放到r0中
                      @这是伪指令,需要汇编器进行翻译

   情形2：
        指令地址	伪指令
          8058	        ldr r1, =testdata @伪指令,将标签testdata的首地址给r1=8064
          805c          ldr r0, [r1] @将r1的地址内容给r0=0x12345678
          8060          ldr r2, testdata @伪指令,将testdata标签的内容直接给r2=0x12345678
          8064		testdata: @定义标签
                            .word  0x12345678 @分配4字节的内存空间,并且初始化为0x12345678
                                              @类似：int testdata=0x12345678
  案例：编写ldr.s
  .text
  .code 32
  .global _start
  _start:
        @mov r0, #0x1ff 错误
        ldr r0, =0x1ff @伪指令,待会儿查看它的翻译结果
        ldr r1, =testdata @伪指令,待会儿查看它的翻译结果
        ldr r0, [r1] @真实指令
        ldr r2, testdata @伪指令,待会儿查看它的翻译结果
  testdata: @标签
        .world 0x12345678

  .end

12.ARM汇编伪操作
   所有伪操作的说明网站：
   https://sourcware.org/binuntils/docs-2.20/as
   .equ AGE, 20 //类似#define AGE (20)
   .global _start
   .extern add
   .byte
   .word
   .hword
   .asciiz
   .space
   ...
   总结：伪操作具体要参见官方网站

   案例：利用汇编实现每隔一段时间开关灯
   实施步骤：
   1.mkdir /opt/arm/day11/3.0
   2.cd /opt/arm/day11/3.0
   3.vim led.s 添加如下内容
     参考代码从ftp下载
   4.编译
     arm-linux-gcc -nostdlib -c led.s -o led.o
     arm-linux-ld -emain -nostdlib -nostartfiles
        -Ttext=0x20008000 led.o -o led.elf
     arm-linux-objcopy -O binary led.elf led.bin
     cp led.bin /tftpboot
   5.开发测试
     tftp 20008000 led.bin
     go 20008000

13.ARM汇编和C的混合调用
   13.0.明确C的四大存储类型
        auto int a 等价于 int a
        extern
        register int a
        static
   13.1.明确函数调用传递参数的方法
   1.默认采用寄存器传递参数,效率最高
   2.可以采用栈来传递参数,效率相比寄存器要低
     注意：linux内核编程中,一般使用编译器的选项能够强制
           让函数传递参数使用栈来传递,这个选项为：asmlinkage
           asmlinkage int add(int a, int b)
           {
                return a + b;
           }//告诉编译器,此函数传递a,b采用栈,而不是寄存器
    注意：CPU的寄存器资源太有限了！

    切记切记：ARM传递参数,如果使用寄存器传递参数,传递参数的寄存器只能是r0,r1,r2,r3
              函数的返回值通过r0进行返回！

    13.3.问：C如何调用汇编的函数和变量
         问：汇编如何调用C的函数和变量

    13.3.1.C调用汇编的函数和变量
    案例:main.c调用add.s中的函数和变量
    实施步骤：
    1.mkdir /opt/arm/day11/4.0 -p
    2.cd /opt/arm/day11/4.0
    3.vim add.s 添加如下内容：
    .text
    .code 32
    .global add @声明全局标号add,就是做为汇编中的函数
    .global yy  @声明全局标号yy,就是做为汇编中的变量

    @定义汇编函数add
    add:
        add r0, r0, r1 @r0,r1保存传递过来的参数信息,r0 = r0 + r1,返回值保存在r0
        mov pc, lr @C调用汇编函数,最后要添加此句实现返回

    @定义初始化汇编变量yy
    yy:
        .word  0x1234

    .end
    保存退出

  4.vim main.c 添加如下内容
    extern int add(int, int); //声明函数
    extern int yy; //声明变量

    int main(void)
    {
        int ret;
        ret = add(100, 200); //调用add.s中的add函数,传递参数r0=100;r1=200,返回值ret就是r0的值
        ret = yy; //调用add.s中的yy
        return 0;
    }

  5.编译
    arm-linux-gcc -nostdlib -g -c -o main.o main.c
    arm-linux-as -g -o add.o add.s
    arm-linux-ld -nostdlib -nostartfiles -o main
                                main.o add.o -emain
    qemu-arm -g 1234 main
    arm-linux-gdb main
    target remote localhost:1234
    l
    b
    s //下一步,会进入子函数
    info reg //查看r0,r1的值
    p ret //查看ret变量的值
    p /x ret //查看ret变量的值,按照16进制输出

  总结：C调用汇编编程步骤
  1.汇编中的函数和变量必须用.global进行声明
  2.C在调用时,需要用extern进行外部引用声明

  13.3.2.汇编调用C的函数和变量
  案例：
  实施步骤：
  1.mkdir /opt/arm/day11/5.0 -p
  2.cd /opt/arm/day11/5.0
  3.vim add.c
    int g_data = 1000; //定义初始化全局变量
    int add(int a, int b) //定义函数
    {
        return a + b;
    }
  4.vim main.s
    .text
    .code 32
    .global main
    .extern add  @声明函数
    .extern g_data @声明变量

    main:
        mov r0, #100
        mov r1, #200

        bl add @调用add函数,并且传递参数
               @a=100,b=200

       ldr  r2, =g_data @将标签地址给r2
       ldr  r3, [r2] @取内容

       b  .
   .end

  总结：汇编调用C
  1.C的函数和变量必须是全局,不能用static修饰
  2.汇编使用时,用.extern进行声明即可

  大作业：将led.c改造成led.s,实现通过shell命令开关灯

14.回顾ARM异常
   ARM异常处理：
   ARM核硬件完成：
   1.备份cpsr到spsr_mode,spsr_mode=cpsr
   2.设置影响的cpsr的位
     2.1.设置cpsr的mode模式位
     2.2.设置cpsr的T位=0,切换到ARM状态
     2.3.设置cpsr的I,F位=1,禁止IRQ和FIQ
   3.保存返回地址到lr_mode=pc-4(切记此动作硬件完成)
   4.设置PC为相应的异常向量表的入口地址(软件代码就是在这个入口地址存放)
     例如，如果是IRQ异常,PC=0x18,代表CPU到0x18地址去运行

   注意：以上都是硬件自动完成
   5.一旦进入异常向量表的入口地址,至此开启了后序的软件处理过程
     软件如何处理,完全由程序员自行定制！
     当然也不能随随便便写！
   6.一旦异常处理完毕,异常一般都需要进行返回
     返回需要软件来实现：
     1.从spsr_mode恢复cpsr=spsr_mode
     2.从lr_mode恢复pc,让CPU到原先被打断的位置继续接着执行

周末作业：
1.三遍当前笔记
2.研究led.s
3.改造led.c成led.s
4.周末安装linux系统
5.继续复习UC
6.继续做笔试题
7.练练口才

回顾：
面试题：谈谈对ARM理解
1.ARM定义
2.ARM流水线
3.ARM工作模式
4.ARM工作状态
5.ARM寄存器
6.ARM异常
7.ARM指令集
8.ARM混合调用
9.ARM伪指令
  adr/ldr
10.ARM伪操作
  www.google.com
11.ARM异常
   场景       工作模式       异常模式       运行地址
   复位           SVC	      复位           0x00
   未定义指令    undefine     未定义指令     0x04
   程序调svc      SVC	      软中断         0x08
   预取指令出错   abort       预取指令异常   0x0c
   数据处理出错   abort       数据处理异常   0x10
                                             保留
   IRQ	          IRQ          IRQ           0x18
   FIQ		  FIQ          FIQ           0x1c

   ARM异常处理：
   ARM核一旦接收到了异常,ARM核硬件将做：
   1.备份cpsr到spsr
   2.设置cpsr
     mode
     T
     i
     f
   3.lr=pc-4
   4.pc=异常向量表的入口地址
     一旦CPU进入这个入口地址,开启软件处理异常的过程
   5.一旦异常处理完毕,异常返回需要软件做：
     cpsr=spsr
     pc=lr

   明确：1~4都是硬件完成,5需要软件完成
   问：不同的异常返回,软件如何实现呢？
   答：
   1.对于软中断返回处理，例如：
   ...
   sub r1, r1, #5
   svc 0 @汇编代码调用svc指令,触发软中断异常
   add r0, r0, #1
   bic r0, r0, #0xf
   ...
   分析过程：
   1.当svc进行取指，解码，执行的时候,就在执行的时候
     触发了软中断异常
   2.ARM核硬件
     备份spsr_swi=cpsr
     设置cpsr
     lr=pc-4(pc=bic)
       =add
     设置pc=0x08,CPU到0x08地址开启软中断的后序处理
   3.异常处理完毕,返回
     cpsr=spsr
     pc=lr
     切记的代码：movs pc,lr

   2.未定义指令异常,例如：
     ...
     sub r1, r1, #5
     lisi r0, r0, #3 @lisi非法指令
     add r0, r0, #1
     bic r0, r0, #0xf
     ...

     分析过程：
     1. 取指,解码,执行,在lisi指令处于执行阶段,CPU不认识
        发生异常
     2. ARM核硬件
        备份CPSR
        设置CPSR
        lr=pc-4(pc=bic)
          =add
        设置pc=0x04,开启了软件的后序处理过程
     3.异常处理完毕,返回软件做
       movs pc, lr

  3.FIQ/IRQ中断异常,例如：
    ...
    sub r0, r0, #1
    add r1, r1, #2
    bic r0, r0, #0xf
    cmp r0, r0
    ...
    分析过程：
    1.当CPU执行sub指令时,突然CPU接收到了中断信号
      虽然中断来了,sub指令还是要执行完毕,发生中断异常
    2.ARM核硬件
      备份CPSR
      设置CPSR
      lr=pc-4(pc=cmp)
        =bic
      设置pc=0x18/0x1c,开启后序的软件处理
    3.异常处理完毕,返回：
      subs  pc, lr, #4

  3.预取指令异常,例如：
    ...
    sub r0,r0,#1
    add r0,r0,#2
    bic r1,r1,#0xf
    cmp r0, r1
    ...
    1.当sub指令取指,压根就没有取到,但是在执行的时候
      发生异常
    2.ARM核硬件
      备份CPSR
      设置CPSR
      lr=pc-4(pc=bic)
        =add
      pc=0x0c,开启异常的软件处理过程
    3.异常处理完毕,返回：
      subs pc, lr, #4

  4.数据处理异常,例如：
    ...
    ldr r0, [r1] @取指,解码,执行,访存,写回
    sub r0, r0, #5
    add r1, r1, #1
    bic r0, r0, #0xf
    cmp r1, r0
    ...
    分析过程：
    1.当ldr执行在访存阶段发生异常
    2.ARM核硬件
      备份
      设置
      lr=pc-4(pc=bic)
        =add
      pc=0x10,开启异常的软件处理
    3.异常处理完毕,返回：
      subs pc, lr, #8
    总结：ARM官方建议发生数据处理和指令预取如果异常,希望
          重新再来一遍！
    总结：只要记住每个异常返回的代码即可！

12.ARM异常处理之软件处理过程
   12.1.明确异常发生,整个处理过程需要硬件和软件共同来处理
   12.2.硬件做
        1.备份CPSR
        2.设置CPSR
        3.保存返回地址
        4.设置pc为某个异常的处理入口
   12.3.至此开启了软件的异常处理过程
        理论：软件处理异常的过程,由程序员自己来决定！
        通常：软件异常处理遵循原则：
        1.明确软件异常处理之前一定先写好异常向量表的代码
          例如：
          异常处理入口地址        代码(放置一个函数地址)
          0x00          	  reset_function
          0x04			  undefine_function
          0x08                    swi_function
          0x0c			  pre_abort_function
          0x10			  data_abort_function
          0x14			  b .
          0x18			  irq_function
          0x1c			  fiq_function
          一旦将来异常发生,CPU最终执行对应的函数代码
       2.一旦异常发生,CPU进入对应的异常处理入口,将做：
         2.1.保护原先被打断事务的现场(简称保护现场)
             就是将被打断事务的现场(各种寄存器)进行压栈处理
         2.2.就可以踏踏实实的进一步处理异常
             如何处理完全由程序员自行决定,整个处理的过程
             又称异常处理子函数,或者异常处理服务程序,
             又称异常处理服务历程
         2.3.一旦处理完毕,将原先被打断的事务进行恢复现场
             一旦恢复,原先被打算的事务继续执行,进行弹栈处理
         画出异常处理示意图！
切记：异常软件的处理所做的工作：
1.编写好异常向量表的代码
2.编写保护现场的代码
3.编写好异常对应的处理函数
4.编写好恢复现场的代码

14.这里以按键为例,掌握异常处理的软件代码编写过程
   实施步骤：
   1.分析用户需求,以TPAD为例
     10按键,每一个按键不同的需求
   2.掌控硬件特性
     粗看：
          记录每一个按键对应的标签
          暂且记录KEY_UP按键
     细看：打开底板的原理图,根据标签找到KEY_UP的硬件连接位置
           结论：
           1.KEY1_UP采用独立式按键的接法
             独立式按键接法优缺点：
             优点：软件操作简单
             缺点：浪费GPIO资源

             矩阵式按键接法优缺点：
             优点：节省GPIO资源
             缺点：软件操作复杂,需要进行按键扫面判断哪个
                   按键有操作

          2.KEY1_UP最终连接到CPU的XEINT0/GPH0_0(复用)
            既可以作为中断管脚XEINT0
            又可以作为普通的GPIO,GPH0_0
            约定：IRQ=INT=中断
     3.按键的软件处理过程
       3.0.明确中断的概念
           中断属于计算机的一种相当重要的机制,由于外设的
           处理速度远远慢于CPU,为了保证CPU和外设的数据通信
           正常,一般可以采用轮询方式操作外设,但是这种方式
           会大大降低CPU的利用率,可以采用中断方式来跟外设进行
           数据通信,当CPU发现外设数据没有准备就绪,CPU可以干
           其他别的事情,一旦外设准备好数据，会给CPU发送中断
           信号,CPU接收到中断信号以后,CPU停止手头的工作转去
           处理外设,处理完毕以后CPU继续执行原先被打断的事情
           提高了CPU的利用率

       3.1.按键的中断硬件连接图
           画出处理的流程图
           结论：外设产生的中断信号不会直接给CPU,而是要经过
           中断控制器,经过中断控制器的判断,最终由中断控制器
           决定此外设产生的中断信号是否给CPU核发送

       3.2.外设给CPU发送的中断电信号的形式有五种
           高电平触发
           低电平触发
           下降沿触发
           上升沿触发
           双边沿触发
           这些电信号最终同样由中断控制器进行判断；
           例如：咱们前提设置中断控制器只认下降沿触发,
           此时按键松开,硬件上电平是产生上升沿,这个上升沿
           电信号先到达中断控制器,但是中断控制器所示别的
           触发信号跟目前的电信号不一致,此电信号直接由中断
           控制器抛弃，也不会给CPU发送中断信号！

      3.3.按键硬件中断的触发过程：
      1.前提咱们设置中断控制器认为KEY_UP按键的有效中断触发方式
        为下降沿触发
      2.有人按键KEY_UP,硬件上产生一个下降沿电信号
      3.此电信号先跑到中断控制器,中断控制器发现此信号
        为有效的中断信号
      4.中断控制器于是乎再给CPU发送一个中断信号,可以以
        FIQ或者IRQ形式发送
      5.CPU一旦接收到了此中断信号,代表CPU会产生一个
        FIQ或者IRQ异常
      6.CPU开始处理FIQ或者IRQ异常
        6.1.ARM核硬件做
            备份CPSR
            设置CPSR
            保存返回地址
            设置PC=0x1c/0x18
            跳转到异常向量表的入口地址,至此开启了软件的处理流程

      7.软件处理中断的过程
        7.1.明确前提是咱们已经编写好了异常向量表的代码
        7.2.保护现场
        7.3.根据用户需求,进一步完成对中断的处理
            按下按键,点亮LED1
        7.4.处理完毕,恢复到原先被打断的现场继续执行
        会画图
      8.阅读按键中断的参考代码
      切记切记：针对裸板程序,一定要先看链接脚本,通过
                连接脚本确定程序运行的第一个文件和入口
                函数,将来只需要顺藤摸瓜慢慢品味代码即可！
      1.通过uart.lds掌握程序运行的第一个文件vector.s
      2.并且整个程序连接的起始地址为0x20004000
      3.打开vector.s文件,开始顺藤摸瓜
        切记：异常向量表的入口地址默认从0x00开始
              但是软件可以修改异常向量表的入口起始地址，
              比如修改为0x20004000,将来IRQ产生的异常,那么
              CPU自动到0x20004018地址去运行
      4.首先运行程序
        tftp 20004000 shell.bin
        go 20004000
        明确：vector.s中的ldr pc, _reset指令执行
              并且异常向量表已经在内存建立好！

      5.go 20004000时,顺藤摸瓜看ldr pc, _reset
        ldr pc, _reset
            pc=reset(reset.s)
               1.修改异常向量表的入口起始地址为0x20004000
               2.ldr pc, start_armboot
               pc=main(main.c)
                  main ()
                  {
                        xxx_init();//各种初始化
                        其中会初始化中断控制器
                        irq_init();//必须看S5PV210芯片手册的中断控制器的章节
                        while(1) {
                                shell命令
                        }
                  }
     6.至此shell程序运行了,此时有个人要操作按键了
       按键操作之前,一定要先初始化中断控制器
       至少应该设置为将来以FIQ或者IRQ
       至少应该设置为某种电平触发方式

       梳理S5PV210中断控制器的功能：
       0.能够设置外设中断的开关和中断的触发方式
       1.能够设置中断的优先级
       2.能够设置中断的类别：FIQ，IRQ
       3.分4大组,每一组32个
         KEY1_UP用的是VIC0组的第一个EINT0

       总结：main.c调用irq_init初始化好中断控制器以后
       人们就可以操作KEY_UP按键,让CPU相应这个按键的中断

     7.至此shell程序运行了,此时有个人要操作按键了
       硬件下降沿电信号->中断控制器(判断)->IRQ发给CPU
       ->CPU核开启硬件处理
         1.
         2.
         3.
         4.PC=0x20004018,开启软件处理的过程
     8.PC=0x20004018,此内存放的指令：ldr pc, _irq_hdl
       顺藤摸瓜ldr pc, _irq_hdl
                   pc=_irq_handler
                        1.保护现场
                        2.调用C的中断处理函数c_irq_handler
                          从VICADRESS0取出当前中断对应的中断处理函数
                          调用中断处理函数
                          清中断
                        3.恢复现场(又恢复到shell的main函数中)
     友情提示：实际的ARM裸板开发,只需要将按键对应的中断处理函数
     编写好,调用ARM公司开发工具提供的函数将中断处理函数注册
     即可,将来硬件产生中断,CPU自动执行中断处理函数,什么建立
     异常向量表,什么保护现场,什么回复现场,统统由ARM公司的开发工具
     实现好！

     实验步骤：
     make
     cp uart.bin /tftpboot
     tftp 20004000 uart.bin
     go 20004000
     ledon  //开灯
     操作按键


六、嵌入式内核移植---bootloader/kernel/rootfs
        uboot/kernel/rootfs移植的时候，编译出的文件大小
        Phascan    : uboot[192K] uImage[3M] rootfs[308M]
        Phascan-II : uboot[496K] zImage[5M] rootfs[358M]

回顾：
场景：给一块开发板,如何将linux系统运行起来
面试题：谈谈对uboot的理解
实施步骤：
1.配置上位机的开发环境
  装系统：linux
  装软件: vim tftp nfs ctags cscope minicom kermit
  获取交叉编译器:芯片厂家,版本要合适
  配置交叉编译器:PATH

2.部署(烧写,下载)嵌入式linux到下位机
  掌控下位机开发板的基本硬件信息
        三大件：CPU,内存,闪存
        外设：务必弄清楚外设芯片跟CPU之间的通信方式
        明确：下位机必备UART和网口(建议)或者USB口
        注意一个人：硬件工程师

  明确嵌入式linux系统软件组成部分：
  bootloader：
        1.类似BIOS
        2.硬件初始化,将硬件工作状态准备就绪
        3.加载linux操作系统内核到内存,并且启动内核
          通过环境变量bootcmd
        4.给内核传递启动参数,告诉内核rootfs根文件系统
          在哪里(Nand某个分区上或者上位机的某个目录中/opt/rootfs)
          通过环境变量bootargs
        5.uboot属于其中一种

  linux内核：
        1.linux操作系统内核
        2.包含7大功能(7大子系统)
          内存管理
          系统调用
          进程管理
          网络协议栈
          设备驱动
          文件系统
          平台代码
        3.内核最终要挂接rootfs根文件系统
          一旦挂接成功,将来把操作权交给用户(shell)

  rootfs根文件系统:
        1.仅仅是个代名词
        2.本质就是"/"
        3.包含了一堆的目录,一堆的目录中有一堆的各种
          命令,库,配置文件等
          bin:sbin:usr/bin:usr/sbin->各种命令
          lib->库
          etc->tftp,nfs等配置
        4.内核挂接完rootfs以后,要启动第一号用户进程sbin/init

  嵌入式linux系统启动流程：
  上电->bootloader(内存的某个地方运行)->根据bootcmd加载内核
  到内存,启动内核->内核启动->根据bootargs到某个地方去挂接
  rootfs->挂接成功->启动linuxrc->启动/sbin/init(第一号进程)
  ->创建子进程->调用exec函数族某个函数->调用/bin/sh->
  用户就可以输入命令

  画出系统启动示意图！

  两个相当关键重要的启动参数(环境变量)：
  bootcmd:
  bootargs:
  常见实例：
  setenv bootcmd nand read 内存地址 闪存起始地址  大小 \; bootm 内核起始地址
  或者
  setenv bootcmd tftp 内存起始地址 linux内核镜像名 \; bootm 内存起始地址
  研发阶段用第二个,产品发布用第一个

  setenv bootargs root=/dev/闪存分区名 init=/linuxrc console=ttySAC0,115200
  或者：
  setenv bootargs root=/dev/nfs nfsroot=上位机IP:rootfs路径 ip=上位机IP:下位机IP:网关：掩码：:eth0:on ...
  研发阶段用第二个,产品发布用第一个

  嵌入式linux系统烧写：
  1.烧写之前一定要记得进行分区规划！
  2.tftp+nand命令

**********************************************************
3.问：u-boot.bin从何而来？
  答：从uboot而来,肯定有对应的源码呀
  3.1.uboot特点
  1.uboot是一款相当有名的开源软件,由德国denx开源小组负责
    uboot的官方网站：ftp://denx.de
    千万别从这个网站下载源码,然后编译烧写到自己的开发板上
    ,几乎100%不好使！
  2.uboot支持多种处理器架构
    X86,ARM,MIPS,Powerpc,DSP,FPGA
  3.uboot支持多种多样的硬件开发板
    提示：即使CPU一样,有可能外设不一样,u-boot.bin势必也不一样
    全世界没有一个通用的u-boot.bin
  4.uboot引导多种操作系统
    linux,qnx,vxworks等
    主流的嵌入式操作系统：
    linux：
    vxworks:硬实时
    wince

  3.2.获取uboot源码
  1.切记一定要从芯片厂家或者开发板的厂家获取源码
  2.切记芯片厂家的源码仅仅支持芯片厂家提供的参考板
    所以将来自己的开发板如果跟参考板的硬件有不一致的
    地方,需要对芯片厂家的源码进行修改
    案例：TPAD的官方uboot源码：u-boot_CW210_1.3.4.tar.gz(三星)
          三星S5PV210处理器官方参考板名：smdkv210
          TPAD由融汇光泽基于参考板设计,名：cw210
    注意：很多芯片厂家将自家的芯片源码都放置在开源软件托管的地址：
          www.github.com

  3.源码操作
    3.0.windows安装sourceinsight,安装包ftp的SourceInsight35.zip
    3.1.在windows解压缩uboot源码一份,利用sourceinsight创建源码工程
        便于将来阅读源码,提示创建过程：
        Project->New Project->指定工程名称和保存位置->OK->OK->
        将"Show only known ..."前面的勾去掉->点击Add All,
        添加uboot所有的源码->在新的对话框中将两个勾都加上
        ->OK(大概1391个源文件)->点击Close关闭

        Project->Sync....->OK,将源码进行同步,将来便于跳转

        通过点击右键进行跳转
        通过点击<-实现返回
        通过点击"R"实现搜索
    3.2.在linux系统解压缩一份,为了能够编译
        cp  u-boot_CW210_1.3.4.tar.gz /opt/
        cd /opt/
        tar -xvf u-boot_CW210_1.3.4.tar.gz
        mv u-boot_CW210_1.3.4 uboot
        结果：uboot就是源码根目录

    3.3.友情提示,编译源码之前,记得将交叉编译器配置好
        注意交叉编译器的版本要合适

    3.4.开启源码的配置和编译
        注意：uboot源码支持的处理器架构非常多
              并且uboot支持的硬件开发板也非常多
        cd /opt/uboot
        make distclean  //彻底删除之前编译生成的目标文件
                          获取最干净的源码,只做一次！
        make ABC_config  //对源码进行配置,将源码配置成能够
                          运行在某个处理器架构并且能够运行
                          在某个开发板上
        说明：
        ABC:就是当前开发板的名称
            如果是自己设计的开发板,只需要使用官方的参考板名即可
        对于TPAD,配置命令：
        make CW210_config
        结论：当前uboot源码就可以支持ARM架构,并且支持S5PV210处理器,并且支持CW210开发板

        配置完毕,可以踏踏实实进行编译：
        time make
        或者
        time make -j4
        结果：在uboot源码根目录生成最终二进制文件u-boot.bin
        cd /opt/uboot
        ls
          u-boot.bin

   3.5.以上操作步骤仅仅是热身,因为上面编译的u-boot.bin目前
       只能运行在官方的参考板上,但不一定能够运行在你自己设计的
       开发板上,除非硬件一模一样,接下来就要对uboot源码进行
       各种修改。
       实施步骤：
       1.一定要将自己设计的硬件开发板和参考板之间的硬件差异找出来
         友情提示：硬件差异需要咨询硬件工程师
         案例：处理器为I.MX25,参考板A,自己的板子B
         参考板A：
                CPU:I.MX25
                DDR:512MB
                Nand:1GB
                晶振：24MHz
                网卡：CPU自带的MAC
                UART:2
                ...
         自己的板子B：
                CPU:I.MX25
                DDR:1GB
                Nor:1GB
                晶振：24MHz
                网卡：CPU自带的MAC
                UART:0
                ...
         总结：接下来只要对uboot源码修改DDR,Nor,UART相关代码即可

       2.需要有针对性的修改uboot源码
         2.1.明确uboot代码就是一个ARM裸板程序,类似裸板的shell
             仅仅是比咱们的shell代码复杂而已
         2.2.修改之前,掌握uboot代码的执行顺序
             首先查看make编译的打印信息,得到：
             arm-linux-ld -Bstatic -T /opt/uboot/board/CONCENWIT/CW210/u-boot.lds  -Ttext 0xc3e00000 $UNDEF_SYM cpu/s5pv210/start.o \
                        --start-group lib_generic/libgeneric.a cpu/s5pv210/libs5pv210.a
             结论：
             1.首先获取到了连接脚本：/opt/uboot/board/CONCENWIT/CW210/u-boot.lds
             2.并且获取到了将来uboot在内存的运行起始地址0x23e00000
             3.最后通过连接脚本u-boot.lds能够获取到u-boot.bin运行的第一个文件：
               ENTRY(_start) //程序的入口为：_start
               cpu/s5pv210/start.o->start.S //程序运行的第一个文件

             恭喜：重要阶段性成果终于诞生start.S

         2.3.利用sourceinsight慢慢阅读start.S
             b  reset 这个阶段用汇编实现
             reset:
                1.设置CPU的工作模式为SVC
                2.初始化CPU
                  初始化cache
                  关闭看门狗
                  关闭中断
                  初始化内存
                  初始化系统时钟(24MHz(倍频)->1GHz)
                  初始化UART
                  初始化Nand

                3.判断开发板的启动方式
                4.将Nand上的uboot拷贝到DDR上0x23e00000运行
                5.从内存中继续运行uboot

            ldr p, start_armboot 支持进入C实现的启动流程：
            start_armboot {
                ...
                ...
                board_init, //初始化板卡上的外设
                说明：如果将来添加自己的硬件外设的初始化代码
                建议把初始化代码的函数的定义放在board_init所在的
                文件
                ...
                总结：做了大量的各种硬件初始化

                 for (;;) {
                        main_loop () {
                                //如果有环境变量bootcmd
                                //并且如果用户没有按空格键,
                                //最终运行bootcmd对应的命令
                                s = getenv ("bootcmd");
                                //运行命令
                                run_command (s, 0); //run_command("nand erase");

                                //如果bootcmd没有运行
                                //彻底进入shell终端
                                for (;;) {
                                 //获取用户输入的命令
                                 readline (CFG_PROMPT);
                                 //执行对应的命令
                                 run_command (lastcommand, flag);
                                }
                        }
                }
            }

            总结：代码流程：
            1.切记uboot运行的第一个文件start.S
            2.uboot运行的第一个阶段:b reset
            3.uboot运行的第二个阶段：ldr pc, start_armboot

       2.4.切记：实际如果硬件存在差异,修改很少去阅读代码的启动流程
                 去修改代码,一般来说只需要看一个头文件即可搞定！
           此头文件又称硬件平台头文件,此文件定义了大量的跟当前开发板硬件相关的宏
           头文件路径：include/configs/开发板名.h
           总结：一旦找到硬件差异,玩命多多多看对应的硬件平台
                 头文件

       2.6. uboot启动仅仅是系统启动的第一个阶段,一旦uboot将内核
       引导起来,uboot的生命周期就到此为止,所以,uboot做硬件初始化
       但是不要做大量的无关的硬件初始化,只要做了,就势必加长系统的启动时间
       所以,uboot尽量所得事情要简单为主！

       uboot初始化的必要硬件：
       1.CPU
       2.内存
       3.闪存
       4.UART
       5.网卡或USB(也可以不用初始化)

       uboot初始化的可选硬件：
       原则：根据用户需求来定,是否做某个外设的初始化
       案例：手机显示屏上显示logo(提高用户的体验度)
             此时此刻,必须在uboot添加LCD显示屏硬件初始化代码

             无线路由器需要logo显示吗？对于这个产品
             就无需在uboot中添加LCD显示屏的初始化

案例：将uboot命令行提示修改为自己喜欢的提示符
实施步骤：
1.cd /opt/uboot
2.vim include/configs/CW210.h
  修改,保存
3.make //无需再次make CW210_config
4.cp u-boot.bin /tftpboot
5.开发板烧写：
  tftp 50008000 u-boot.bin
  nand erase 0 200000
  nand write 50008000 0 200000
  reset //复位命令


回顾：
面试题：谈谈对uboot的认识
1.uboot特点
2.uboot功能
  uboot生命周期:上电运行,内核启动结束
  uboot运行的时间尽量要快,提高用户的体验度
  硬件初始化
        必要硬件初始化
                CPU初始化
                关闭看门狗
                关闭中断
                初始化系统时钟
                初始化UART
                初始化闪存
                初始化内存
        可选硬件初始化
                一般来说：网卡和USB是需要初始化,便于软件调试
                根据用户的实际需求来定
                手机和路由器是否添加LOGO显示为例
  将内核从"某个地方"加载到内存中,并且启动内核,通过bootcmd
  给内核传递启动参数,告诉内核rootfs在哪里

3.uboot移植操作步骤
  获取源码
  windows解压
  linux解压
  先别尝试修改,先去编译
  make distclean
  make ABC_config
  make
  结果：u-boot.bin,尝试先运行
  找出参考板和自己的板卡之间的硬件差异(硬件工程师)
  例如：
  前提：
        处理器架构：FPGA+ARM核
        厂家：xilinx
        处理器名：zynq720
        参考板名：zed
        自己板卡名：sdr
  硬件差异对比：
  zed板卡：
        zynq720
        DDR 1GB
        SD卡8G
        UART0
        UART时钟频率：33.3MHz
        网卡基地址:0x10000000

  sdr板卡：
       zynq720
       DDR 128MB
       Norflash 256MB
       UART1
       UART时钟频率:40MHz
       网卡基地址:0x30000000
       ...
  一旦掌握硬件差异,接下来只需修改uboot源码即可
  慢慢阅读uboot的启动过程：
  通过编译uboot的打印信息获取到连接脚本和连接地址
  uboot编译连接脚本：u-boot.lds
  运行第一个文件：start.S
  运行第一条指令：b reset //开启汇编
  运行第一条C语言：ldr pc, start_armboot //开启C
  顺藤摸瓜
  真正的修改一般只需要关注头文件：include/configs/ABC.h

3.uboot关键一些命令
  3.1.uboot现有命令的介绍
  查看uboot所有命令：?
  查看命令帮助：help 命令
  常见命令：
  printenv
  setenv
  savenv
  go
  bootm
  tftp
  reset
  nand erase
  nand read
  nand write
  mw:写数据到外设
  md:从外设读取数据

  案例：利用mw,md实现读取Nand ID信息
  读取Nand ID信息时序：参见Nand手册
  uboot操作步骤：
  mw.b 0xB0E00008 0x90
  mw.b 0xB0E0000c 0x00
  md.b 0xB0E00010 1
  md.b 0xB0E00010 1
  md.b 0xB0E00010 1
  md.b 0xB0E00010 1
  md.b 0xB0E00010 1

  案例：利用mw,md实现开关灯和蜂鸣器

 3.2.uboot命令的实现过程
 1.明确uboot命令的源码在uboot的common存在
   一般命名：cmd_xxx.c
 2.注意：如果将来自己添加一个新的命令实现源码在common
   记得要修改common目录下的Makeifle文件添加对新文件的编译支持
 3.uboot命令实现的基本语法：
   第一步：
   vim cmd_nand.c

   U_BOOT_CMD(
        nand,	5,	1,	do_nand,
        "nand    - legacy NAND sub-system\n",
        "info  - show available NAND devices\n"
        "nand device [dev] - show or set current device\n"
        "nand read[.jffs2[s]]  addr off size\n"
        "nand write[.jffs2] addr off size - read/write `size' bytes starting\n"
        "    at offset `off' to/from memory address `addr'\n"
        "nand erase [clean] [off size] - erase `size' bytes from\n"
        "    offset `off' (entire device if not specified)\n"
        "nand bad - show bad blocks\n"
        "nand read.oob addr off size - read out-of-band data\n"
        "nand write.oob addr off size - read out-of-band data\n"
  );
  说明：
  宏U_BOOT_CMD用来定义一个命令对象
  第一个参数：表示命令的名称
  第二个参数：表明命令参数的最大个数
  第三个参数：表示命令是否重复,1:按回车命令重复执行
                               0：按回车命令不会重复执行
  第四个参数：表示命令对应的执行函数
  第五个参数：命令的简要说明
  第六个参数：命令的详细说明,一行不够写,记得续行

  第二步：编写对应的命令执行函数
  返回值为int
  cmdtp,flags:两个形参无需关注！
  argc:命令参数的个数
  argv:命令参数的信息
  int do_nand(cmd_tbl_t * cmdtp, int flag,
                int argc, char *argv[])
  {
        //函数根据传递的参数执行不同的业务
        ...
        return 0; //执行成功
        或者
        return 非0;//执行失败
  }

  第三步：修改Makefile添加新文件的支持

案例：给uboot添加开关灯命令
实施步骤：
1.从ftp://porting下载led开关命令的源码
  led_logo.rar/u-boot-led目录：
                cmd_led.c //命令实现的代码,调用
                led.h //开关灯函数的声明
                led.c //开关灯函数的定义

2.潜心研究以上源码
3.添加命令的编译
  cd /opt/uboot
  cp cmd_led.c /opt/uboot/common
  cp led.h /opt/uboot/common
  cp led.c /opt/uboot/common

4.修改Makefile
  vim /opt/uboot/common/Makefile 添加：
  COBJS-y += cmd_led.o
  COBJS-y += led.o

5.编译
  cd /opt/uboot
  make
  cp u-boot.bin /tftpboot

6.更新uboot
  执行开关灯命令：
  led 1 on
  led 1 off
  led 2 on
  led 2 off

3.logo显示
  1.用途
    提高用户的体验,善意"欺骗"用户
  2.原则
    只要有LCD显示屏,必须添加此功能
    显示时间越早越好,所以在uboot中实现
    logo本质上就是一张图片,但是图片要做小
  3.LCD显示屏显示logo的工作原理

案例：在TPAD的uboot中添加logo显示
      具体操作参见LOGO显示.doc

案例：在TPAD的LCD屏幕的正中央显示一个矩形块

案例：在TPAD的LCD屏幕上画圆

***********************************************************
4.问：zImage从何而来？
  答：通过编译源码获取
  嵌入式linux系统软件之linux内核
  4.1.明确嵌入式linux系统软件组成部分
      bootloader:u-boot属于其中的一种
      linux操作系统内核
      rootfs根文件系统
  4.2.明确嵌入式linux系统启动的顺序
      硬件上电->uboot->根据bootcmd加载内核到内存,启动内核
      ->内核启动->根据uboot传递的bootargs,挂接rootfs
      ->rootfs挂接成功->启动linuxrc->启动第一号进程/sbin/init
      ->创建子进程,利用exec启动shell->用户输入命令交互
  4.3.linux内核特点
      著名的开源软件
      www.kernel.org
      支持多种处理器架构：X86,ARM,MIPS,POWERPC,FPGA,DSP等
      支持多种多样的硬件开发板
      支持TCP/IP网络协议栈
      支持多种多样的文件系统,NTFS,FAT32,EXT4,CRMAFS,YAFFS2,UBIFS等
      支持多种多样的硬件设备驱动
      视频<<the code linux>>
  4.4.linux内核功能
      7大子系统
      linux内核就像一个"管家"
      linux内核就像一个"服务器",应用程序就是客户端
  4.5.获取linux内核源码
      1.切记：linux内核源码的获取一定从芯片厂家或者开发板的
            厂家获取源码,很多芯片厂家将源码放在www.github.com
            进行托管
        TPAD开发板,三星提供的linux内核源代码ftp://porting/kernel.tar.bz2

  4.6.对官方源码进行操作
      1.切记保证交叉编译器的环境变量要设置好
        交叉编译器的版本要合适
      2.在windows下解压缩一份,利用sourceinsight创建
        源码工程,便于将来阅读linux内核源码
      3.在linux系统下解压缩一份,要开始编译
        cp kernel.tar.bz2 /opt/
        cd /opt
        tar -jxvf kernel.tar.bz2
        cd /opt/kernel //进入linux内核源码根目录
        make distclean //获取最干净的内核源码,只做一次
        make ABC_defconfig //配置内核源码,将内核源码配制成
                           能够运行在某个开发板上
        注意：ABC就是开发板的名称,如果是自己的开发板
              ABC采用参考板的名称
        CW210开发板配置命令：
        make cw210_defconfig  //linux内核源码将来就可以
                              运行在ARM架构,S5PV210处理器,CW210开发板上
        make zImage -j4//将内核源码编译成zImage
        成果：
        ls arch/arm/boot/zImage
        友情提示：先尝试在开发板上运行编译的zImage
        cp arch/arm/boot/zImage /tftpboot
        开发板测试,进入uboot命令行执行：
        tftp 50008000 zImage
        bootm 50008000

回顾：
一.嵌入式linux系统软件之linux操作系统内核
1.linux内核特点
2.linux内核功能
  7大子系统
  uboot启动内核开始,掉电结束,运行在内存
3.linux内核源码操作
  3.1.获取官方源码
  3.2.windows创建SI源码工程
  3.3.linux系统中进行配置编译
      1.安装好交叉编译器
        版本要合适
      2.内核源码操作三步曲
        make distclean
        make ABC_defconfig
        make zImage
        成果：arch/arm/boot/zImage
  3.4.到目前为止,zImage肯定能够运行在芯片公司的参考板上,
      但不能保证能够运行在自己的开发板上,此时需要从以下
      两个方面进行突破,具体实施步骤：
      1.明确参考板和自己的开发板之间的硬件差异(硬件工程师)
      2.观察linux内核配置信息,配置信息是否正确
        cd /opt/kernel
        make menuconfig //开始对linux内核进行菜单式的配置
                        //掌握一些关键的配置信息
         System Type  --->
            //当前内核源码能够支持ARM架构,能够支持三星S5PV210处理器
            //如果没有一下信息,一般问题出在没有make CW210_defconfig
            ARM system type (Samsung S5PV210/S5PC110)  --->

            //使用UART0作为调试打印串口,按回车键进入可以进行修改
            (0) S3C UART to use for low-level messages

            //开发板的选择
            Board selection (SMDKV210)  --->

         Boot options  --->
            //明确：内核启动挂接rootfs,使用的启动参数的传参方法有两种：
              方法1：利用uboot传递的bootargs
              方法2：内核自己给自己传递参数,一下这条语句就是
              内核自己传递的参数,按回车键进入进行修改
            (console=ttySAC2,115200) Default kernel command string
            //如果此条目选中,表示内核启动使用自己的参数信息
              如果没有选中此条目,表示内核使用uboot的bootargs
              按Y键进行选中,选中以后[*]
            [ ]Always use the default kernel command string

        Device Drivers  ---> //设备驱动支持
            //Nor和Nand驱动支持
            <*> Memory Technology Device (MTD) support  --->
                  <*>   Mapping drivers for chip access  ---> //Nor
                  <*>   NAND Device Support  --->    //Nand

           //网卡驱动
           [*] Network device support  --->
                [*]   Ethernet (10 or 100Mbit)  --->
                         <*>   DM9000 support

           //input设备驱动：键盘,鼠标,触摸屏,游戏手柄等
           Input device support  --->
                 [*]   Keyboards  --->
                 [*]   Touchscreens  --->

           //字符设备驱动(一大类驱动)
           Character devices  --->

           //I2C总线驱动支持
           <*> I2C support  --->

           //SPI总线驱动支持
           [*] SPI support  --->

           //GPIO操作库函数
           -*- GPIO Support  --->

           //一线式总线驱动
           < > Dallas's 1-wire support  --->

           //看门狗驱动
           [*] Watchdog Timer Support  --->

           //摄像头驱动支持
           <*> Multimedia support  --->

           //LCD显示屏驱动
           Graphics support  --->

           //声卡驱动
           <*> Sound card support  --->

        File systems  --->
             //支持EXT4文件系统格式,兼容ext2,ext3
             <*> The Extended 4 (ext4) filesystem


             [*] Miscellaneous filesystems  --->
                  //支持yaffs2文件系统格式(一般应用于NandFlash)
                  <*>   YAFFS2 file system support

                  //支持jffs2文件系统格式(一般应用于NorFlash)
                  <*>   Journalling Flash File System v2 (JFFS2) support

                  //支持cramfs文件系统格式
                  <*>   Compressed ROM file system support (cramfs)

            //网络文件系统支持
            [*] Network File Systems  --->
                 //如果让内核采用NFS网络服务挂接rootfs,必须必须选中此条目
                 [*] Root file system on NFS

            案例：内核启动利用NFS网络服务挂接rootfs,参数由
                  内核自身传递,不再使用uboot的bootargs
            实施步骤：
            1.cd /opt/kernel
              make menuconfig
                  Boot options  --->
                     (console=ttySAC2,115200) Default kernel command string
                     按回车键进入,修改为如下：
                     root=/dev/nfs nfsroot=192.168.1.8:/opt/rootfs ip=192.168.1.110:192.168.1.8:192.168.1.1:255.255.255.0::eth0:on init=/linuxrc console=ttySAC0,115200
                     保存退出

                     //按Y键选中此条目
                     [*]Always use the default kernel command string

              保存退出,记住按YES
              make zImage //重新编译内核源码
              cp arch/arm/boot/zImage /tftpboot

           2.开发板测试,开发板上执行：
             进入uboot的命令行：
             setenv bootargs  //设置bootargs为空,bootargs没有信息了
             setenv bootcmd tftp 20008000 zImage \; bootm 20008000
             saveenv
             boot //启动系统,就是执行bootcmd的命令
             看内核是否能够启动,正常挂接rootfs

           3.实验做完,最后重新修改为uboot传递参数方式

     3.如果根据硬件差异,将内核配置完毕以后,内核同样不能
       运行在自己的板子上,一定要多多看平台代码文件：
       内核源码:arch/arm/mach-处理器名/mach-开发板名.c
       cw210开发板平台文件：arch/arm/mach-s5pv210/mach-cw210.c
       切记：此平台文件定义了大量的开发板外设的硬件信息,这些硬件
       信息将来都是要给外设对应的设备驱动程序使用！
       将来如果硬件上发生变化,只需关注此文件,修改即可！

     4.如果还是不行,此时此刻要严重怀疑硬件是否有问题
       此时需要硬件工程师协助配合追踪硬件问题！

4.linux内核源码配置菜单的操作
  问题：make menuconfig以后出现的菜单,如何添加一个新的子菜单？
        菜单项如何最终跟对应的源码关联在一起呢
  场景：进入内核源码,执行make menuconfig,按/键搜索LM77关键字
        能够获取到内核支持LM77温度传感器的菜单信息,说明内核
        也就支持对应的硬件驱动,如何找到对应的源码呢？
  1.菜单实现和代码的编译只需要两个关键文件：Kconfig和Makefile
    Kconfig：用来生成一个菜单选项
    Makefile：用来编译源代码

  2.Kconfig的基本语法
    参考代码：
    config  HELLO_WORLD
    TAB键  tristate "hello, world"
    TAB键  help
                "this is my first kernel code"
    说明：
    config关键字用来生成一个新的选项,叫HELLO_WORLD
    tristate关键字具有三种操作状态：不选,*,M
    bool关键字具有两种操作状态：不选和*
    help关键字用来指示选型的说明信息
    "不选"：将来对应的源代码不会被编译
    "*":将对应的源代码和zImage编译在一起
    "M":也会编译对应的源代码,但是不会和zImage编译器在一起
        单独编译
    结论：这个菜单将来生成的最终选项是对应的Makefile文件
          使用,最终的选项名为：CONFIG_HELLO_WORLD,给对应的
          Makefile使用;
          如果不选择,CONFIG_HELLO_WORLD=空
          如果选择为*：CONFIG_HELLO_WORLD=y
          如果选择为M：CONFIG_HELLO_WORLD=m

     Makefile使用生成的CONFIG_HELLO_WORLD的步骤：
     obj-$(CONFIG_HELLO_WORLD) += helloworld.o
     说明：
     根据CONFIG_HELLO_WORLD的值决定helloworld.c代码如何
     编译(不编译,在一起,单独编译)

     一般：
     将源码和zImage编译在一起,又称静态编译
     单独编译源码,又称模块化编译

  案例：将TPAD开发板LED灯的驱动程序静态编译到内核中
  实施步骤：
  1.从ftp下载LED灯的设备驱动程序
    day04/led_drv/
          led_drv.c //LED驱动程序
          led_test.c //LED应用测试程序
  2.拷贝驱动到内核源码中
    cp led_drv.c /opt/kernel/driver/char/
  3.修改Kconfig添加对LED灯菜单的支持
    vim /opt/kernel/drivers/char/Kconfig 添加如下内容：
    config  TARENA_LED
        tristate "tpad led drivers support"
        help
                "this is my first led kernel drivers!"
    保存退出

  4.修改Makeifle添加对LED灯驱动的编译支持
    vim /opt/kernel/drivers/char/Makefile 添加如下内容
    obj-$(CONFIG_TARENA_LED) += led_drv.o
    保存退出

  5.配置内核源码
    cd /opt/kernel
    make menuconfig
        Device Drivers->
                Character devices->
                        //按Y键选为*：和zImage编译在一起
                        <*> "tpad led drivers support"
    保存退出
    make zImage
    cp arch/arm/boot/zImage /tftpboot

  6.测试LED驱动
    进入uboot命令行：
    setenv bootcmd tftp 20008000 zImage \; bootm 20008000
    setenv bootargs root=/dev/nfs nfsroot=192.168.1.8:/opt/rootfs ip=192.168.1.110:192.168.1.8:192.168.1.1:255.255.255.0::eth0:on init=/linuxrc console=ttySAC0,115200
    saveenv
    boot //启动系统
    然后在内核的启动信息中,找到一下语句：
    "this is my first led driver!"
    如果看到以上语句,说明驱动正常安装

  7.交叉编译驱动测试程序
    cp led_test.c /opt/kernel/
    cd /opt/kernel/
    arm-linux-gcc -o led_test led_test.c
    cp led_test /opt/rootfs/

  8.开发板运行测试程序(开发板的linux系统正常运行)
    ./led_test on 1
    ./led_test on 2
    ./led_test off 1
    ./led_test off 2

  9.挂接NFS网络服务的rootfs,超时失败,重启虚拟机NFS网路服务
    sudo /etc/init.d/nfs-kernel-server restart

案例：将TPAD开发板LED灯的驱动程序采用模块化编译
实施步骤：
1.配置内核源码,将LED驱动对应的菜单选择为M
  cd /opt/kernel
  make menuconfig
      Device Drivers->
                Character devices->
                        //按M键选为M：模块化编译驱动
                        <M> "tpad led drivers support"
  保存退出

2.单独编译内核源码和LED驱动
  cd /opt/kernel

  make zImage //单独编译内核
  cp arch/arm/boot/zImage /tftpboot

  make modules //单独编译LED驱动
  成果：
  ls drivers/char/led_drv.ko //将led_drv.c单独编译成对应的二进制文件led_drv.ko

  cp led_drv.ko /opt/rootfs/

3.安装LED驱动到内核,开发板执行(前提是内核已经挂接NFS的rootfs)：
  cd /
  ls
      led_drv.ko  //LED驱动的二进制文件
      led_test    //LED驱动的测试程序

  insmod led_drv.ko //安装驱动到内核中,insmod = insert module
  ./led_test on 1
  ./led_test on 2
  ./led_test off 1
  ./led_test off 2

  rmmod led_drv //从内核中卸载LED驱动

**********************************************************
3.问：rootfs根文件系统从何而来?
  嵌入式linux系统软件之rootfs根文件系统
  1.rootfs根文件系统概念
    根文件系统仅仅是一个代名词
    不代表任何一种文件系统格式,比如NTFS,FAT32等
    linux系统的"/"里面的内容组合在一起形成rootfs根文件系统

  2.rootfs根文件系统包含哪些内容
    cd /
    ls //查看根文件系统包含的内容
    rootfs根文件系统包含了一大堆的用户命令,一大堆的静态库,
    动态库,一大堆的配置文件和服务

    rootfs根文件系统的内容有些必须存在,有些可以不需要：
    必须的目录：
    bin:命令
    sbin:命令
    lib:库
    etc:配置服务
    proc:虚拟文件系统入口,驱动相关
    sys:虚拟文件系统入口,驱动相关
    dev:设备文件,驱动相关
    usr:命令

    可选目录：
    home:普通用户主目录
    mnt:挂接点
    var:临时目录
    root:root用户主目录
    opt:临时目录
    ...
    zhangsan:

  3.rootfs根文件系统如何制作呢？
    答：利用大名鼎鼎的开源软件busybox
    问：为什么不用芯片厂家提供的rootfs呢？
    答：一般不建议使用芯片厂家的rootfs,因为芯片厂家的
        rootfs功能相当之强大,带来的结果是rootfs的体积
        相当臃肿,会大量的占用的闪存空间,有些功能还用不着
        建议自己制作rootfs!

  4.busybox特点
    著名的开源软件
    小名：瑞士军刀
    www.busybox.net
    切记：busybox仅仅给你提供各种命令！什么动态库,什么配置服务
    等这些都需要自己额外的添加！

  5.busybox操作
    0.从ftp下载busybox源码:busybox-1.21.1.tar.bz2
    1.配置好交叉编译器
      注意版本要合适
    2.在windows下解压缩,创建源码工程
      编译将来阅读源码
    3.在linux系统解压缩,进行配置编译
      cp busybox-1.21.1.tar.bz2 /opt/
      cd /opt/
      tar -xvf busybox-1.21.1.tar.bz2
      mv bubusybox-1.21.1 busybox
      cd busybox //进入busybox源码根目录
      修改Makefile文件：
      vim Makefile +189
      将ARCH修改为：ARCH=arm  //指定将来运行的架构为ARM

      vim Makefile +163
      将CROSS_COMPILE修改为：CROSS_COMPILE=arm-linux-  //指定的交叉编译器

      保存退出
      make //编译
      make install //安装编译的成果
      将编译生成的各种命令的二进制文件统一放在busybox源码下的_install目录中
      ls _install //查看编译成果
        bin   sbin  usr  linuxrc
        说明：busybox仅仅是给你提供命令而已

回顾：
1.嵌入式linux系统软件之linux内核
  linux内核特点
  linux内核功能
  linux内核生命周期
  linux内核源码操作
  获取源码
  创建源码阅读工程
  交叉编译器的环境配置
  配置编译
  make distclean
  make ABC_defconfig
  make zImage
  arch/arm/boot/zImage
  尝试先运行
  检查内核的配置信息
  make menuconfig
        System Type->
        Boot options->
        Device Drivers->
        File system->
  仔细阅读平台文件：arch/arm/mach-处理器名/mach-开发板名.c
  注意：此文件定义的大量硬件信息将来给设备驱动使用
  还要确保硬件正常
  向内核添加一个内核代码的过程：Kconfig和Makefile

2.嵌入式linux系统软件之rootfs根文件系统
  2.1.rootfs根文件系统概念
  仅仅是一个代名词而已
  不是具体某种文件系统格式
  本质就是"/"

  2.2.rootfs包含的内容
  cd /
  ls //看到的东西就是rootfs的内容
  就是包含了一大堆的命令,一大堆的库,一大堆的配置服务等

  必要的目录：
  bin
  sbin
  usr
  proc
  sys
  etc
  lib
  dev

  可选的目录：
  home
  tmp
  var
  mnt
  ...

  2.3.制作rootfs根文件系统只需busybox
  2.4.busybox特点
      开源软件
      www.busybox.net
      瑞士军刀
      切记：busybox开源软件仅仅获取命令而已(ls,cd等)！
            置于其他的动态库,配置文件等需要自己额外的添加

3.busybox源码操作
  注意：配置好交叉编译器,版本要合适
  具体的实施步骤：
  1.下载busybox源码
  2.windows解压缩一份,创建SI工程,便于将来看源码
    完好UC编程,看busybox源码即可！
    例如：第一号进程/sbin/init->源码init/init.c
  3.linux交叉编译过程
    3.1.源码解压缩
    cp busybox-1.21.1.tar.bz2 /opt/
    cd /opt/
    tar -xvf  busybox-1.21.1.tar.bz2
    mv busybox-1.21.1 busybox
    cd busybox  //进入busybox源码根目录

    3.2.修改Makefile,指定交叉编译器
    cd /opt/busybox
    vim Makefile +189
    将ARCH修改:ARCH=arm

    vim Makefile +163
    将CROSS_COMPILE修改为：CROSS_COMPILE=arm-linux-
    保存退出

    3.3.注意：busybox也可以进行make menuconfig菜单式配置
        可以将有些命令支持或者不支持
        注意：buysbox去除一些关键的命令
        cd /opt/busybox
        make menuconfig
            //支持驱动安装和卸载命令
            Linux Module Utilities  --->
                  [*] Simplified modutils //去除精简的命令,此时会出现完整的驱动操作命令
                 //以下全部选中,这些都是完整的驱动操作命令
                  [*]   insmod
                  [*]   rmmod
                  [*]   lsmod
                  [*]   Pretty output
                  [*]   modprobe
                  [*]   Blacklist support
                  [*]   depmod

            Miscellaneous Utilities  --->
                  //去除nand写和读命令
                  [ ] nandwrite
                  [ ] nanddump
          保存退出

     3.4.交叉编译和安装busybox
         cd /opt/kernel
         make
         make install //安装,默认安装到当前目录下的_install目录中
         cd _install
         ls
           bin sbin usr linuxrc
         重要结论：生成的各种命令都是软连接文件,最终都连接到
         bin/busybox,所以说编译busybox源码最终生成的二进制
         文件只有一个：bin/busybox

    3.5.创建必要目录和可选目录
        cd /opt/busybox/_install
        mkdir  lib etc dev proc sys  //必要目录
        mkdir home var tmp mnt //可选目录

    3.6.添加应用程序(bin/busybox)所需的动态库
        添加原则：应用程序需要哪些动态库就添加对应的动态库即可
        明确：动态库在交叉编译器中
              动态库命名：lib名.so...
        明确：将来找到的动态库要放在rootfs的lib目录下
        明确：获取应用程序所需动态库的方法：
        cd /opt/busybox/_install
        arm-linux-readelf -a bin/busybox | grep "Shared"
        得到：
         0x00000001 (NEEDED)  Shared library: [libm.so.6]
         0x00000001 (NEEDED)  Shared library: [libc.so.6]
        结论：busybox可执行程序所需两个库：libm.so.6和libc.so.6

        进入交叉编译器中,找所需的动态库,并且拷贝：
        cd /home/tarena/workdir/toolchains/opt/S5PV210-crosstools/4.4.6
        find . -name libm.so.6
        得到：
        ./arm-concenwit-linux-gnueabi/concenwit/usr/lib/libm.so.6
        ls ./arm-concenwit-linux-gnueabi/concenwit/usr/lib/libm.so.6 -lh
        得到：
        libm.so.6也是软连接文件,所以还需要拷贝它的实体文件
        拷贝：
        cp arm-concenwit-linux-gnueabi/concenwit/usr/lib/libm-2.10.1.so /opt/busybox/_install/lib/ -d
        cp arm-concenwit-linux-gnueabi/concenwit/usr/lib/libm.so.6 /opt/busybox/_install/lib/ -d

        同理拷贝libc库：
        find . -name libc.so.6
        ./arm-concenwit-linux-gnueabi/concenwit/usr/lib/libc.so.6
        ls ./arm-concenwit-linux-gnueabi/concenwit/usr/lib/libc.so.6 -lh
        得到：
        libc.so.6也是软连接文件,所以还需要拷贝它的实体文件
        拷贝：
        cp arm-concenwit-linux-gnueabi/concenwit/usr/lib/libc-2.10.1.so /opt/busybox/_install/lib/ -d
        cp arm-concenwit-linux-gnueabi/concenwit/usr/lib/libc.so.6 /opt/busybox/_install/lib/ -d

        关键最后：拷贝动态链接库(加载器)到lib
        提示：加载器的命名：ld-...
        cp arm-concenwit-linux-gnueabi/concenwit/usr/lib/ld-* /opt/busybox/_install/lib/ -d

        总结：将来拷贝动态库,首先获取应用程序所需的动态库有
        哪些,然后到交叉编译器中进行拷贝,拷贝时,不要光拷贝连接文件
        还要把对应的实体文件进行拷贝！

     3.7.添加系统启动的必要配置文件和启动脚本文件
     明确：配置文件和脚本文件一般放置在etc目录
     明确：两个配置文件inittab,fstab
           一个脚本文件rcS
     1.添加inittab文件
       cd /opt/busybox/_install
       vim etc/inittab 添加如下内容：
       ::sysinit:/etc/init.d/rcS
       ::respawn:-/bin/sh
       ::ctrlaltdel:/sbin/reboot
       ::shutdown:/bin/umount -a –r
       说明inittab文件格式：
       id:runlevel:action:process
       注意：嵌入式linux来说,一般id,runlevel给空即可
       action关键字：sysinit,askfirst,respawn
       sysinit:此action表示第一号进程/sbin/init启动以后
               会创建一个子进程,子进程会执行sysinit对应的
               process信息(/etc/init.d/rcS,脚本),父进程
               等待子进程的结束

       askfirst和respawn是一样的:当sysinit对应的process进程
       执行完毕,父进程init继续执行,会再次创建一个子进程
       执行askfirst或者respawn对应的process信息(/bin/sh)
       至此就启动了一个shell,可以跟用户进行交互；
       前者askfirst在执行/bin/sh之前需要用户按回车键
       后者respawn无需用户按回车键,直接去执行/bin/sh
       所以建议：采用respawn

     总结：细分嵌入式linux系统启动流程：
     上电->uboot->根据bootcmd加载启动内核->根据bootargs挂接
     rootfs->挂接成功->启动linuxrc进程->启动/sbin/init->
     init解析inittab文件->init进程首先找sysinit信息->
     找到以后创建子进程,执行/etc/init.d/rcS脚本->
     rcS执行完毕->init继续往下执行->init继续找askfirt或者
     respawn->执行对应的/bin/sh->至此启动了shell->可以跟
     用户进行交互

    2.添加启动脚本文件etc/init.d/rcS
      cd /opt/busybox/_install
      mkdir etc/init.d
      vim etc/init.d/rcS 添加如下内容：
      #!/bin/sh
      /bin/mount -a
      mkdir /dev/pts
      mount -t devpts devpts /dev/pts
      echo /sbin/mdev > /proc/sys/kernel/hotplug
      mdev -s
      保存退出
      chmod 777 etc/init.d/rcS

      说明：
      /bin/mount -a:将来系统会自己解析并且执行etc/fstab

      mkdir /dev/pts
      mount -t devpts devpts /dev/pts
      以上两句话用户远程登录服务,例如telnet

      echo /sbin/mdev > /proc/sys/kernel/hotplug
      mdev -s
      以上两句话跟驱动创建设备文件相关

    3.添加文件系统挂接配置文件etc/fstab
      切记：etc/fstab文件必须由rcS脚本中的mount -a命令执行

      cd /opt/busybox/_install
      vim etc/fstab 添加如下内容
      proc           /proc        proc   defaults        0     0
      tmpfs          /tmp         tmpfs  defaults        0     0
      sysfs          /sys         sysfs  defaults        0     0
      tmpfs          /dev         tmpfs  defaults        0     0
      保存退出
      说明：
      将proc目录,tmp目录,sys目录,dev目录分别挂接成
      procfs,sysfs,tmpfs虚拟文件系统,也代表着将来
      proc目录,tmp目录,sys目录,dev目录下的内容都是
      由内核自动创建,这三种虚拟文件系统的内容都是存在于
      内存,掉电丢失！

    3.8.至此咱们的最小根文件系统制作完毕,利用NFS进行测试
    mv /opt/rootfs /opt/rootfs_bak  //备份原先的根文件系统
    cp /opt/busybox/_install /opt/rootfs -frd
    du /opt/rootfs -lh //目前来说大小为3.2M
    重启开发板,进入uboot,执行：
    setenv bootargs root=/dev/nfs nfsroot=...
    saveenv
    boot //启动,看是否能够挂接咱们自己的rootfs
    linux系统启动完毕,执行：
    cat /proc/cmdline //查看内核的启动参数

    3.9.利用NFS网络进行应用程序的测试
    虚拟机执行：
    cd /opt/rootfs/
    vim helloworld.c
    arm-linux-gcc -o helloworld helloworld.c

    开发板测试：
    ./helloworld

    3.10.如何实现应用程序的自启动呢？
    虚拟机执行：
    cd /opt/rootfs
    vim etc/init.d/rcS 在文件最后添加：
    cd /
    ./helloworld & //让应用程序helloworld后台运行,便于后序咱们继续能够输入命令
    保存退出
    重启开发板
    观察应用程序是否启动：
    ps

4.问：rootfs.cramfs,android_rootfs.bin从何而来？
  部署(烧写)rootfs到开发板上Nand
  实施步骤：
  1.明确：rootfs目前还是一个目录
  2.明确：要烧写rootfs到Nand,首先必须将rootfs目录制作成
          单个镜像文件(比作压缩包)
  3.明确：在操作系统下访问文件,文件所在分区必须要格式化成
          某种文件系统格式,类似安装windows到C盘,首先会提示
          你将C盘格式化成NTFS或者FAT32文件系统格式
  4.常见的嵌入式linux闪存使用的文件系统格式：
    cramfs文件系统格式：只读压缩
    yaffs2文件系统格式：针对NandFlash,非压缩,可读写
    jffs2文件系统格式：针对NorFlash,非压缩,可读写
    ubifs文件系统格式：针对NandFlash,卷,非压缩,可读写
    ramdisk文件系统格式：存在内存中,效率最高,占用内存空间
    initramfs文件系统格式：本质就是zImage+ramdisk

  5.案例：将rootfs制作成cramfs文件系统格式的镜像文件
  实施步骤：
  1.配置linux内核支持cramfs文件系统格式
    cd /opt/kernel
    make menuconfig
        File systems  --->
           [*] Miscellaneous filesystems  --->
                //按Y选择为*支持cramfs文件系统格式
                  < >   Compressed ROM file system support (cramfs)
    保存退出
    make zImage
    cp arch/arm/boot/zImage /tftpboot

  2. 切记：烧写之前一定要记得对闪存进行分区规划
  0------2M--------7M---------17M---------剩余
   uboot    zImage    rootfs      userdata
  mtdblock0 mtdblock1 mtdblock2  mtdblock3

  3.修改内核的NandFlash驱动中的分区表
    cd /opt/kernel
    vim drivers/mtd/nand/s3c_nand.c +40 将内核现在的Nand
    分区表修改为如下形式：
    struct mtd_partition s3c_partition_info[] = {
         //描述第一分区的信息
         {
            .name           = "uboot",//分区名
            .offset         = (0), //分区起始地址
            .size           = (2*SZ_1M),//分区大小
         },
         //描述第二分区的信息
         {
            .name           = "zImage",
            .offset         = MTDPART_OFS_APPEND,//追加
            .size           = (SZ_1M*5),
         },
         //描述第三分区的信息
         {
            .name           = "rootfs",
            .offset         = MTDPART_OFS_APPEND,
            .size           = (10*SZ_1M),
         },
         //描述第四分区的信息
         {
            .name           = "userdata",
            .offset         = MTDPART_OFS_APPEND,
            .size           = MTDPART_SIZ_FULL,//剩余
         },

    };
    保存退出
    make zImage
    cp arch/arm/boot/zImage /tftpboot

  4.将rootfs制作成单个镜像文件rootfs.cramfs
    只需要工具：mkfs.cramfs
    cd /opt/
    mkfs.cramfs rootfs rootfs.cramfs
    cp rootfs.cramfs /tftpboot

  5.开发板烧写
    重启开发板,进入uboot：
    tftp 50008000 rootfs.cramfs
    nand erase 700000 a00000
    nand write 50008000 700000 a00000
    setenv bootargs root=/dev/mtdblock2 init=/linxurc console=ttySAC0,115200 rootfstype=cramfs
    说明：告诉内核,rootfs在Nand的第三分区上
    saveenv
    boot //启动linux系统
    启动以后,验证：
    cat /proc/cmdline //查看内核启动参数,确保是从Nand启动
    mkdir helloworld //失败,cramfs文件系统格式是只读的
    ps //查看自启动的应用程序的pid
    kill 程序的pid

6.案例：将rootfs制作成yaffs2文件系统格式的镜像文件
  实施步骤：
  1.配置linux内核支持yaffs2文件系统格式
    cd /opt/kernel
    make menuconfig
        File systems  --->
           [*] Miscellaneous filesystems  --->
                //按Y选择为*支持yaffs2文件系统格式
                  <*>   YAFFS2 file system support
    保存退出
    make zImage
    cp arch/arm/boot/zImage /tftpboot

  2. 切记：烧写之前一定要记得对闪存进行分区规划
  0------2M--------7M---------17M---------剩余
   uboot    zImage    rootfs      userdata
  mtdblock0 mtdblock1 mtdblock2  mtdblock3

  3.分区表已经修改过

  4.将rootfs制作成单个镜像文件rootfs.yaffs2
    只需要工具：mkyaffs2image
    从ftp下载工具mkyaffs2image
    sudo cp mkyaffs2image /sbin/ //将工具拷贝到linux虚拟机中
    sudo chmod 777 /sbin/mkyaffs2image
    cd /opt/
    mkyaffs2image rootfs rootfs.yaffs2
    cp rootfs.yaffs2 /tftpboot

  5.开发板烧写
    重启开发板,进入uboot：
    tftp 50008000 rootfs.yaffs2
    nand erase 700000 a00000
    nand write.yaffs 50008000 700000 $filesize
    或者
    nand write.yaffs 50008000 700000 $(filesize)
    setenv bootargs root=/dev/mtdblock2 init=/linxurc console=ttySAC0,115200 rootfstype=yaffs2
    说明：告诉内核,rootfs在Nand的第三分区上
    saveenv
    boot //启动linux系统
    启动以后,验证：
    cat /proc/cmdline //查看内核启动参数,确保是从Nand启动
    mkdir zhangsan //成功
    ps //查看自启动的应用程序的pid
    kill 程序的pid

面试题：谈谈对嵌入式linux系统软件的认识
面试题：谈谈对嵌入式linux系统启动流程的认识


七、驱动的相关的知识

回顾：
1.linux内核platform机制
  目的：将硬件和软件分离
  一个虚拟总线：platform_bus_type
  两个链表：dev链表(硬件)和drv链表(软件)
  两个数据结构：
        struct platform_device
                .name
                .id
                .resource
                .num_resources
                .dev
                        .release
        struct platform_driver
                .driver
                        .name
                .probe
                        1.获取硬件信息
                                platform_get_resource
                        2.处理硬件信息
                          4个该
                        3.注册硬件操作接口
                .remove
                        对着干
   四个配套函数
   platform_device_register
   platform_device_unregister
   platform_driver_register
   platform_driver_unregister
   四个什么都是由内核来完成

   一个关心：probe函数是否被调用

2.I2C总线
  面试题：谈谈对I2C总线的理解
  2.1.I2C总线功能
  2.2.I2C概念
  2.3.三个问题
  2.4.协议设计概念
      START
      STOP
      设备地址
      读写位
      ACK
  2.5.访问过程
      举例子：以CPU向AT24C02片内地址0x10存储空间写入字符'A'为例
      结论：一切的操作都是在芯片手册的操作时序图中
  2.6.配合
      画出时序图
      START 设备地址=0x50 W ACK

3.linux内核I2C驱动开发
  3.1.明确I2C总线实际的硬件操作
  研究对象转移：
  CPU访问外设
  转移到CPU访问SDA和SCL
  转移到CPU访问I2C控制器
  转移到CPU访问I2C控制器对应的寄存器

  3.2.linux内核I2C驱动的分类
  I2C总线驱动：
        管理的硬件是I2C控制器
        此驱动操作I2C控制器最终帮你发起SCL和SDA的时序
        注意：像START,ACK,读写位,STOP这些都是标准信号,I2C控制器
              自动完成,但是设备地址,操作的芯片的片内地址和片内数据
              控制器是不知道的,这些由I2C设备驱动来告诉
              I2C总线驱动
        总线驱动由CPU芯片厂家实现好,只需配置内核支持即可：
        cd /opt/kernel
        make menuconfig
          Device Drivers->
                I2C supports->
                        i2c hardware bus supports...-> //在此
                                <*> s3c2410 i2c ...
  I2C设备驱动：
        管理的硬件是I2C外设本身
        像设备地址,片内地址,片内数据都是跟
        外设相关,I2C设备驱动需要将这些数据
        信息丢给I2C总线驱动,最终完成硬件SCL
        和SDA的时序传输
        I2C驱动开发的重点！

  问：以上两个驱动如何关联呢？

  3.3.linux内核I2C驱动框架(分层思想)
  例如：以CPU向AT24C02片内地址0x10存储空间写入数据'A'为例：

  应用层：
        作用：就是要获取到底层硬件将来要操作的数据信息(片内地址和片内数据)
        struct at24c02_info {
                unsigned char addr;
                unsigned char data;
        };
        struct at24c02_info at24c02;
        at24c02.addr = 0x10;
        at24c02.data = 'A';
        //将应用层的数据丢给I2C设备驱动
        ioctl(fd, AT24C02_WRITE, &at24c02);
 ----------------------------------------------------------
 I2C设备驱动层：
         从用户获取要操作的数据信息或者将数据信息丢给用户
         同时还要将数据信息利用SMBUS接口丢给I2C总线驱动
         或者利用SMBUS接口从I2C总线驱动获取数据
         at24c02_ioctl(file, cmd, arg) {
            struct at24c02_info at24c02;
            copy_from_user
                结果：
                at24c02.addr = 0x10
                at24c02.data = 'A'
            switch ....
                case AT24C02_WRITE: //写
                     I2C设备驱动利用内核提供的SMBUS接口函数
                     将这些数据信息丢给I2C总线驱动：
                     smbus_xxxx(数据信息);
                break

         }
----------------------------------------------------------
SMBUS接口层：
        连接I2C设备驱动和I2C总线驱动
        桥梁作用
        内核已经实现！
        smbus_xxx
        0x10
        'A'
----------------------------------------------------------
I2C总线驱动层：
        唯一的作用就是操作I2C控制器,启动硬件的最终传输
        设备地址同样由I2C设备驱动来告诉
        当然传输的数据信息来自用户0x10,'A'
----------------------------------------------------------
硬件层：
        START->设备地址|0->ACK->0x10->ACK->'A'->ACK->STOP

问：linux内核I2C设备驱动如何编写呢？
答：同样采用分离思想(bus-device-drivers编程模型)
1.首先内核已经定义好了一个虚拟总线叫i2c_bus_type
  在这个总线上维护着两个链表dev链表和drv链表
2.dev链表上每一个节点描述的I2C外设的硬件信息,对应的
  数据结构为struct i2c_client, 每当添加一个I2C外设的硬件信息时,
  只需利用此数据结构定义初始化一个对象,添加到dev链表以后
  内核会帮你遍历drv链表,取出drv链表上每一个软件软件跟这个
  硬件节点进行匹配(匹配通过内核调用总线提供的match函数,比较
  i2c_client的name和i2c_driver的id_table的name)如果匹配成功
  内核调用软件节点的probe函数,并且把匹配成功的硬件节点的
  首地址给probe函数
3.drv链表上每一个节点描述的I2C外设的软件信息,对应的
  数据结构为struct i2c_driver, 每当添加一个I2C外设的软件信息时,
  只需利用此数据结构定义初始化一个对象,添加到drv链表以后
  内核会帮你遍历dev链表,取出dev链表上每一个硬件节点跟这个
  软件节点进行匹配(匹配通过内核调用总线提供的match函数,比较
  i2c_client的name和i2c_driver的id_table的name)如果匹配成功
  内核调用软件节点的probe函数,并且把匹配成功的硬件节点的
  首地址给probe函数

总结：如果要实现一个I2C外设的I2C设备驱动只需关注两个数据结构：
struct i2c_client
struct i2c_driver

3.4.struct i2c_client
    struct i2c_client {
        unsigned short addr;//设备地址,将来寻找外设
        char name[I2C_NAME_SIZE];//将来用于匹配
        int irq; //中断号
        ...
    };
    功能：描述I2C外设的硬件信息
    切记：addr,name两个成员必须要进行初始化！
    结论：驱动开发者不会自己去拿这个结构体去定义初始化和注册
          一个硬件节点对象到内核,而是利用以下结构体间接完成
          以上操作(用i2c_client定义初始化注册对象)

    神秘的数据机构：
    struct i2c_board_info {
        char type[I2C_NAME_SIZE];
        unsigned short	addr;
        int irq;
        ...
    };
    功能：将来驱动开发者用此数据结构去定义初始化注册
          一个I2C外设的硬件信息到内核,将来内核会根据
          你提供的硬件信息,内核会帮你定义初始化和注册
          一个i2c_client硬件节点对象到内核dev链表中
    成员：
    type:硬件信息的名称,将来这个字段的内容会赋值给
         i2c_client的name成员,用于匹配
    addr:I2C外设的设备地址,将来这个字段的内容会赋值给
         i2c_client的addr成员,用于找某个外设
    irq:I2C外设的中断号,将来这个字段的内容会赋值给
         i2c_client的irq成员
    切记：type,addr必须要初始化！
    内核鼓励使用I2C_BOARD_INFO宏对type,addr进行初始化！
    例如：I2C_BOARD_INFO("at24c02", 0x50)

    配套函数：
    注册i2c_board_info描述的硬件信息到内核的函数：
    int i2c_register_board_info(int busnum,
                        const struct i2c_board_info *info,
                                int number)
    功能:i2c_board_info描述的硬件信息到内核
    参数：
    busnum:I2C外设所在的I2C总线编号(从0开始),通过原理图来获取
    info:传递定义初始化的I2C外设的硬件信息对象首地址
    number:硬件信息的个数
    结果：将来内核根据你注册的硬件信息,内核会帮你定义初始化
    和注册一个i2c_client对象到内核中
    切记切记：i2c_board_info定义初始化和注册不能采用insmod
              和rmmod,此代码必须放在平台代码中完成！
    TPAD的平台代码：arch/arm/mach-s5pv210/mach-cw210.c

    案例：向内核添加AT24C02的硬件节点到内核
    实施步骤：
    1.cd /opt/kernel
    2.vim arch/arm/mach-s5pv210/mach-cw210.c 在头文件的后面添加如下内容：
      //定义初始化AT24C02的硬件信息
      static struct i2c_board_info at24c02[] = {
          {
                I2C_BOARD_INFO("at24c02", 0x50)
          }
      };//"at24c02"将来用于匹配,0x50表示设备地址,用于寻找外设

   3.vim arch/arm/mach-s5pv210/mach-cw210.c 在任何一个函数中调用
     一下函数完成对I2C外设硬件信息的注册,推荐找到：
     .init_machine	= smdkc110_machine_init,
     找到smdkc110_machine_init,在此函数中调用：
     i2c_register_board_info(0, at24c02, ARRAY_SIZE(at24c02));
     保存退出
   4.make zImage
     cp arch/arm/boot/zImage /tftpboot
   5.用新内核重启开发板
     至此内核就有了AT24C02的硬件信息,内核也帮你定义初始化
     注册一个i2c_client,此时此刻它会静静等待着软件节点的到来！

3.5.struct i2c_driver
    struct i2c_driver {
        int (*probe)(struct i2c_client *client,
                        const struct i2c_device_id *id);
        int (*remove)(struct i2c_client *client);
        const struct i2c_device_id *id_table;
        ...
    };
    作用：描述I2C外设的软件信息
    id_table:I2C外设的标识,其中的name用于匹配
        struct i2c_device_id {
                char name[I2C_NAME_SIZE];//用于匹配
                unsigned long data; //给probe函数传递的参数
        };
        例如：
        static const struct i2c_device_id at24_id[] = {
                { "at24c02", 0 },
                { }
        };//"at24c02"将来用于匹配

    probe:匹配成功,内核调用此函数
          形参client指向匹配成功的硬件信息
          id指向驱动自己定义初始化的i2c_device_id对象,就是
          at24_id
    remove：卸载软件节点,内核调用此函数

    配套函数：
    i2c_add_driver(&软件节点对象); //注册
    i2c_del_drier(&软件节点对象);  //卸载

案例：编写TPAD上AT24C02存储器的软件节点代码
      注意：前提是内核已经有了AT24C02的硬件信息
实施步骤：
1.从ftp下载源码
2.mkdir /opt/drivers/day12/
  cp at24c02_1 /opt/drivers/day12
  cd /opt/drivers/day12/at24c02_1 潜心研究代码
  make
  cp at24c02_drv.ko /opt/rootfs/home/drivers
开发板测试：
insmod /home/drivers/at24c02_drv.ko
观察驱动的probe函数是否被调用

rmmod at24c02_drv //观察remove函数是否被调用

案例：编写TPAD上AT24C02存储器的软件节点代码
      注意：前提是内核已经有了AT24C02的硬件信息
实施步骤：
1.从ftp下载源码
2.mkdir /opt/drivers/day12/
  cp at24c02_2 /opt/drivers/day12
  cd /opt/drivers/day12/at24c02_2
  潜心研究at24c02_drv.c at24c02_test.c
  make
  cp at24c02_drv.ko /opt/rootfs/home/drivers
  arm-linux-gcc -o at24c02_test at24c02_test.c
  cp at24c02_test /opt/rootfs/home/drivers/

开发板测试：
insmod /home/drivers/at24c02_drv.ko
ls /dev/at24c02 -lh
./at24c02_test

SMBUS接口函数的使用操作步骤：
1.首先打开I2C外设的芯片手册,找到对应的操作时序图
2.然后打开内核关于smbus接口的说明文档：
  内核源码\Documentation\i2c\smbus-protocol
3.在文档中根据手册的时序要求找到对应的函数
  例如：
  按字节写的时序：S->设备地址<<1|0->ACK->片内地址->ACK->数据->ACK->STOP
  找到此函数：i2c_smbus_write_byte_data()
  此函数说明提示：S Addr Wr [A] Comm [A] Data [A] P //完全符合
4.赋值函数名,在sourceinsight中找到函数的定义
  在自己的驱动代码中填充参数即可

回顾：
1.linux内核mmap机制
  目的：将硬件外设的物理地址映射到用户空间的虚拟地址上

  内核的sys_mmap所做的内容：
  1.帮你在MMAP内存映射区找一块空闲的虚拟内存区域,用来映射物理地址
  2.一旦找到,内核用struct vm_area_struct数据结构来描述这块空闲的
    虚拟内存区域,其对象由内核创建
  3.内核sys_mmap最终调用底层驱动的mmap接口,并且将描述空闲的
    虚拟内存区域的对象的首地址传递给驱动的mmap接口

  底层驱动的mmap仅作只做一件事：映射
  struct file_operations {
   int (*mmap)(struct file *file, struct vm_area_struct *vma)
  };//vma指针指向的对象由内核创建,用来描述空闲的虚拟内存区域
  切记：映射时,地址必须是页面大小的整数倍！

2.linux内核platform机制
  实现linux内核的分离思想
  实现将硬件和软件彻底分开
  一旦软件写好,无需在进行改动
  将来只需要关注硬件差异即可,将来硬件有所变动,只需改动硬件部分
  画图
  总结：
  1.probe函数是否被调用至关重要！
  2.驱动开发者利用platform机制实现设备驱动,只关注两个数据结构：
    struct platform_device
        .name 相当重要
        .id
        .resource
                .start
                .end
                .flags
                  IORESOURCE_MEM
                  IORESOURCE_IRQ
        .num_resources
    struct platform_driver
        .driver = {
                .name 相当重要
        },
        .probe 匹配成功内核调用,形参指向匹配成功的硬件信息
        .remove 删除软件或者硬件节点内核调用

  3.什么遍历,什么匹配,什么调用,什么传参都是由内核完成！
  4.probe函数一般所做的工作：
    0.调用代表一个完整的硬件设备驱动产生
    1.通过形参获取硬件信息
      struct resource *platform_get_resource(
                struct platform_device *pdev,
                int flags;
                int index;
      );
      函数功能：通过probe函数的形参pdev或者resource描述硬件信息
      pdev:指向匹配成功的硬件信息
      flags：硬件信息的类型
             IORESOURCE_MEM/IORESOURCE_IRQ
      index:同类资源的偏移量
      返回值：返回获取到的硬件信息的首地址

    2.处理获取到的硬件信息
      该申请的申请
      该注册的注册
      该映射的映射
      该初始化的初始化
    3.注册硬件操作接口(字符设备驱动或者混杂设备驱动)
      .open
      .release
      .read
      .write
      .unlocked_ioctl
      .mmap

    remove跟probe对着干！

**********************************************************
3.I2C总线(IIC总线)
  面试题：谈谈对I2C总线理解
  3.1.I2C总线的功能
  计算机CPU和外设的通信方式很多种：
  GPIO,例如LED,按键
  总线(地址线数据线),例如内存,NorFlash,DM9000
  UART,例如BT,GPS
  I2C,例如重力传感器,触摸屏芯片
  一线式,例如DS18B20温度传感器
  SPI,例如NorFlash
  等
  I2C总线是CPU和外设通信的一种数据传输方式

  3.2.I2C总线的定义
  两线式串行总线
  解释：
  “两线式”：CPU跟外设的数据通信只需2根信号线,分别是SCL时钟控制信号线
            和SDA数据线,画简要的连接图
  SDA数据线：用来传输数据,CPU和外设都可以控制,但是不能同时
             控制,例如CPU向外设写数据,数据线由CPU控制
                      CPU从外设读取数据,数据线由外设控制
             问：由于外设的处理速度远远慢于CPU,CPU和外设如何
                 保证数据传输的正常呢？
             答：关键靠SCL时钟线
             注意：I2C总线数据传输从数据的高位开始！

  SCL时钟线：同步双方的数据传输,保证数据传输正常，只能由CPU控制
             例如：CPU在SCL为高电平时,将数据放到数据线上
                   设备就在同周期的SCL为低电平时,从数据线上读取数据
                   SCL为低电平时,数据线上的数据保持稳定不变！

  “串行”：CPU和外设的数据通信是一个时钟周期传输1个bit位
  “总线”: CPU和外设通信的两根信号线上可以挂接多个外设
          画出简要的连接图
  注意：SDA和SCL都会连接一个上拉电阻,默认电平都为高电平！

  问：CPU如何找到总线上要访问的某个外设？
  问：如果CPU找到这个外设,CPU如何通过两根信号线和外设通信呢？
  问：SDA和SCL如何搭配使用呢？
  答：答案在I2C总线传输协议中

  3.3.I2C总线协议相关概念
  CPU=主设备=master
  外设=slave
  MSB:高位
  LSB:低位

  START信号：又称起始信号,每当CPU要访问总线上某个外设,首先CPU向总线
             发送一个START信号,此信号只能由CPU发起
             SCL为高电平,SDA由高向低跳变产生START信号
             类似“同学们,上课了”
  STOP信号：又称结束信号,每当CPU要结束对某个外设的访问,CPU
            只需向总线发送一个STOP信号即可,此信号同样只能由CPU发起
            SCL为高电平,SDA由低向高跳变产生STOP信号
            类似“同学们,下课”
            画图START和STOP时序图
  读写位：如果CPU要读设备,读写位=1;如果CPU要写设备,读写位=0
  设备地址：同一个I2C总线上的外设都有一个唯一的设备地址(类似身份证号)
            表示外设在总线上的唯一性
            如果将来CPU要访问总线上某个外设,CPU只需向总线
            发送这个外设对应的设备地址即可
            类似“某某同学,请回答问题”
            切记：设备地址不包含读写位

            读设备地址=设备地址<<1|1
            写设备地址=设备地址<<1|0

            问：外设的设备地址如何确定？
            答：
            以LM77温度传感器为例P8：
            确定LM77设备地址=10010A1A0(A1A0都接地)=》
            1001000(高位补0)=01001000=0x48
            =>
            LM77的：
            读设备地址=0x48<<1 | 1
            写设备地址=0x48<<1 | 0

            以AT24C02存储器为例P11:
            确定AT24C02设备地址=1010A2A1A0(A2A1A0都接地)=》
            1010000(高位补0)=01010000=0x50
            读设备地址=0x50<<1 | 1
            写设备地址=0x50<<1 | 0

            以ADP8860背光灯控制芯片为例：
            0101010x=>
            设备地址=0101010(去x,高位补0)=00101010=0x2A
            读设备地址=0x2A<<1 | 1
            写设备地址=0x2A<<1 | 0

  ACK信号:又称应答信号,表示CPU和外设的通信状态
          低电平有效
          类似“老师，我在”

  总结：
  1.CPU要想访问总线上某个外设,CPU只需向总线发送这个外设的
    设备地址即可
    I2C总线数据传输一周期一bit,一次一字节

  问：CPU一旦通过设备地址找到某个外设,如何通过两根信号线
      和外设进行数据通信呢？
  答：答案都在外设的芯片手册中,重点关注其中的操作时序图
  以CPU读取LM77温度传感器2字节数据为例P12：
  1.CPU向总线发送START信号
  2.CPU向总线发送外设的设备地址包括读写位
  3.如果外设存在于总线上,外设在第九个时钟周期会给CPU发送
    一个ACK信号,低电平有效
  4.设备向CPU发送两字节数据的高字节
  5.CPU读取数据以后,CPU同样在第九个时钟周期给外设一个有效的
    ACK信号
  6.设备继续向CPU发送两字节数据的低字节
  7.CPU读取数据以后,没有在第九个时钟周期给外设一个有效的
    ACK信号
  8.数据读取完毕,CPU向总线发送STOP信号结束此次的数据读取操作
  边说边画图(框框圈圈)

  以AT24C02存储器的读写为例P11，字节写时序图：
  AT24C02存储器特性：
        存储容量256字节
        内部地址编址：0x00~0xff
  用户需求：将数据'A'写入到AT24C02的片内的0x10地址存储空间中
            硬件操作流程：
  1.CPU向总线发送START信号
  2.CPU向总线发送设备地址包括读写位
  3.如果设备存在于总线上,设备在第九个时钟周期给CPU发送一个
    有效的ACK信号
  4.CPU向设备发送要访问的片内地址0x10
  5.设备接收到了CPU要访问的片内地址,设备同样在第九个时钟
    周期给CPU一个有效的ACK信号
  6.CPU最后向设备发送要写入的数据'A'
  7.设备将数据写入到片内0x10地址以后,设备同样在第九个时钟
    周期给CPU一个有效的ACK信号
  8.CPU向总线发送STOP结束数据的操作
  边说边画框框圈圈图

  再以CPU读取AT24C02任意片内地址存储空间的数据为例P2随机读试图：
  具体参见时序图

  最后以CPU让HMC6352指南针传感器进入休眠模式为例：
  1.CPU发送START信号
  2.CPU发送设备地址<<1|0
  3.设备如果存在于总线上,设备在第九个时钟周期给CPU发送一个
    有效的ACK信号
  4.CPU向设备发送命令'S'=0x53,让设备进入休眠模式
  5.设备接收到命令以后，设备在第九个时钟周期给CPU发送一个
    有效的ACK信号
  6.最后CPU向总线发送STOP信号结束访问
  边说边画圈圈框框图

  切记：任何外设的访问必须严格按照时序图进行！！！

  问：SDA和SCL如何搭配使用呢？
  答：以CPU向设备写入数据为例：
      CPU应该在SCL为低电平的时候将数据放到数据线上
      那么设备就应该在SCL同周期的高电平从数据线上读取数据
      "低放高取"
  一定要画出相应的时序图,以CPU向HMC6352发送‘S’为例P4：
  可以仅画START时序,写0,1时序即可

  会画波形，将来也会分析示波器的波形图！！！！

回顾：
1.linux内核等待队列编程方法2
  工作队列：底半部一种实现方法,延后执行的一种手段
            延后处理函数工作在进程上下文,可以休眠操作
  等待队列：实现进程在内核中随时随地休眠,随时随地唤醒
  编程实现两种形式：
  方式1：
  1.定义初始化等待队列头
  2.定义初始化装载休眠进程的容器
  3.添加
  4.设置为休眠状态
  5.进入真正的休眠，等待被唤醒
  6.一旦被唤醒,设置为运行,移除
  7.判断唤醒的原因
  8.在某个地方进行唤醒,一般在中断处理函数中唤醒
  方式2：
  1.定义初始化等待队列头
  2.直接进入休眠
  3.在某个地方进行唤醒,一般在中断处理函数中唤醒
  4.注意,编程口诀：唤醒前设置为真;唤醒以后设置为假

2.linux内核内存分配相关内容
  2.1.linux内核1G虚拟内存的划分
  划分的本质目的：一方面让内核访问到所有的物理地址
                  另一方面让内核的内存访问效果提高

  2.2.linux内核内存分配的方法
  kmalloc/kfree
  __get_free_pages/free_pages
        注意：GFP_KERNEL/GFP_ATOMIC
  vmalloc/vfree
  启动参数添加vmalloc=?
  启动参数添加mem=?

  2.3.linux内核地址映射的函数:ioremap
  明确：软件一律不允许直接访问硬件外设的物理地址
  问：如何将外设的物理地址映射到内核的虚拟地址上？
  答：ioremap

3.问：如何将外设的物理地址映射到用户空间的虚拟地址上呢？
      如果一旦完成这种映射,将来用户应用程序只需要在用户
      空间访问映射的用户虚拟地址就是在访问实际的硬件物理地址？
      也就是原先驱动中的这些代码：
      *gpiocon &= ~((0xff << 12)); //gpiocon此时就是用户虚拟地址
      ...
      这些代码都应该在应用程序中完成！
  答：利用mmap

  3.1.回忆：应用程序mmap系统调用函数的使用：
  void *addr;
  int fd = open("a.txt", O_RDWR);

  addr = mmap(0, 0x1000, PROT_READ|PROT_WRITE,
                MAP_SHARED, fd ,0);
  说明：
  功能：将文件a.txt映射到当前进程的3G虚拟内存的MMAP内存映射区中的
  某块虚拟内存上,一旦完成映射,将来访问映射的用户虚拟内存就是
  在访问实际的文件；
  明确：
  "文件"：太抽象,文件实际代表的是一个硬件设备(硬盘),通常说
  访问文件,其他就是在说访问硬盘的物理存储地址空间,由于linux系统
  不允许直接访问硬盘的物理地址,需要进行映射,利用mmap就能够
  将硬盘的物理地址映射到用户的虚拟地址上,将来访问映射的用户
  虚拟地址就是在访问实际的硬盘物理地址

  第一个参数0:让内核帮你在MMAP内存映射区中找一块空闲的虚拟内存
              用来映射外设的物理地址

  第二个参数0x1000:要映射的用户虚拟内存区域的大小
                   一般为页面大小的整数倍
  第三个参数PROT_READ|PROT_WRITE:将来给这块虚拟内存设置一个访问权限
  ...
  返回值addr：保存的就是内存映射区域的首地址

  3.2.mmap系统调用的过程做了哪些工作：
  1.当应用程序调用mmap系统调用函数
  2.首先调用到C库的mmap函数的定义
  3.C库的mmap函数将做两件事：
    1.保存mmap系统调用号到R7寄存器
    2.调用svc指令触发软中断异常
      至此进程由用户态陷入内核态
  4.进入内核的软中断处理的入口,做两件事：
    1.从R7寄存器取出之前保存的系统调用号
    2.以系统调用号为下标在内核的系统调用表中
    找到对应的内核函数sys_mmap
    调用此函数；
  5.内核的sys_mmap同样做三件事：
    1.内核会在当前进程的3G的MMAP内存映射区中找一块
      空闲的虚拟内存区域来映射硬件的物理地址
    2.一旦内核找到了空闲内存区域,内核用struct vm_area_struct
      结构体帮你创建一个对象来描述这块空闲内存区域的属性(起始地址,大小,访问权限等)
      struct vm_area_struct {
        unsigned long vm_start;//空闲虚拟内存区域的起始地址
        unsigned long vm_end;//结束地址
        pgprot_t vm_page_prot;//访问权限
        unsigned long vm_pgoff;	//偏移量
        ...
      };
      总结：应用程序的mmap的返回值addr就是vm_start
            此数据结构对应的对象由内核创建
    3.最后内核的sys_mmap调用底层驱动的mmap接口,切记并且
      内核将创建的vm_area_struct结构体对象指针传递给底层驱动
      的mmap接口,底层驱动的mmap接口通过参数获取空闲虚拟内存
      区域的属性！

   6.底层驱动的mmap接口函数只做仅作一件事,将已知的空闲虚拟内存
   和外设的物理内存建议映射即可,一旦建议映射,将来对硬件的访问
   过程都是在应用程序中完成！
   底层驱动mmap接口的角色类似“媒婆”,只负责映射(牵线),
   具体的硬件访问操作跟mmap没有任何关系！

   7.底层驱动mmap接口
   struct file_operations {
        int (*mmap)(struct file *file,
                        struct vm_area_struct *vma)
   };
   功能：
   此接口函数只做仅作一件事：将已知的用户虚拟地址和已知的
                            物理地址建立映射
   参数：
   file:文件指针
   vma:指向内核描述空闲虚拟内存区域的属性对象
       vma指向的对象由内核创建
       对象描述内核找到的空闲用户虚拟内存区域的属性

   底层驱动mmap接口只需调用一下函数即可完成最终的映射：
   int remap_pfn_range(struct vm_area_struct *vma,
                        unsigned long from,
                        unsigned long to,
                        unsigned long size,
                        pgprot_t prot);
  功能：将已知的用户虚拟地址和已知的物理地址进行映射
  参数：
  vma: 指向内核描述空闲虚拟内存区域的属性对象
  from:已知要映射的用户虚拟的起始地址vm_start
  to:已知要映射的物理地址,注意要将物理地址>>12
  size:映射的用户虚拟内存的大小
  prot：用户虚拟内存区域的属性

  切记切记：mmap地址映射时,地址(不管是用户虚拟地址还是物理地址)
            必须是页面大小的整数倍！
  例如：
  GPC1CON:0xE0200080
  GPC1DATA:0xE0200084
  注意：不能拿0xE0200080或者0xE0200084去做地址映射,这两个地址
  不是页面大小的整数倍！所以拿0xE0200000做地址映射即可：
  物理地址        用户虚拟地址
  0xE0200000      vm_start
  0xE0200080      vm_start + 0x80
  0xE0200084      vm_start + 0x84

  案例：利用mmap实现LED驱动

  切记：利用mmap进行GPIO操作(输入和输出操作时),把cache关闭
  vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);

**************************************************************
3.linux内核分离思想
  3.1.案例：将TPAD开发板的LED1,LED2对应的GPIO更换成GPF1_4,GPF1_5
        并且实现其驱动程序
  分析：
  明确：一个完整的硬件设备驱动必然包含两个内容：
        纯硬件信息和纯软件信息(软件操作硬件)
  如果要实现以上驱动,只需将昨天利用ioremap实现的LED驱动改造即可
  分析改动的部分；
  原先：
  LED1->GPC1_3
  LED2->GPC1_4
  0xE0200080,0xE0200084
  现在
  LED1->GPF1_4
  LED2->GPF1_5
  0xE020.... 0xE020....

  总结：
  1.如果是硬件发生变化,之前的LED驱动修改的部分还是蛮多
  2.可以采用C的#define来优化此驱动,但是#define不能给硬件
    添加额外的属性

  3.问：如何让这个LED驱动具有更好的可移植性呢(如果将来仅仅
  是硬件发生变化,只需修改硬件信息,软件一旦写好,就无需改动,
  甚至都不用去看)
    答：采用linux内核的分离思想

  3.2.linux内核分离思想
  linux内核分离思想就是将一个完整的硬件驱动的纯硬件信息和
  纯软件信息彻底分开,一旦驱动的软件部分写好,将来无需在改动，
  硬件变化,只需修改硬件信息即可,将来驱动开发者的重心放在硬件
  部分即可.

  linux内核分离思想的实现基于platform机制

  3.3.linux内核的platform机制
  机制实现原理：参见PPT

  3.4.linux设备驱动采用platform机制实现,驱动开发者只需关注
  两个数据结构：
  struct platform_device
  struct platform_driver
  问：如何使用？

  1.struct platform_device的使用操作步骤：
    struct platform_device {
        const char	* name;
        int		id;
        u32		num_resources;
        struct resource	* resource;
        ...
    };
    功能：描述硬件外设的纯硬件信息
    成员说明：
    name:描述硬件节点的名称,将来用于匹配
    id：硬件节点的编号,如果dev链表中仅有一个硬件节点,id=-1
        如果dev链表上有同名的多个硬件节点,id=0,1,2...
    resource:装载纯硬件信息
             struct resource {
                unsigned long start;
                unsigned long end;
                unsigned long flags;
                ...
             };
             功能：描述纯硬件信息
             start:硬件的起始信息
             end:硬件的结束信息
             flags:硬件的类型：
                   IORESOURCE_MEM：地址类信息
                   IORESOURCE_IRQ: IO类信息
    num_resources:纯硬件信息对象的个数

    配套函数：
    int platform_device_register(&硬件节点对象);
    功能：注册硬件节点到dev链表
    1.添加节点到dev链表
    2.内核帮你遍历drv链表,取出每一个软件节点进行匹配
    3.一旦匹配成功,内核调用软件节点的probe函数
    4.顺便把匹配成功的硬件节点的首地址给probe函数
      完成硬件和软件的再次结合

    void platform_device_unregister(&硬件节点对象);
    功能：将硬件节点从dev链表上删除
          此时内核会调用remove函数

  2.struct platform_driver
    struct platform_driver {
        int (*probe)(struct platform_device *pdev);
        int (*remove)(struct platform_device *pdev);
        struct device_driver driver;
        ...
    };
    功能：描述驱动的纯软件信息
    成员：
    probe:当硬件和软件匹配成功,内核调用此函数
          形参pdev指向匹配成功的硬件节点
          注意：它是否被调用至关重要！只有此函数被调用
          一个完成的驱动诞生！
    remove：当卸载软件或者硬件节点时,内核调用此函数
            形参pdev指向匹配成功的硬件节点
          注意：remove和probe永远是死对头！

    driver：只需关注其中的name字段,将来用于匹配

    配套函数：
    int platform_driver_register(&软件节点对象);
    功能：注册软件节点到drv链表
    1.添加节点到drv链表
    2.内核帮你遍历dev链表,取出每一个硬件节点进行匹配
    3.一旦匹配成功,内核调用软件节点的probe函数
    4.顺便把匹配成功的硬件节点的首地址给probe函数
      完成硬件和软件的再次结合

    void platform_driver_unregister(&软件节点对象);
    功能：将软件节点从drv链表上删除
          此时内核会调用remove函数

    案例：利用platform机制优化LED驱动
    实验步骤：
    cd /home/drivers/
    insmod led_drv.ko
    insmod led_dev.ko
    rmmod led_dev
    rmmod led_drv
    ...

    项目实施：
    project.doc文档
    根据文档从制作文件系统开始
    内容：
    制作根文件系统
    tslib移植
    QT移植

回顾：
1.linux内核并发和竞态之原子操作
  特点：
  能够解决所有的竞态问题
  位原子操作：对共享资源进行位操作,考虑竞态问题
  整形原子操作：对共享资源进行整型操作,考虑竞态问题
  数据类型：atomic_t(类比成int)
  总结：操作务必要使用内核提供的相关函数

2.linux内核等待队列机制
  产生根本原因：外设的处理速度远远慢速CPU
  能够让进程随时随地休眠,随时随地被唤醒
  编程步骤：
  1.定义初始化等待队列头(全局变量)
  2.定义初始化装载休眠进程的容器(局部变量)
    current：内核全局变量,指向"当前进程"
  3.添加休眠进程到等待队列中
  4.设置当前进程的休眠状态
  5.进入真正的休眠状态,释放CPU资源,等待被唤醒
    注意：唤醒的方法
  6.一旦进程被唤醒,设置进程的状态为运行,并且将进程从
    等待队列中移除
  7.一般要判断进程唤醒的原因
  8.驱动主动唤醒的方法
    wake_up/wake_up_interruptible
  9.务必掌握按键驱动包括去抖动

3.linux内核等待队列编程方法2：
  编程步骤：
  1.定义初始化等待队列头(构造鸡妈妈)
    wait_queue_head_t wq;
    init_waitqueue_head(&wq);
  2.调用以下两个方法即可实现进程的休眠
    wait_event(wq, condition);//切记：此乃宏
    说明：
    wq：等待队列头
    condition:如果condition为真,进程不会休眠,立即返回,即硬件设备可用(可读或者可写)
              如果condition为假,进程将进入不可中断的休眠状态,等待被唤醒,即硬件设备不可用

    或者
    wait_event_interruptible(wq, condition);
    说明：
    wq：等待队列头
    condition:如果condition为真,进程不会休眠,立即返回,即硬件设备可用(可读或者可写)
              如果condition为假,进程将进入可中断的休眠状态,等待被唤醒,即硬件设备不可用
    总结：
    以上两个宏等价于编程方法1的第2步~第7步

  3.唤醒的方法
    wake_up/wake_up_interruptible

  方法2的编程框架：
  //休眠的地方
  xxx(...) {
        //起初condition为假
        wait_event_interruptible(wq, condition);
        //一旦被唤醒
        condition设置为假
  }

  //唤醒的地方
  yyy(...) {
        condition设置为真
        //唤醒休眠的进程
        wake_up_interruptible(&wq);
  }

  案例：利用等待队列编程方法2实现按键驱动

***********************************************************
3.linux内核内存分配相关内容
  3.1.linux内核内存的划分(了解)
  明确：不管是在用户空间还是在内核空间,软件一律不允许访问
        硬件外设的物理地址,要想软件访问硬件外设的物理地址
        必须将硬件外设的物理地址映射到用户虚拟地址或者
        内核虚拟地址,将来软件只要访问用户虚拟地址或者
        内核虚拟地址就是在访问对应的物理地址
  特例：uclinux操作系统软件访问的地址都是物理地址

  回顾用户空间3G虚拟内存的划分
  总结：用户空间3G虚拟内存地址和物理地址之间的映射
        属于动态映射(用到时进行映射,不用时将映射关系解除)
  4G虚拟地址划分为用户虚拟地址和内核虚拟地址
  用户虚拟地址空间范围：0~0xbfffffff
  内核虚拟地址空间范围：0xc0000000~0xffffffff

  linux内核1G虚拟内存地址和物理内存地址的映射属于一一映射,
  即内核在启动的时候就已经将物理内存地址和内核1G虚拟内存地址
  建立好映射关系,将来软件无需再次建立映射,直接访问即可,内存
  的访问效率最高：
  物理内存地址     内核虚拟地址
  0x0     	   0xC0000000
  0x1		   0xC0000001
  0x2		   0xC0000002
  ...              ...
  1G		   1G
  一一映射存在线性关系！
  问题：如果采用一一映射,linux内核最多只能访问1G的物理内存
  如何让内核访问到所有的物理内存地址呢？又要兼顾内存的访问
  效率
  答：linux内核将1G虚拟内存划分若干个区域
  X86划分：
  直接内存映射区：
        大小为896M
        内核在启动的时候,将直接内存映射区的内核虚拟内存地址
        和物理内存地址进行一一映射,这块内存区域的效率最高
        又称低端内存
  动态内存映射区：
        默认大小为120M
        内核代码需要访问某块物理内存时,内核动态建立动态内存映射区
        的虚拟内存和物理内存的映射,使用完毕,一定要记得解除
        地址映射,否则造成内存泄漏

  永久内存映射区：
  固定内存映射区：
        固定=永久
        大小都为4M
        如果频繁的访问某块物理内存,考虑到效率,可以将
        物理内存映射到永久或者固定内存的虚拟内存上
        前者映射时会导致休眠,不能用于中断上下文
        后者不会导致休眠

   高端内存=动态内存映射区+永久+固定

   TPAD开发板,linux内核1G虚拟内存的划分：
   启动开发板,观察内核打印信息,找到1G内核虚拟内存的划分：
   Virtual kernel memory layout:
    区域名    内核起始地址  内核结束地址  区域大小

    异常向量表
    vector  : 0xffff0000 - 0xffff1000   (   4 kB)

    固定内存映射区
    fixmap  : 0xfff00000 - 0xfffe0000   ( 896 kB)

    DMA内存映射区
    DMA     : 0xff000000 - 0xffe00000   (  14 MB)

    动态内存映射区
    vmalloc : 0xec800000 - 0xfc000000   ( 248 MB)

    直接内存映射区
    lowmem  : 0xc0000000 - 0xec600000   ( 710 MB)

    //模块加载区域
    modules : 0xbf000000 - 0xc0000000   (  16 MB)

    //初始化段
      .init : 0xc0008000 - 0xc0037000   ( 188 kB)
    //代码段
      .text : 0xc0037000 - 0xc0832000   (8172 kB)
    //数据段
      .data : 0xc0832000 - 0xc0886960   ( 339 kB)

   切记：一个物理地址可以有多个虚拟地址(用户的和内核的)
         但是一个虚拟地址不能对应多个物理地址

   3.2.linux内核内存分配的函数
   回忆应用内存分配：
   int a; //局部,全局的(初始化和没初始化)
   malloc/free //堆

   内核分配函数一：
   kmalloc/kfree
   函数原型：
   void *kmalloc(int size, gfp_t flags)
   功能：
   1.从直接内存映射区分配内存
     访问效率高
   2.分配内存大小最小32字节,最大4MB
   3.分配的内核虚拟内存和物理内存都是连续的

   参数：
   size:指定分配内存的大小,单位为字节
   flags:指定分配内存时的行为标志：
         GFP_KERNEL:告诉内核,请努力将这次内存分配搞定
                    如果内存不足,会导致休眠,所以不能用在
                    中断上下文
         GFP_ATOMIC:如果内存不足,不会进行休眠,而是立即返回
                    可以用在中断上下文
   返回值：返回分配内核虚拟内存的首地址
   例如：
   void *addr;
   addr = kmalloc(100, GFP_KERNEL);
   if (addr == NULL)
        return -ENOMEM;

   memcpy(addr, "hello,world", 12);

   不再使用时,记得要释放内存：
   void kfree(void *addr)

   内核内存分配函数二：
   __get_free_pages/free_pages
   函数原型：
   unsigned long __get_free_pages(gfp_t flags, int order)
   功能：
   1.从直接内存映射区分区
   2.物理和虚拟内存上都是连续的
   3.最大4MB

   参数：
   flags：表示分配内存时的行为
          GFP_KERNEL:告诉内核,请努力将这次内存分配搞定
                    如果内存不足,会导致休眠,所以不能用在
                    中断上下文
          GFP_ATOMIC:如果内存不足,不会进行休眠,而是立即返回
                    可以用在中断上下文
   order:order=0,分配1页
         order=1,分配2页
         order=2,分配4页
         order=3,分配8页
         ...
   返回值：返回分配内存的首地址,注意数据类型的转换

   unsigned long addr;
   addr = __get_free_pages(GPF_KERNEL, 2);
   memcpy((void *)addr, "hello,world", 12);

   内存不再使用时,记得要释放内存：
   void free_pages(unsigned long addr, int order);

   内核内存分配函数三：
   vmalloc/vfree
   void *vmalloc(int size);
   函数功能：
   1.从动态内存映射区分配内存
   2.内核虚拟地址是连续的,但是对应的物理地址不一定连续
     动态内存映射区的内存访问效率低
   3.理论默认最大分配120M
   4.同样会导致休眠,所以不能用在中断上下文

   释放内存：
   void vfree(void *addr)

   内核内存分配另类方法：
   在内核启动参数中,添加vmalloc=？(例如vmalloc=250M)表示
   内核启动时,将动态内存映射区的大小由原先的120M扩展到
   250M

   案例：跳转动态内存映射区的大小
   1.启动开发板的linux系统,观察内核打印信息,首先确认
     直接内存映射区和动态内存映射区的大小(默认832M和120M)

   2.重启开发板,进入uboot,执行：
   setenv bootargs root=/dev/nfs nfsroot=192.168.1.8:/opt/rootfs ip=192.168.1.110:192.168.1.8:192.168.1.1:255.255.255.0::eth0:on init=/linuxrc console=ttySAC0,115200 vmalloc=250M
   saveenv
   boot
   cat /proc/cmdline
   继续观察内核的启动信息,再次查看直接内存映射区和动态内存映射区的大小是否有变化

   内核内存分配另类方法：
   在内核启动参数中,添加mem=？(例如mem=8M)表示
   内核启动时,将物理内存的最后8M预留出来,将来给驱动单独使用
   但是驱动使用时,必须利用ioremap函数进行地址映射,将最后的
   8M物理内存和内核的动态内存映射区的虚拟内存做映射,一旦完成
   映射,将来驱动访问映射的内核虚拟内存就是在访问最后的8M物理
   内存

**********************************************************
4.大名鼎鼎的ioremap函数
  4.1.明确
  嵌入式系统,CPU访问某个外设,必须要先获取到这个外设的基地址
  只要有了这个基地址,将来就可以以地址指针的形式访问：
  *(unsigned long *)0x20000000 = 0x55;

  4.2.明确
  linux系统不管是用户空间还是内核空间,一律不允许访问外设的物理基地址
  ,要想访问,必须将设备的物理地址映射到用户虚拟地址上或者
  内核虚拟地址上,将来访问映射的用户或者内核虚拟地址就是在
  访问对应的物理地址

  4.3.问：如何将外设的物理地址映射到内核的虚拟地址上呢？
      答：利用大名鼎鼎的ioremap函数

  4.4.ioremap使用
  函数原型：
  void *ioremap(unsigned long phys_addr, int size)
  函数功能：
  1.将外设的物理地址映射到内核的虚拟地址上
  2.映射到内核1G的动态内存映射区

  phys_addr:硬件外设的起始物理地址
  size:映射的"物理内存"的大小

  返回值：返回的映射的内核起始虚拟地址

  参考代码：
  LED1,LED2硬件寄存器信息：
  GPC0CON:起始物理地址0xE0200060,大小4字节
  GPC0DATA:起始物理地址0xE0200064,大小4字节

  映射如下：
  unsigned long *gpiocon *gpiodata;
  gpiocon = ioremap(0xE0200060, 4);
  gpiodata = ioremap(0xE0200064, 4);

  或者：
  由于发现两个硬件寄存器的内存空间都是连续的,物理上连续：
  gpiocon = ioremap(0xE0200060, 8);
  gpiodata = gpiocon + 1;

  *gpiocon &= ~(0xf << 12);
  *gpiocon |= (1 << 12);
  ...

  内存不再使用时,记得要释放内存,解除地址映射
  iounmap(void *addr);

  例如：
  iounmap(gpiocon);

  案例：不再使用GPIO库函数,实现LED驱动,接口采用ioctl

  小项目：寄存器编辑器
  用户需求：随意能够查看和修改CPU的任何一个寄存器
  思路：
  应用测试思路：
  ./regeditor w regaddr regdata
  ./regeditor r regaddr //打印寄存器的值
  例如：
  ./regeditor w 0xE0200080 0x11000 //将0x11000写入寄存器0xE0200080
  ./regeditor r 0xE0200080 //打印寄存器0xE0200080的值

  应用程序编程思路：
  struct reg_info {
        unsigned long regaddr;
        unsigned long regadata;
  };

  #define REG_WRITE	0x100001 //写寄存器
  #define REG_READ	0x100002 //读寄存器

  struct reg_info reg;

  if (!strcmp) { //写寄存器
        reg.regaddr = strtoul(...);
        reg.regdata = strtoul(...);
        ioctl(fd, REG_WRITE, &reg);
  } else { //读
        reg.regaddr = strtoul(...);
        //reg.regdata = ?
        ioctl(fd, REG_READ, &reg); //读寄存器
        printf("寄存器值=%#x\n", reg.regdata);
  }

 底层驱动ioctl接口：
   struct reg_info {
        unsigned long regaddr;
        unsigned long regadata;
  };

  #define REG_WRITE	0x100001 //写寄存器
  #define REG_READ	0x100002 //读寄存器

 reg_ioctl(...) {
        unsigned long *regbase;
        struct reg_info reg;
        copy_from_user(&reg, (struct reg_info*)arg, 8);
        regbase = ioremap(reg.regaddr, 4);
        switch(cmd) {
                case REG_WRITE:
                *regbase = reg.regdata;
                break;
                case REG_READ:
                reg.regdata = *regbase;
                copy_to_user((struct reg_info *)arg, &reg, 8);
                break;
        }
        iounmap(regbase);
 }

 检验：利用寄存器编辑器软件开关蜂鸣器

回顾：
1.linux内核并发和竞态
  1.1.概念
  并发
  竞态
  共享资源
  临界区
  互斥访问
  执行路径具有原子性

  1.2.形成竞态的4中情形
  SMP
  单CPU,进程与进程的抢占
  中断和进程
  中断和中断
  画图

  1.3.解决竞态问题的方法
  中断屏蔽
  自旋锁
  衍生自旋锁
  信号量

  场景：设置某个GPIO的高低电平的时间为严格的500us
  此时要考虑到竞态问题,一般来说中断最会捣鬼！

  spin_lock_irqsave(&lock ,flags);
  gpio_direction_output(., 1);
  udelay(500);
  gpio_direction_output(., 0);
  udelay(500);
  spin_unlock_irqrestore(&lock, flags);

  1.4.原子操作
  特点：
  原子操作能够解决所有的竞态问题
  原子操作分两类：位原子操作和整形原子操作

  位原子操作=位操作具有原子性,位操作期间不允许发生CPU资源切换

  使用位原子操作的场景：如果驱动对共享资源进行位操作,并且考虑
  到竞态问题,此时可以考虑使用内核提供的位原子操作来避免竞态问题
  但是对共享资源的位操作必须使用内核提供的相关函数：
  void set_bit(int nr, void *addr)
  void clear_bit(int nr, void *addr)
  void change_bit(int nr, void *addr)
  int test_bit(int nr, void *addr)
  ...
  addr:共享资源的首地址
  nr:第几个bit位(从0开始)

  参考代码：
  static int open_cnt = 1; //共享资源

  //临界区
  open_cnt &= ~(1 << 1); //不具有原子性,会发生CPU资源的切换

  改造,考虑竞态问题：
  方案1：
  local_irq_save(flags);
  open_cnt &= ~(1 << 1);
  local_irq_restore(flags);

  方案2：
  spin_lock_irqsave(&lock, flags);
  open_cnt &= ~(1 << 1);
  spin_unlock_irqrestore(&lock, flags);

  方案3：
  down(&sema);
  open_cnt &= ~(1 << 1);
  up(&sema);

  方案4：
  clear_bit(&open_cnt, 1);

  案例：加载驱动,在驱动入口函数将0x5555数据变成0xaaaa
  不允许使用change_bit函数

  整形原子操作 = 整形操作具有原子性
  使用场景：如果驱动中对共享资源进行整型数的操作,并且考虑到
  竞态问题,可以考虑使用整形原子操作

  整形原子变量数据类型：atomic_t(类比成int)

  编程步骤：
  1.定义初始化整型原子变量
    atomic_t tv = ATOMIC_INIT(1);
  2.对整形原子变量操作,内核提供了相关的配套函数
    atomic_add
    atomic_sub
    atomic_inc
    atomic_dec
    atomic_set
    atomic_read
    atomic_dec_and_test(&tv) //整形原子变量tv自减1,然后判断tv的值
    是否为0,如果为0,返回真;否则返回假

    参考代码：
    static int open_cnt = 1;

    //临界区
    --open_cnt; //不具有原子性

  改造,添加方法：
  方案1：
  local_irq_save(flags);
   --open_cnt
  local_irq_restore(flags);

  方案2：
  spin_lock_irqsave(&lock, flags);
   --open_cnt
  spin_unlock_irqrestore(&lock, flags);

  方案3：
  down(&sema);
  --open_cnt
  up(&sema);

  方案4：整形原子操作
  static atomic_t open_cnt = ATOMIC_INIT(1);
  atomic_dec(&open_cnt);

*********************************************************
2.linux内核等待队列机制
  2.1.等待分两种
  忙等待：CPU原地空转,等待时间比较短的场合
  休眠等待：专指进程,进程等待某个事件发生进入休眠状态
  等待队列机制研究休眠等待！

  2.2.等待的本质
  由于外设的处理速度慢于CPU,当某个进程要操作访问硬件外设
  当硬件外设没有准备就绪,那么此进程将进入休眠等待,那么进程
  会释放CPU资源给其他任务使用,直到外设准备好数据(外设会给CPU发送中断信号),唤醒之前
  休眠等待的进程,进程被唤醒以后即可操作访问硬件外设

  以CPU读取UART数据为例,理理数据的整个操作流程：
  1.应用程序调用read,最终进程通过软中断由用户空间
    陷入内核空间的底层驱动read接口
  2.进程进入底层UART的read接口发现接收缓冲区数据没有准备
    就绪,此进程释放CPU资源进入休眠等待状态,此时代码停止不前
    等待UART缓冲区来数据
  3.如果在某个时刻,UART接收到数据,最终势必给CPU发送一个中断信号
    内核调用其中断处理函数,只需在中断处理函数中唤醒之前
    休眠的进程
  4.休眠的进程一旦被唤醒,进程继续执行底层驱动的read接口
    read接口将接收缓冲区的数据最终上报给用户空间

  问：如何让进程在内核空间休眠呢？
  答：
  利用已学的休眠函数：msleep/ssleep/schedule/schedule_timeout
  这些函数的缺点都需要指定一个休眠超时时间,不能够随时随地休眠
  随时随地被唤醒！

  问：如何让进程在内核空间随时随地休眠,随时随地被唤醒呢？
  答：利用等待队列机制
  msleep/ssleep/信号量这些休眠机制都是利用等待队列实现！

  2.4.等待队列和工作队列对比
  工作队列是底半部的一个实现方法,本质让事情延后执行
  等待队列是让进程在内核空间进行休眠唤醒

  2.5.利用等待队列实现进程在驱动中休眠的编程步骤：
  老鹰<------->进程的调度器(给进程分配CPU资源,时间片,切换,抢占),此代码有内核已经实现
  鸡妈妈<------>等待队列头,所代表的等待队列中每一个节点表示的是要休眠的进程
                只要进程休眠,只需把休眠的进程放到鸡妈妈所对应的等待队列中
  小鸡<----->每一个休眠的进程,一个休眠的进程对应的是一个小鸡

  linux内核进程状态的宏：
  进程的运行状态：TASK_RUNNING
  进程的休眠状态：
                不可中断的休眠状态：TASK_UNINTERRUPTIBLE
                可中断的休眠状态：TASK_INTERRUPTIBLE
  进程的准备就绪状态：TASK_READY

  编程操作步骤：
  1.定义初始化等待队列头对象(构造一个鸡妈妈)
    wait_queue_head_t wq; //定义
    init_waitqueue_head(&wq); //初始化

  2.定义初始化装载休眠进程的容器(构造一个小鸡)
    wait_queue_t wait; //定义一个装载休眠进程的容器
    init_waitqueue_entry(&wait, current);//将当前进程添加到wait容器中
                                         //此时当前进程还么以后休眠
    “当前进程”：正在获取CPU资源执行的进程,当前进程是一个动态变化的
    current：内核全局指针变量,对应的数据类型：
             struct task_struct {
                pid_t pid;//进程号
                char comm[TASK_COMM_LEN];//进程的名称
                ...
             };//此数据结构就是描述linux系统进程
             只要创建一个进程,内核就会帮你创建一个task_struct
             对象来描述你创建的这个进程信息
             current指针就是指向当前进程对应的task_struct对象
   打印当前进程的PID和名称：
   printk("当前进程[%s]PID[%d]\n",
                current->comm, current->pid);

   注意：一个休眠的进程要有一个对应的容器wait！

  3.将休眠的进程添加到等待队列中去(将小鸡添加到鸡妈妈的后面)
    add_wait_queue(&wq, &wait);

  4.设置进程的休眠状态
    set_current_state(TASK_INTERRUPTIBLE);//可中断的休眠状态
    或者
    set_current_state(TASK_UNINTERRUPTIBLE); //不可中断的休眠状态
    //此时进程还没有休眠

  5.当前进程进入真正的休眠状态,一旦进入休眠状态,代码
    停止不前,等待被唤醒
    schedule(); //休眠然后等待被唤醒
    对于可中断的休眠状态,唤醒的方法有两种：
    1.接收到了信号引起唤醒
    2.驱动主动唤醒(数据到来,中断处理函数中进行唤醒)

    对于不可中断的休眠状态，唤醒的方法有一种：
    1.驱动主动唤醒

  6. 一旦进程被唤醒,设置进程的状态为运行,并且将当前进程
     从等待队列中移除
     set_current_state(TASK_RUNNING);
     remove_wait_queue(&wq, &wait);

  7.一旦被唤醒,一般还要判断唤醒的原因
    if(signal_pending(current)) {
        printk("进程由于接收到了信号引起的唤醒!\n");
        return -ERESTARTSYS;
    } else {
        printk("驱动主动唤醒!\n");
        //说明硬件数据准备就绪
        //进程继续操作硬件
        copy_to_user//将数据上报给用户空间
    }

   8.驱动主动唤醒的方法：
     wake_up(&wq); //唤醒wq所对应的等待队列中所有的进程
     或者
     wake_up_interruptible(&wq); //只唤醒休眠类型为可中断的进程

   案例：写进程唤醒读进程
   ARM测试步骤：
   insmod /home/drivers/btn_drv.ko
   /home/drivers/btn_test r & //启动读进程
   ps  //查看PID
   top //查看休眠类型
   /home/drivers/btn_test w   //启动写进程


  案例：编写按键驱动,给用户应用程序上报按键状态和按键值
  分析：
  1.应用程序获取按键的状态和按键值
    应用程序调用read或者ioctl获取这些信息
  2.如果按键没有操作,应用程序应该进入休眠等待按键有操作
  3.一旦按键有操作,势必给CPU发送中断信号,此时唤醒休眠的
    进程,进程再去读取按键的信息上报给用户

  测试步骤：
  insmod /home/drivers/btn_drv.ko
  ls /dev/mybtn -lh
  cat /proc/interrupts //查看中断的注册信息


3.按键去除抖动
  由于按键的机械结构,按键的质量问题造成按键存在抖动
  按键抖动实际的波形
  去除抖动的方法：
  硬件去抖动
  软件去抖动：宗旨延时
  每次上升沿和下降沿的时间间隔经验值5~10ms
  单片机裸板开发,采用忙延时,浪费CPU资源
  linux内核同样采用延时,延时采用定时器进行延时

编写驱动步骤：
1.先头文件
2.该声明的声明,该定义的定义,该初始化的初始化
  先搞硬件再弄软件
  struct btn_event
  struct btn_resource

  struct btn_event g_data;
  struct btn_resource btn_info...

  struct file_operations ...
  struct miscdevice ...
3.填充入口和出口
  但凡初始化工作都在入口
  出口跟入口对着干
4.最后完成各个接口函数
  .open
  .release
  .read
  .write
  .unlocked_ioctl
  .mmap
  编写接口函数一定要根据实际的用户需求来完成

  如果有中断,编写中断处理函数
  注意：中断处理函数和各个接口函数之间的关系(数据传递)

按键程序的执行流程：
应用read->驱动read,睡眠->按键按下->产生中断->内核调中断处理函数
->中断处理函数准备上报的数据,唤醒进程->read进程唤醒,继续执行-》
把中断准备好的数据给用户

回顾：
1.linux内核中断编程
  面试题：谈谈对中断理解
  1.1.为什么有中断
      举例子
  1.2.中断硬件连接和触发过程
      画图
  1.3.中断的处理流程
      画图
  1.4.中断编程步骤
      四步骤
  1.5.linux内核中断编程
      request_irq/free_irq
  1.6.linux内核对中断处理函数的要求
  1.7.linux内核中断顶半部和底半部
  1.8.linux内核底半部实现方法
      tasklet
      工作队列
      软中断

2.linux内核软件定时器
  硬件定时器
  HZ
  jiffies
  数据结构：
  struct timer_list
  基于软中断
  不能休眠操作

3.linux内核延时方法
  忙延时
        ndelay/udelay/mdelay
  休眠延时
        msleep/ssleep/schedule/schedule_timeout

4.linux内核并发和竞态
  案例：一个设备要求只能被打开一次
  思路：
  方法1：在应用层实现
  方法2：在驱动层实现

  4.1.概念
  并发：多个执行单元(中断和进程)同时发生
  竞态：多个执行单元对共享资源的同时访问,形成的竞争状态
        三个条件：
        1.要有共享资源
        2.要有多个执行单元
        3.必须对共享资源同时访问

  共享资源：软件上的全局变量和硬件资源(硬件寄存器)
            例如：int open_cnt = 1; //全局变量
                  GPC0CON //硬件寄存器

  临界区：访问共享资源的代码区域
          例如：
          static int open_cnt = 1; //共享资源
          static int led_open(...)
          {
                //临界区
                if (--open_cnt != 0) {
                        ...
                }
                //临界区结尾
          }

  互斥访问：当一个执行单元在访问临界区时,其他执行单元禁止
            访问临界区,直到前一个执行单元访问完毕

  执行路径具有原子性：当一个执行单元在访问临界区时,不允许
                      发生CPU资源的切换,保证这个执行单元
                      踏踏实实访问临界区

  4.2.linux内核中形成竞态的4种情形：
  1.多核(SMP),由于多核共享内存,闪存,IO资源
  2.单CPU的进程与进程之前的抢占(高优先级的进程抢占低优先级进程的CPU资源)
  3.中断和进程
    硬件和进程
    软中断和进程
  4.中断和中断
    硬件和软中断
    软中断和软中断

  4.3.linux内核解决竞态的方法
  中断屏蔽
  自旋锁
  信号量
  原子操作

  4.4.linux内核解决竞态方法之中断屏蔽
  特点：
  1.中断屏蔽能够解决以下竞态问题：
    中断和进程
    中断和中断
    进程与进程的抢占(切记进程与进程的抢占基于软中断)

  2.中断屏蔽无非保护的是临界区,当CPU执行临界区时,不允许中断
    进行来抢占CPU资源,但是由于是屏蔽了中断,而操作系统很多机制
    又跟中断密切相关,所以中断屏蔽保护的临界区的代码执行速度
    要快,更不能进行休眠操作

  编程使用步骤：
  1.明确驱动代码中哪些是共享资源
  2.明确驱动代码中哪些是临界区
  3.明确驱动代码中的临界区是否有休眠操作
    如果有,势必不能使用中断屏蔽此方法
    如果没有,可以考虑使用中断屏蔽
  4.访问临界区之前屏蔽中断
    unsigned long flags
    local_irq_save(flags); //屏蔽中断,保存中断状态到flags

  5.接下来可以踏踏实实的访问临界区,此时也不会发生CPU资源的切换

  6.访问临界区完毕,一定要记得恢复中断
    local_irq_restore(flags);

  7.屏蔽中断和恢复中断一定要逻辑上配对使用！

  参考代码：
  底层驱动的led_open参考代码：
      static int open_cnt = 1; //共享资源
      static int led_open(struct inode *inode,
                                struct file *file)
      {
        unsigned long flags;
        //屏蔽中断
        local_irq_save(flags);

        //临界区
        if (--open_cnt !=0 ){
                printk("设备已被打开!\n");
                open_cnt++;
                //恢复中断
                local_irq_restore(flags);
                return -EBUSY;//设备忙
        }

        //恢复中断
        local_irq_restore(flags);
        printk("设备打开成功!\n");
        return 0;
      }

   4.5.linux内核解决竞态方法之自旋锁
   特点：
   1.除了中断引起的竞态问题都可以进行解决
   2.自旋锁必须附加在某个共享资源上
   3.想访问临界区而没有获取自旋锁的任务将原地空转,原地忙等待
   4.持有自旋锁的任务访问临界区时,执行速度要快,更不能做休眠操作
   总结：自旋锁保护的临界区不能进行休眠操作

   数据类型：spinlock_t

   编程操作步骤：
   1.明确驱动代码中哪些是共享资源
   2.明确驱动代码中哪些是临界区
   3.明确临界区中是否有休眠
     如果没有,可以考虑使用自旋锁
     当然还要考虑是否有中断引起的竞态,如果有,同样不能
     使用自旋锁
   4.定义自旋锁对象
     spinlock_t lock;
   5.初始化自旋锁对象
     spinlock_init(&lock);
   6.访问临界区之前先获取自旋锁
     spin_lock(&lock); //任务获取自旋锁,立马返回
                       //如果没有获取自旋锁,任务在此忙等待
   7.一旦获取自旋锁,踏踏实实的访问临界区
     注意：临界区不能进行休眠操作
   8.访问临界区之后,记得要释放自旋锁
     spin_unlock(&lock);
   9.获取锁和释放锁在逻辑上要配对使用
   参考代码：
   //定义自旋锁对象
   static spinlock_t lock;
   入口函数调用：
        spin_lock_init(&lock);
   底层驱动的led_open参考代码：
      static int open_cnt = 1; //共享资源
      static int led_open(struct inode *inode,
                                struct file *file)
      {
        unsigned long flags;
        //获取自旋锁
        spin_lock(&lock);

        //临界区
        if (--open_cnt !=0 ){
                printk("设备已被打开!\n");
                open_cnt++;
                //释放自旋锁
                spin_unlock(&lock);
                return -EBUSY;//设备忙
        }

        //释放自旋锁
        spin_unlock(&lock);
        printk("设备打开成功!\n");
        return 0;
      }

   4.6.linux内核解决竞态方法之自旋锁扩展,又称衍生自旋锁
   特点：
   1.所有的竞态问题都能够解决
   2.衍生自旋锁必须附加在某个共享资源上
   3.想访问临界区而没有获取衍生自旋锁的任务将原地空转,原地忙等待
   4.持有衍生自旋锁的任务访问临界区时,执行速度要快,更不能做休眠操作
   总结：衍生自旋锁保护的临界区不能进行休眠操作

   数据类型：spinlock_t

   编程操作步骤：
   1.明确驱动代码中哪些是共享资源
   2.明确驱动代码中哪些是临界区
   3.明确临界区中是否有休眠
     如果没有,可以考虑使用衍生自旋锁
   4.定义自旋锁对象
     spinlock_t lock;
   5.初始化自旋锁对象
     spinlock_init(&lock);
   6.访问临界区之前先获取衍生自旋锁
     unsigned long flags
     spin_lock_irqsave(&lock,flags); //先屏蔽中断然后获取自旋锁
                                     //任务获取自旋锁,立马返回
                                     //如果没有获取自旋锁,任务在此忙等待
   7.一旦获取自旋锁,踏踏实实的访问临界区
     注意：临界区不能进行休眠操作
   8.访问临界区之后,记得要释放自旋锁,再恢复中断
     spin_unlock_irqrestore(&lock,flags);
   9.获取锁和释放锁在逻辑上要配对使用
   参考代码：
   //定义自旋锁对象
   static spinlock_t lock;
   入口函数调用：
        spin_lock_init(&lock);
   底层驱动的led_open参考代码：
      static int open_cnt = 1; //共享资源
      static int led_open(struct inode *inode,
                                struct file *file)
      {
        unsigned long flags;
        //获取自旋锁
        spin_lock_irqsave(&lock, flags);

        //临界区
        if (--open_cnt !=0 ){
                printk("设备已被打开!\n");
                open_cnt++;
                //释放自旋锁
                spin_unlock_irqrestore(&lock, flags);
                return -EBUSY;//设备忙
        }

        //释放自旋锁
        spin_unlock_irqrestore(&lock, flags);
        printk("设备打开成功!\n");
        return 0;
      }
    案例：利用混杂设备驱动,实现一个LED设备只能被打开一次
    ARM测试步骤：
    insmod /home/drivers/led_drv.ko
    ls /dev/myled -lh
    /home/led_test & //启动A进程
    ps  //查看A进程的PID
    /home/led_test  //启动B进程

  4.7.linux内核解决竞态方法之信号量
  特点：
  1.本质就是解决自旋锁保护的临界区不能休眠的问题
  2.信号量又称睡眠锁,本身基于自旋锁扩展而来
  3.信号量保护的临界区可以进行休眠操作
  4.要想访问临界区的任务,而没有获取到信号量,任务将进入休眠
    状态等待信号量被释放
  5.信号量一般应用于进程

  数据类型：struct semaphore

  编程操作步骤：
  1.明确驱动中哪些是共享资源
  2.明确驱动中哪些是临界区
  3.明确临界区中是否有休眠操作
    如果有,使用信号量
    如果没有,可以考虑使用信号量
  4.定义信号量对象
    struct semaphore sema;
  5.初始化信号量为互斥信号量
    sema_init(&sema, 1);
  6.访问临界区之前获取信号量
    down(&sema);//获取信号量,如果正常获取信号量,此函数立即返回
                //如果没有获取信号量,进程将进入不可中断的休眠状态
                //代码停止不动,进程等待被唤醒,唤醒的方法是正在获取
                  信号量的任务释放信号量,同时也会唤醒这个休眠的进程
                //A获取信号量,B进程在此进入不可中断的休眠状态(睡眠期间不会立即响应和处理信号)
                //A释放信号量,同时唤醒B,B进程被唤醒以后,需要处理之前接受到的信号
    或者
    down_interruptible(&sema);//获取信号量,如果正常获取信号量,此函数立即返回
                //如果没有获取信号量,进程将进入可中断的休眠状态
                //代码停止不动,进程等待被唤醒,唤醒的方法是有两种：
                  1.获取信号量的任务进行唤醒
                  2.接收到了信号进行唤醒
                //A获取信号量,B进程在此进入可中断的休眠状态(睡眠期间会立即响应和处理信号)
                //A释放信号量,同时唤醒B

  7.一旦获取信号量成功,踏踏实实的访问临界区
  8.访问完毕,记得要释放信号量
    up(&sema); //不仅仅会释放信号量,还要唤醒之前休眠的进程

  案例：利用信号量,实现一个LED设备只能被打开一次
  采用down来获取信号量
  强调：
  1.如果没有获取信号量,进程进入不可中断的休眠状态(休眠期间不会立即响应和处理信号)
  2.此休眠进程被唤醒的方法只有1个：
    只能由A进程释放信号量时唤醒此休眠的进程
    此进程一旦被唤醒,还要处理之前接受到的信号
  ARM实验步骤：
  insmod /home/drivers/led_drv.ko
  /home/drivers/led_test & //启动A进程
  /home/drivers/led_test & //启动B进程
  ps //查看A,B的PID
  top //查看A,B进程的状态,按Q键退出top命令
      S:可中断的休眠状态
      D:不可中断的休眠状态
      R:运行状态

  kill B进程的PID  //向休眠中的B进程发送信号
  ps //查看B是否被干掉
  kill A进程的PID //杀死A进程,A进程释放信号量,唤醒B进程

  /home/drivers/led_test & //启动A进程
  /home/drivers/led_test & //启动B进程
  ps //查看A,B的PID
  top //查看A,B进程的状态,按Q键退出top命令
  kill A进程的PID  //杀死A进程,A进程释放信号量,唤醒B进程
  top //查看B进程的状态信息
  kill B进程PID
      结果是:D->S(应用调用sleep)


  采用down_interruptible来获取信号量
  强调：
  1.没有获取信号量,进程进入可中断的休眠状态
  2.可中断的休眠状态表示休眠期间可以响应处理接收到的信号
  3.可中断休眠进程被唤醒的方法：
    1.通过信号唤醒
    2.通过A进程释放信号量唤醒
 insmod /home/drivers/led_drv.ko
  /home/drivers/led_test & //启动A进程
  /home/drivers/led_test & //启动B进程
  ps //查看A,B的PID
  top //查看A,B进程的状态,按Q键退出top命令
      S:可中断的休眠状态
      D:不可中断的休眠状态
      R:运行状态

  kill B进程的PID  //向休眠中的B进程发送信号
  ps //查看B是否被干掉
  kill A进程的PID //杀死A进程,A进程释放信号量,唤醒B进程

  /home/drivers/led_test & //启动A进程
  /home/drivers/led_test & //启动B进程
  ps //查看A,B的PID
  top //查看A,B进程的状态,按Q键退出top命令
  kill A进程的PID  //杀死A进程,A进程释放信号量,唤醒B进程
  top //查看B进程的状态信息
  kill B进程PID
      结果是:D->S(应用调用sleep)

回顾：
1.linux内核中断编程
  面试题：谈谈对中断的理解
  1.为什么有中断机制
    举例子
  2.中断的硬件连接
    画图
  3.中断的处理过程
    画图
  4.中断的软件编程
    四部曲
  5.linux内核中断编程
    目标：只需向内核注册硬件中断的中断处理函数即可
    大名鼎鼎函数：requeset_irq/free_irq
    int request_irq(中断号,中断处理函数,中断标志,中断名称,给中断处理函数传递的参数)
    void free_irq(中断号,传递参数)
  6.linux内核中断编程的注意事项
    中断不隶属于任何进程,不参与进程调度
    硬件中断>软中断>进程
    要求中断处理函数执行的速度越快越好,目的提高系统的相应能力和并发能力
    更不能进行休眠操作
    问：有些场合无法满足这种要求,此时可以考虑使用内核提供的顶半部和底半部机制来优化
  7.中断编程顶半部和底半部机制
    这种机制的本质目的就是及时释放CPU资源,让其他高优先级的
    任务及时获取到CPU资源,投入运行;
    底半部机制本质就是延后执行,就是将不重要的事情往后拖延,以后去执行
    底半部并不一定非要和顶半部配合使用

    顶半部本质就是中断处理函数,紧急,耗时较短的内容,不可被中断
    底半部执行不紧急,耗时较长的内容,可以中断
    画图

    底半部实现方法：
        tasklet
        工作队列
        软中断
  8.底半部实现方法之tasklet
    特点：
    中断上下文：就是中断的整个处理的过程(跳转到异常向量表,保护现场,执行中断处理函数,恢复现场)
    进程上下文：就是进程的整个处理的过程(进程的创建,调度,抢占,进程休眠,进程的唤醒,进程的退出)
    基于软中断实现,优先级高于进程低于硬件中断,延后处理函数不能进行休眠操作
    tasklet延后处理函数工作在中断上下文
    本质是延后执行的一种手段

    数据结构：
    struct tasklet_struct
        .function //延后处理函数,一旦登记完成,内核会在适当的时候去执行
                    不能进行休眠操作
        .data //给延后处理函数传递的参数

    配套函数：
    DECLARE_TASKLET(name,func,data)//定义初始化对象
    tasklet_schedule(&name);//登记延后处理函数

  9.底半部实现方法之工作队列
  1.特点：
    工作队列的延后处理函数工作在进程上下文,所以此函数可以进行
    休眠操作,参与进程之间的调度
    优先级低于中断
    工作队列的本质也是延后执行的一种手段
    总结：
    延后执行的内容中如果有休眠操作必须使用工作队列
    延后执行的内容中没有休眠,三种方法都可以使用,但是如果考虑
    到效率问题,使用tasklet或者软中断

  2.数据结构
    struct work_struct {
        void (*function)(struct work_struct *work);
        ...
    };
    function:工作队列的延后处理函数,工作在进程上下文,所以可以进行
             休眠操作
             形参work指针指向驱动自己定义初始化的工作对象
    问：工作队列如何给延后处理函数传递参数呢？
    答：认真自行研究内核大名鼎鼎的宏：container_of

    配套函数：
    //给工作对象添加一个延后处理(初始化对象)
    INIT_WORK(&工作对象名,延后处理函数);
    schedule_work(&工作对象名); //向内核登记工作的延后处理函数
    一旦登记完成,内核会在适当的时候去执行此函数

    编程步骤：
    1.定义工作对象
      struct work_struct work;
    2.初始化工作对象,添加延后处理函数
      INIT_WORK(&work, xxx_work_function);
    3.在适当的位置进行登记延后处理函数
      schedule_work(&work);
      总结：
      如果有顶半部,一般在顶半部登记
      如果没有顶半部,何时何地登记随意

    案例：利用工作队列,"优化"按键驱动
          打印按键信息放在底半部工作队列的延后处理函数中执行

  10.底半部实现方法之软中断(了解)
  特点：
  1.软中断的延后处理函数工作在中断上下文中,不能进行休眠操作
  2.tasklet基于软中断实现
  3.软中断的延后处理函数可以同时运行在多个CPU上,但是tasklet
    的延后处理函数只能运行在一个CPU上;
    所以软中断的延后处理函数必须具备可重入性(可重入函数)
    int g_data
    swap1(int *a, int *b)
    {
        g_data = *b;
        *b = *a;
        *a = g_data;
    } //不具有可重入性

    swap2(int *a, int *b)
    {
        int data;

        data = *b;
        *b = *a;
        *a = data;
    } //具有可重入性
    总结：
    1.尽量避免访问全局变量
    2.如果要访问全局变量,要注意互斥访问,但是代码的执行效率
      降低
  4.软中断代码的实现过程不能采用insmod/rmmod动态加载和卸载
    只能静态编译到内核中(zImage,在一起),不便于代码的维护
  5.软中断的本质就是延后执行

2.linux内核软件定时器
  2.1.了解计算机的硬件定时器
  特点：一旦上电,硬件定时器周期性的按照一定的频率给CPU发送中断信号
        这个中断又称时钟中断,或者定时器中断;
        中断触发的频率可以软件编程设置！

  2.2.了解linux内核对应的定时器中断的中断处理函数
  1.此函数由内核已经实现好
    cd /opt/kernel
    vim arch/arm/mach-s5pv210/mach-cw210.c
    .init_timer=sys_timer //跟踪进入找到对应的中断处理函数
  2.此函数会周期性,按照一定的频率被内核调用
  3.此函数将做一下几个事情：
    1.更新系统的运行时间
    2.更新系统的实际时间(又称wall time)
    3.检查进程的时间片是否用尽,决定是否启动调度
    4.检查内核是否有超时的软件定时器,如果有超时的软件定时器
      内核调用超时的软件定时器的超时处理函数
    5.统计的CPU利用率,内存的使用率等等系统资源

  2.3.linux内核中时间相关概念
    1.HZ
      内核常量,ARM架构HZ=100,X86架构HZ=1000
      例如HZ=100,表示硬件定时器1秒钟给CPU发送100个定时器中断信号
      每发生一次中断的时间间隔为10ms
    2.jiffies_64,jiffies
      jiffies_64是内核全局变量,64位,unsigned long long,
      记录自开机以来发生了多少次的定时器中断,每发生一次,"自动"加1

      jiffies也是内核全局变量,32位,unsigned long,值取得jiffies_64
      的低32位，每发生一次定时器中断,同样"自动"加1,一般用来
      记录流失时间(时间间隔)
      注意：只要在内核代码中看到jiffies,就等于此刻为当前时间

      参考代码：
      unsigned long timeout = jiffies + 5*HZ;
      说明：
      jiffies:表示当前时间
      5*HZ:时间间隔为5秒
      timeout:表示5秒以后的时间,也就是超时时间

      参考代码：判断是否超时
      unsigned long timeout = jiffies + 5*HZ;
      ...
      ...
      ... //若干条代码,代码执行需要时间
      if (jiffies > timeout)
        超时
      else
        没有超时

      解决方法：
      if(time_after(jiffies, timeout)) {
        超时
      } else {
        没有超时
      }//此函数无需记忆,只需看大神如何判断即可

  2.4.linux内核软件定时器
  特点：
  1.内核软件定时器基于软中断实现
  2.内核软件定时器对应的超时处理函数不能进行休眠操作
  3.内核软件定时器到期以后,内核会调用对应的超时处理函数完成某个用户的业务

  数据结构:
  struct timer_list {
        unsigned long expirs; //超时时候的时间,例如超时时间间隔为5s
                                expires = jiffies + 5*HZ;
        void (*function)(unsigned long data) //超时处理函数,不能进行休眠操作
        unsigned long data; //给超时处理函数传递的参数,一般传递指针
        ...
  };

  配套函数：
  init_timer(&定时器对象);//初始化定时器对象
  add_timer(&定时器对象);//向内核注册添加一个定时器对象
                           一旦添加完毕,内核开始对此定时器进行倒计时
                           超时时间到期,内核调用对应的超时处理函数,并且
                           内核将定时器对象从内核中删除
  del_timer(&定时器对象); //删除定时器
  mod_timer(&定时器对象, 新的超时时候的时间);//修改定时器
  此函数等价于一下三步骤：
  1.先删除之前的定时器del_timer
  2.在修改新的超时时间expires = ....
  3.重新添加定时器add_timer

  编程步骤：
  1.定义定时器对象
    struct timer_list mytimer;
  2.初始化定时器对象
    init_timer(&mytimer);
    //需要额外自己初始化以下三个字段：
    expires = jiffies + 5*HZ;
    function = mytimer_function;
    data = (unsigned long)&...;
  3.注册定时器对象到内核
    add_timer(&mytimer);
  4.不再使用定时器删除
    del_timer(&mytimer);
  5.mod_timer(&mytimer, jiffies + 20*HZ);

  案例1：利用定时器,实现每隔2000ms打印一句话
  案例2：利用定时器,实现每隔2000ms开关灯
  案例3：利用定时器,实现能够动态修改灯的闪烁频率,例如100ms
         500ms，1000ms，2000ms,提示不允许使用字符设备驱动和
         混杂设备驱动编程框架,只需采用内核程序的命令行传参实现即可
         驱动加载以后,灯的闪烁频率可以修改
         提示：module_param(name,type,权限);
         提示：毫秒ms转中断触发的次数
         msecs_to_jiffies(毫秒数);
         注意：不允许使用if...else判断

3.linux内核延时方法
  linux内核延时分两种：忙延时和休眠延时
  "忙延时"：CPU原地空转,打转,应用在等待延时极短的场合
            中断和进程都可以使用忙延时
  "休眠延时"：当前进程释放所占用的CPU资源给其他任务使用
              仅适用于进程,延时时间比较长的场合

  忙延时的函数：
  ndelay(纳秒数);//纳秒级延时
  例如：ndelay(100);//忙延时100纳秒

  udelay(微秒数);
  例如：udelay(100); //忙延时100微秒

  mdelay(毫秒数);
  例如：mdelay(5); //忙延时5毫米
  注意：如果忙延时的时间超过10ms,建议采用休眠延时

  休眠延时的函数：
  msleep(毫秒数);
  例如：msleep(20); //休眠延时20毫秒

  ssleep(秒数);
  例如：ssleep(20);

  schedule(); //永久性休眠

  scheudle_timeout(5*HZ); //休眠延时5秒

*********************************************************
4.linux内核并发和竞态相关内容
面试题：谈谈进程间通信的方法
案例：要求一个LED设备只能被打开一次
分析实现过程：
方案1:应用层实现
      采用进程间通信机制,实现多个进程之间通信决定是否打开设备
      A打开,B问A,C问A...
      缺点：不太灵活

方案2:驱动层实现
      明确：不管应用层有多少进程,访问设备永远先open
      它们最终都会调用底层驱动的led_open,只需在底层驱动的
      led_open代码中做相关的限定即可
      ”一夫当关万夫莫开“

      底层驱动的led_open参考代码：
      static int open_cnt = 1;
      static int led_open(struct inode *inode,
                                struct file *file)
      {
        if (--open_cnt !=0 ){
                printk("设备已被打开!\n");
                open_cnt++;
                return -EBUSY;//设备忙
        }
        printk("设备打开成功!\n");
        return 0;
      }
      static int led_close(struct inode *inode,
                                struct file *file)
      {
        open_cnt++;
        return 0;
      }

    代码分析：研究代码片段if (--open_cnt !=0 )
    汇编访问变量：
    ldr 加载
    sub 运算
    str 存储
    正常情况：
    A进程打开设备：
        读取：open_cnt=1
        修改,写回：open_cnt=0
        结果：打开设备成功

    B进程打开设备：
        读取：open_cnt=0
        修改，写回：open_cnt=-1
        结果：打开设备失败

    异常情况：
    A进程先打开：
        读取:open_cnt=1
    就在此时此刻,并且由于linux系统允许进程之前进行抢占(进程有优先级之分)
    高优先级的B进程开始投入运行,并且此时抢占A进程的CPU资源,B进程开始执行：

    B进程开始执行：
        读取：open_cnt=1
        修改,写回：open_cnt=0
        结果：打开设备成功
        B进程执行完毕,B进程释放CPU资源给A进程,A进程继续执行

    A进程继续执行：
        修改,写回：open_cnt=0
        结果：打开设备成功

    结论：
    1.发生这种抢占的概率极其之低
    2.产生这种异常的根本原因是linux系统进程与进程的抢占
      linux内核允许进程进行抢占而提高系统的实时性
      高优先级的进程抢占低优先级的进程的CPU资源
      本质：还是优先级问题
    3.问：linux内核中产生类似以上异常的情况还有哪些？
      答：
      1.进程与进程之间的抢占
      2.中断和进程
      3.中断和中断
      4.SMP


回顾：
1.linux内核字符设备驱动开发相关内容
  1.1.设备文件
      /dev/
      mknod
      三个保证+四个函数
      系统调用函数
  1.2.设备号
      dev_t
      MKDEV
      MAJOR
      MINOR
      主设备号
      次设备号
      资源
      申请
      释放
  1.3.字符设备驱动数据类型
      struct cdev
      配套函数
      cdev_init
      cdev_add
      cdev_del
  1.4.硬件操作接口数据类型
      struct file_operations
      open
      release
      read
      write
        注意：buf
      unlocke_ioctl
        注意：arg
  1.5.内存拷贝函数
      copy_from_user
      copy_to_user
  1.6.设备文件自动创建
      三个保证
      四个函数
  1.7.两个额外数据结构
      struct inode
        .i_rdev
      struct file
      inode和file关系：fbmem.c

2.linux内核混杂设备驱动开发相关内容
  本质还是字符设备
  主设备号为10
  通过次设备号区分
  数据结构：
  struct miscdevice
        .minor = MISC_DYNAMIC_MINOR->让内核分配次设备号
        .name  = 内核帮你创建设备文件
        .fops  = 硬件操作接口
  配套函数：
  misc_register
  misc_deregister

3.linux内核中断编程
  面试题：谈谈对中断的理解
  3.1.计算机为什么有中断机制
  由于计算机硬件层面来讲由CPU和外设组成,CPU需要跟外设进行不断的
  数据通信,又由于外设的处理速度远远慢于CPU的处理速度,CPU为了
  保证访问外设时的数据正常,一般会想到采用轮询方式(死等,CPU不能
  干别的其他事情),最终降低CPU的利用率,让功耗提高;对于这种情况
  可以考虑使用中断机制,这里以CPU读取UART数据为例：
  CPU读取UART数据时(接收缓冲区寄存器),当发现数据没有准备
  就绪,CPU可以去干其他别的事情(处理某个进程),一旦UART接收缓冲区
  有数据,UART控制器会给CPU发送一个中断信号(嗨,我这有数了),
  CPU一旦接收到这个中断信号,CPU停止手头的工作,转去读取UART数据
  读取完毕,CPU继续接着执行原先被打断的工作,提高了CPU的利用率

  3.2.中断的硬件触发过程和硬件连接
  明确：外设产生的中断信号不会直接送达CPU,而是要经过
        中断控制器的处理以后再由中断控制器决定是否送达
        给CPU一个中断信号(IRQ/FIQ)
  画出一个简要的中断硬件连接图
  外设和中断控制的中断线分两类：
  外设中断：中断线可以有原理图来调整(肉眼能看到)
  内部中断：中断线不可修改(集成处理器内部,肉眼看不到)

  中断控制器的功能：
  1.能够使能或者禁止某个外设中断信号
  2.能够配置外设中断信号将来以IRQ还是FIQ发给CPU
  3.能够设置外设中断的优先级
  4.能够设置外设中断信号的有效触发方式
    高电平触发
    低电平触发
    上升沿触发
    下降沿触发
    双边沿触发

  以按键为例,谈谈中断电信号的触发流程：
  按键没有操作,中断线为高电平,按键按下,中断线上有一个下降沿
  电信号,此电信号自动跑到中断控制器,中断控制经过一番的判断
  如果合适,中断控制器最终给CPU发送一个中断信号,这个过程都是
  硬件自动完成,一旦CPU接收到中断电信号,CPU开启中断异常的处理
  流程：
  ARM核硬件将完成：
  1.备份CPSR到SPSR_IRQ/FIQ
  2.设置CPSR
    MODE
    T
    I
    F
  3.保存返回地址lr_irq/fiq=pc-4
  4.设置PC为中断异常处理入口
    pc=0x18
    或者
    pc=0x1c
  5.进入了异常向量表的中断处理入口,开启软件的中断异常处理
  6.中断的软件处理过程：
    实现编写好异常向量表的代码
    保护现场
    处理中断处理函数
    恢复现场

  3.3.画图展示中断的处理流程
  具体参见int.bmp

  3.4.中断编程步骤
  明确：不管是ARM裸板程序还是带操作系统的程序,中断编程必须一致
  中断编程四步骤：
  1.编写异常向量表的代码
  2.编写保存现场的代码
  3.编写中断处理函数
    具体内容如何实现,严格按照用户的需求来定
  4.编写恢复现场的代码

  明确：不管是ARM裸板还是在linux系统下,1,2,4三步骤都是由
        ARM公司或者linux内核已经帮你实现！第3步必须由程序员
        根据用户的需求来完成！

  问：linux内核驱动如何添加一个外设的中断处理函数呢？
      一旦中断处理函数添加完成,将来外设产生中断,内核
      就会最终调用此中断处理函数,完成用户的业务需求！
  答：利用大名鼎鼎的request_irq函数即可完成向内核添加注册
      一个外设的中断处理函数！

  3.5.大名鼎鼎的request_irq函数详解
  函数原型：
  int request_irq(unsigned int irq,
                   irq_handler_t handler,
                   unsigned long flags,
                   const char *name,
                   void *dev_id)
  功能：
  1.向内核申请硬件中断资源
  2.向内核注册硬件中断对应的中断处理函数

  参数：
  irq:硬件中断对应的内核软件编号(类似身份证号),又称中断号
      以宏的形式表示
      例如：
      硬件中断       中断号
      XEINT0	     IRQ_EINT(0)
      XEINT1	     IRQ_EINT(1)
      ......	     ....
      XEINT10	     IRQ_EINT(10)

 handler:中断处理函数,只需将中断处理函数地址传递过来即可
         一旦注册中断处理函数到内核,将来硬件触发中断
         内核就会调用此函数
         中断处理函数的原型：
         irqreturn_t 中断处理函数名(int irq, void *dev_id)
         irq:当前触发的硬件中断对应的中断号
         dev_id:给中断处理函数传递的参数信息
                建议参数使用时,数据类型进行强转

 flags:中断标志
       对于外部中断,中断标志：
       IRQ_TRIGGER_FALLING:
       IRQ_TRIGGER_RISING:
       IRQ_TRIGGER_HIGH:
       IRQ_TRIGGER_LOW:
       设置有效的触发方式
       可以做位或操作

       对于内部中断,给0即可,通过配置控制器内部寄存器
       实现有效的中断触发方式配置
 name：中断名称
       通过cat /proc/interrupts查看此名称

 dev_id:给中断处理函数传递的参数
        想想pthread_create

 void *thread_func(void *arg)
 {
        int *p = (int *)arg;

        printf("g_data = %#x\n", *p);
 }

 int g_data = 0x55;
 pthread_create(&id, NULL, thread_func, &g_data);


 中断不再使用时,记得要删除中断处理函数和释放资源
 free_irq(int irq, void *dev_id)
 irq:中断号
 dev_id:给中断处理函数传递的参数,切记注册中断处理函数
        传递的参数务必要和释放传递的参数要一致！

 案例：采用中断方式,编写按键驱动,实现按键按下或者松开打印
       按键的信息
 实施步骤：
 先卸载官方的按键驱动：
 cd /opt/kernel
 make menuconfig
   Device Drivers->
        Input devices supports->
                Keyboards->
                   <*> S3c gpio keypads support... //去掉
 保存退出
 make zImage
 cp arch/arm/boot/zImage /tftpboot
 用新zImage重启开发板

 mkdir /opt/drivers/day05/1.0 -p
 cd /opt/drivers/day05/1.0
 vim btn_drv.c
 vim Makefile
 make
 cp btn_drv.ko /opt/rootfs/home/drivers/

 ARM测试：
 insmod /home/drivers/btn_drv.ko
 cat /proc/interrupts //查看中断注册的信息
            CPU0
 16:         63    s3c-uart  s5pv210-uart
 18:         98    s3c-uart  s5pv210-uart
 32:          0  s5p_vic_eint  KEY_UP
 33:          0  s5p_vic_eint  KEY_DOWN
 ...	    ...    ...          ...
 第一列：中断号,例如IRQ_EINT(0)=32
 第二列：中断触发次数
 第三列：中断类型
 第四列：中断名称

 按下或者松开按键查看打印信息
 cat /proc/interrupts //查看中断的触发次数

4.linux内核中断编程之顶半部和底半部机制
  4.1.明确相关概念
  linux系统,CPU软件层面一天到晚做两类事：进程和中断,哪个要想运行,必须先获取到CPU资源
  “任务”：包括进程和中断
  “休眠”：仅存在进程的世界里,进程休眠只是当前进程会释放所占用的CPU资源给
          其他任务使用,中断是不允许休眠操作
  “优先级”：衡量一个任务获取CPU的一种能力,优先级越高,获取CPU资源的能力就越强
  中断分两类：硬件中断和软中断
  中断不隶属于任何进程,不参与进程之间的调度
  前提是在linux系统,任务优先级的划分：
  硬件中断优先级大于软中断
  软中断的优先级大于进程
  软中断有优先级之分
  进程有优先级之分
  硬件中断无优先级之分

  4.2.切记：linux内核要求中断处理函数的执行速度越快越好,其他
      任务就能够及时获取到CPU资源
      注意：中断处理函数更不能做休眠操作
      如果中断处理函数长时间占用CPU资源,会影响系统的并发能力
      和响应能力！

      问：有些场合,中断处理函数势必会长时间占用CPU资源
          也会势必影响系统的并发和响应能力,怎么办？
      答：通过中断编程之顶半部和底半部机制进行优化
          将原先的中断处理函数一分为二,分别是顶半部和
          底半部

  4.3.顶半部特点
  本质上就是中断处理函数,也就是一旦硬件产生中断,内核首先
  执行顶半部的内容(内核首先调用中断处理函数)；
  此时的中断处理函数和原中断处理函数不一样,此时的中断处理函数
  会做原先中断处理函数中比较紧急,耗时较短的内容,一旦执行完毕
  快速释放CPU资源给其他任务使用！

  顶半部执行期间不允许被打断,不允许发生CPU资源的切换！

  4.4.底半部特点
  底半部要执行原先中断处理函数中不紧急,耗时较长的内容;
  CPU会在"适当的时候"会去执行底半部的内容;
  由于它不紧急,所以如果来了高优先级的任务同样可以打断底半部的
  执行过程,允许CPU资源发生切换

  4.5.底半部实现方法：三种
      tasklet
      工作队列
      软中断

  4.6.底半部机制之tasklet特点
  1.本质就是延后执行的一种手段
  2.tasklet对应的延后处理函数,此函数中原先中断处理函数中
    不紧急,耗时较长的内容
  3.tasklet是基于软中断实现,优先级高于进程,低于硬件中断
    所以tasklet延后处理函数不能进行休眠操作
  4.tasklet的数据结构
    struct tasklet_struct {
        void (*function)(unsigned long data);
        unsigned long data;
        ...
    };
    成员：
    function:tasklet的延后处理函数,做不紧急,耗时较长的内容
             不能进行休眠操作
             形参data保存是给延后处理函数传递的参数,一般传递
             参数的指针,注意数据类型的转换
    data：就是给延后处理函数传递的参数

    配套函数：
    DECLARE_TASKLET(name,func,data);
    功能：定义初始化tasklet对象
    name:tasklet对象名
    func:tasklet延后处理函数地址
    data:给延后处理函数传递的参数

    tasklet_schedule(&tasklet对象);
    功能：向内核登记tasklet延后处理函数,一旦登记完成,内核
          会在"适当的时候"去执行对应的延后处理函数
    如果驱动中有顶半部(中断处理函数),一般在顶半部的代码中
    调用登记即可；
    如果驱动中没有顶半部,依据实际的硬件操作需求进行调用登记
    即可！
    一旦登记完成,内核就会在适当的时候去执行！

    最后编写好延后处理函数即可

    切记：tasklet基于软中断实现,所以延后处理函数执行速度尽量快
          更不能做休眠操作

    案例：利用tasklet"优化"按键驱动

回顾：
1.linux内核字符设备驱动相关内容
  1.1.理念
  1.2.字符设备文件
      c
      主设备号
      次设备号
      设备文件名
      mknod
      仅仅在open时使用
  1.3.设备号
      dev_t
      12
      20
      MKDEV
      MAJOR
      MINOR
      宝贵资源
      alloc_chrdev_region
      unregister_chrdev_region
      主设备号：应用找到驱动
      次设备号：驱动分区硬件个体
  1.4.linux内核描述字符设备驱动数据结构
      struct cdev
        .dev
        .count
        .ops
      配套函数：
      cdev_init
      cdev_add
      cdev_del

  1.5.字符设备驱动描述硬件操作接口的数据结构
      struct file_operations {
        .open
        .release
        .read
        .write
      };
      open/release:可以根据用户的实际需求不用初始化
                   应用程序open/close永远返回成功
      read:
        1.分配内核缓冲区
        2.获取硬件信息将信息拷贝到内核缓冲区
        3.拷贝内核缓冲区数据到用户缓冲区
      write:
        1.分配内核缓冲区
        2.拷贝用户缓冲区数据到内核缓冲区
        3.拷贝内核缓冲区到硬件

      注意：第二个形参buf:保存用户缓冲区的首地址,驱动不能直接
                      访问,需要利用内存拷贝函数
      copy_from_user/copy_to_user

2.linux内核字符设备驱动硬件操作接口之ioctl
  2.1.掌握ioctl系统调用函数：
  函数原型：
  int ioctl(int fd, int request, ...);
  函数功能：
  1.不仅仅能够向设备发送控制命令(例如开关灯命令)
  2.还能够跟硬件设备进行数据的读写操作

  参数：
  fd：设备文件描述符
  request:向设备发送的控制命令,命令需要自己定义
          例如：
          #define LED_ON   (0x100001)
          #define LED_OFF  (0x100002)
  ...:如果应用程序要传递第三个参数,第三个参数要传递用户缓冲区
      的首地址,将来底层驱动可以访问这个用户缓冲区的首地址
      同样底层驱动不能直接访问,需要利用内存拷贝函数
  返回值：成功返回0，失败返回-1
  参考代码：
  //传递两个参数：
  //开灯
  ioctl(fd, LED_ON);
  //关灯
  ioctl(fd, LED_OFF);
  说明：仅仅发送命令

  //传递三个参数：
  //开第一个灯：
  int uindex = 1;
  ioctl(fd, LED_ON, &uindex);

  //关第一个灯：
    int uindex = 1;
  ioctl(fd, LED_OFF, &uindex);
  说明：不仅仅发送命令,还传递用户缓冲区的首地址,完成和设备的读或者写

  2.2.ioctl对应的底层驱动的接口
  回忆C编程：
  int a = 0x12345678;
  int *p = &a;
  printf("a = %#x\n", *p);
  等价于：
  unsigned long p = &a;
  printf("a = %#x\n", *(int *)p);

  ioctl对应的底层驱动的接口
  struct file_operations {
        long (*unlocked_ioctl)(struct file *file,
                                unsigned int cmd,
                                unsigned long arg)
  };
  调用关系：
  应用ioctl->C库ioctl->软中断->内核sys_ioctl->驱动unlocked_ioctl接口
  接口功能：
  1.不仅仅向设备发送控制命令
  2.还能够和设备进行数据的读或者写操作
  参数：
  file：文件指针
  cmd:保存用户传递过来的参数,保存应用ioctl的第二个参数
  arg：如果应用ioctl传递第三个参数,arg保存用户缓冲区的
       首地址,内核不允许直接直接访问(int kindex=*(int *)arg)
       需要利用内存拷贝函数,使用时注意数据类型的转换

  案例：利用ioctl实现开关任意一个灯
  实施步骤：
  虚拟机执行：
  mkdir /opt/drivers/day04/1.0 -p
  cd /opt/drivers/day04/1.0
  vim led_drv.c
  vim Makefile
  vim led_test.c
  make
  arm-linux-gcc -o led_test led_test.c
  cp led_drv.ko led_test /opt/rootfs/home/drivers

  ARM执行：
  insmod /home/drivers/led_drv.ko
  cat /proc/devices
  mknod /dev/myled c 主设备号 0
  /home/drivers/led_test on 1
  /home/drivers/led_test on 2
  /home/drivers/led_test off 1
  /home/drivers/led_test off 2

3.linux内核字符设备驱动之设备文件的自动创建
  3.1.设备文件手动创建
      mknod /dev/设备文件名  c  主设备号  次设备号
  3.2.设备文件自动创建实施步骤：
  1.保证根文件系统rootfs具有mdev可执行程序
    mdev可执行程序将来会帮你自动创建设备文件
    which is mdev
    /sbin/mdev
  2.保证根文件系统rootfs的启动脚本etc/init.d/rcS必须有
    以下两句话：
    /bin/mount -a
    echo /sbin/mdev > /proc/sys/kernel/hotplug
    说明：
    /bin/mount -a:将来系统会自动解析etc/fstab文件，进行
                  一系列的挂接动作
    echo /sbin/mdev > /proc/sys/kernel/hotplug：将来驱动
    创建设备文件时,会解析hotplug文件,驱动最终启动mdev来帮
    驱动创建设备文件
  3.保证根文件系统rootfs必须有etc/fstab文件,文件内容如下：
    proc           /proc        proc   defaults 0 0
    sysfs          /sys         sysfs  defaults 0 0
    将/proc,/sys目录分别作为procfs,sysfs两种虚拟文件系统
    的入口,这两个目录下的内容都是内核自己创建,创建的内存
    存在于内存中
  4.驱动程序只需调用以下四个函数即可完成设备文件的自动
    创建和自动删除
    struct class *cls; //定义一个设备类指针
    //定义一个设备类,设备类名为tarena(类似长树枝)
    cls = class_create(THIS_MODULE, "tarena");
    //创建设备文件(类似长苹果)
    device_create(cls, NULL, 设备号, NULL, 设备文件名);
    例如：
    //自动在/dev/创建一个名为myled的设备文件
    device_create(cls, NULL, dev, NULL, "myled");

    //删除设备文件(摘苹果)
    device_destroy(cls, dev);

    //删除设备类(砍树枝)
    class_destroy(cls);

    案例：在ioctl实现的设备驱动中添加设备文件自动创建功能

4.linux内核字符设备驱动之通过次设备号区分硬件个体
  4.1.明确：多个硬件设备个体可以作为一个硬件看待,驱动也能够
            通过软件进行区分
  4.2.实现思路：
  1.驱动管理的硬件特性相似
    四个UART,Nand的多个分区
    不能把LED,按键放在一起
  2.主设备号为一个,驱动为一个,驱动共享
    cdev共享
    file_operations共享
    .open
    .read
    .write
    .release
    .unlocked_ioctl
    都共享
  3.多个硬件个体都有对应的设备文件
  4.驱动通过次设备号区分,次设备号的个数和硬件个体的数据一致

  4.3.了解两个数据结构：struct inode, struct file
  struct inode {
        dev_t	i_rdev; //保存设备文件的设备号信息
        struct cdev *i_cdev; //指向驱动定义初始化的字符设备对象led_cdev
        ...
  };
  作用：描述一个文件的物理上的信息(文件UID,GID,时间信息,大小等)
  生命周期：文件一旦被创建(mknod),内核就会创建一个文件对应的inode对象
            文件一旦被销毁(rm),内核就会删除文件对应的inode对象
  注意：struct file_operations中的open,release接口的第一个
  形参struct inode *inode,此指针就是指向内核创建的inode对象
  所以,驱动可以通过inode指针获取到设备号信息：inode->i_rdev

  struct file {
        const struct file_operations *f_op;//指向驱动定义初始化的硬件操作接口对象led_fops
        ...
  };
  作用：描述一个文件被打开以后的信息
  生命周期：一旦文件被成功打开(open),内核就会创建一个file对象来描述
            一个文件被打开以后的状态属性
            一旦文件被关闭(close),内核就会销毁对应的file对象

  总结：一个文件只有一个inode对象,但是可以有多个file对象
  切记：通过file对象指针获取inode对象指针的方法：
  内核源码：fbmem.c
  struct inode *inode = file->f_path.dentry->d_inode;
  提取次设备号：
  int minor = MINOR(inode->i_rdev);

  案例：编写设备驱动,实现通过次设备号来区分两个LED
  mknod /dev/myled1 c  250 0
  mknod /dev/myled2 c  250 1

**********************************************************
二.linux内核混杂设备驱动开发相关内容
1.概念
  混杂设备本质还是字符设备,只是混杂设备的主设备号由内核已经
  定义为,为10,将来各个混杂设备个体通过次设备号来进行区分
2.混杂设备驱动的数据结构
  struct miscdevice {
        int minor;
        const char *name;
        const struct file_operations *fops;
        ...
  };
  minor:混杂设备对应的次设备号,一般初始化时指定
        MISC_DYNAMIC_MINOR,表明让内核帮你分配一个次设备号
  name:设备文件名,并且设备文件由内核帮你自动创建
  fops：混杂设备具有的硬件操作接口

  配套函数：
  misc_register(&混杂设备对象);//注册混杂设备到内核
  misc_deregister(&混杂设备对象);//卸载混杂设备

案例：利用混杂设备实现LED驱动,给用户提供的接口为ioctl
同上
vim分屏显示：
进入vim的命令行模式输入：
vs 文件名 //左右分屏
sp 文件名 //上下分屏
屏幕切换：ctrl+ww

回顾：
笔试题：自己编写一个strcmp或者stcpy函数
内核源码/lib/string.c提供相关的参考代码

1.linux内核设备驱动开发相关基础内容
  1.1.用户空间和内核空间
  1.2.linux内核程序编程基本框架
  1.3.linux内核程序编译
  1.4.linux内核程序操作
  1.5.linux内核程序命令行传参
  1.6.linux内核程序符号导出
  1.7.linux内核程序打印函数printk
  1.8.linux内核GPIO操作库函数
  1.9.linux内核系统调用实现过程

2.linux内核字符设备驱动开发相关内容
  2.1.linux系统理念
  2.2.linux设备驱动分类
  2.3.设备文件
      字符设备文件
      块设备文件
      /dev/
      包含主，次设备号
      mknod
      利用系统调用函数进行访问
  2.4.设备号
      包括主，次设备号
      dev_t
      12
      20
      MKDEV
      MAJOR
      MINOR
      主设备号：应用根据主设备号找驱动
      次设备号：驱动根据次设备号区分硬件个体
      设备号是一种宝贵的资源
      申请：alloc_chrdev_region
      释放：unregister_chrdev_region

  2.5.linux内核描述字符设备驱动的数据结构
      struct cdev {
        dev_t dev; //保存申请的设备号
        int count; //保存硬件设备的个数
        const struct file_operations *ops;//保存字符设备驱动具有硬件操作接口
        ...
      };

      linux内核字符设备驱动的硬件操作接口的数据结构:
      struct file_operations {
        int (*open) (struct inode *, struct file *);
        int (*release) (struct inode *, struct file *);
        ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
        ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
        ...
      };
 2.6.问：如何实现一个字符设备驱动程序呢？
     答：编程步骤是定死的！
     具体编程步骤：
     1.定义初始化一个struct file_operations硬件操作接口对象
     2.定义初始化一个struct cdev字符设备对象
       cdev_init用来初始化字符设备对象
     3.调用cdev_add将字符设备对象注册到内核中
       至此内核就有一个新的字符设备驱动
     4.调用cdev_del将字符设备对象从内核中卸载
       一旦卸载,内核就不存在这个字符设备驱动

 2.7.切记应用程序的系统调用函数和底层驱动硬件操作接口之间的联系：
 应用程序调用open->C库open->软中断->内核sys_open->驱动open接口
 应用程序调用read->C库read->软中断->内核sys_read->驱动read接口
 应用程序调用write->C库write->软中断->内核sys_write->驱动write接口
 应用程序调用close->C库close->软中断->内核sys_close->驱动release

 案例：应用程序打开LED设备时,开灯
       应用程序关闭LED设备时,关灯
 分析：
 0.将两个LED灯作为一个硬件设备
 1.应用程序使用open/close
   驱动提供open/release接口
 2.两个接口只需要利用GPIO操作库函数分别操作LED即可
 3.前提是需要将file_operations和cdev进行定义初始化和注册

 实施步骤：
 虚拟机执行：
 mkdir /opt/drivers/day03/1.0 -p
 cd /opt/drivers/day03/1.0
 vim led_drv.c
 vim Makfile
 make
 cp led_drv.ko /opt/rootfs/home/drivers
 vim led_test.c //测试的应用程序
 arm-linux-gcc -o led_test led_test.c
 cp led_test /opt/rootfs/home/drivers

 ARM板执行：
 insmod /home/drivers/led_drv.ko
 cat /proc/devices //查看申请的主设备号
Character devices: //当前系统的字符设备
  1 mem
  2 pty
  3 ttyp
  4 /dev/vc/0
  ...
  250 tarena
  ...
  第一列：申请的主设备号
  第二列：设备名称

 mknod /dev/myled c 250 0
 /home/drivers/led_test

3.编写一个字符设备驱动的步骤：
1.写头文件
2.写入口和出口函数
3.先声明和定义初始化硬件信息
4.然后定义初始化软件信息
  file_operations
  cdev
  dev
5.填充入口和出口函数
  先写注释流程
  再写代码
6.最后将给用户提供的接口函数完善

4.linux内核字符设备驱动硬件操作接口之write
  回忆：应用write系统调用函数的使用
  char msg[1024] = {....};
  write(fd, msg, 1024); //向设备写入数据

  对应的底层驱动的write接口：
  struct file_operations {
        ssize_t (*write) (struct file *file,
                        const char __user *buf,
                        size_t count,
                        loff_t *ppos);
  };
  调用关系：
  应用调write->C库write->软中断->内核sys_write->驱动write接口
  功能：此接口用于将数据写入硬件设备
  参数：
  file:文件指针
  buf：此指针变量用__user修饰,表明此指针变量保存的地址位于
       用户空间(0~3G),也就是保存用户缓冲区的首地址(例如msg)
       虽然底层驱动可以访问buf获取用户的数据,但是内核不允许驱动
       直接操作这个用户缓冲区(例如：int data = *(int *)buf),
       这么操作时相当危险的,如果要从buf缓冲区读取数据到驱动中
       必须要利用内核提供的内存拷贝函数copy_from_user将用户缓冲区的
       数据拷贝到内核缓冲区(3G~4G)中
  count:要写入的字节数
  ppos：记录了上一次的写位置,参考代码：
         loff_t pos = *ppos //获取上一次的写位置
         这一次写了512字节,此接口返回之前,要记得更新写位置：
         *ppos = pos + 512

        友情提示：如果写操作只进行一次,无需记录写位置！
        所以此参数用于多次写入操作

   内存拷贝函数copy_from_user
   unsigned long copy_from_user(void *to,
                                const void __user *from,
                                unsigned long n)
   函数功能：将用户空间缓冲区的数据拷贝到内核空间的缓冲区中
   参数：
   to:目标,内核缓冲区的首地址
   from:源,用户缓冲区的首地址
   n:要拷贝的字节数
   切记：此函数仅仅做了将用户内存的数据拷贝到内核的内存
         此时还没有进行硬件操作,硬件操作还需要进行额外的操作

   案例：应用向设备写1,开灯
         应用写设备写0,关灯
   实施步骤：
   mkdir /opt/drivers/day03/2.0
   cd /opt/drivers/day03/2.0
 vim led_drv.c
 vim Makfile
 make
 cp led_drv.ko /opt/rootfs/home/drivers
 vim led_test.c //测试的应用程序
 arm-linux-gcc -o led_test led_test.c
 cp led_test /opt/rootfs/home/drivers

 ARM板执行：
 insmod /home/drivers/led_drv.ko
 cat /proc/devices //查看申请的主设备号
Character devices: //当前系统的字符设备
  1 mem
  2 pty
  3 ttyp
  4 /dev/vc/0
  ...
  250 tarena
  ...
  第一列：申请的主设备号
  第二列：设备名称

 mknod /dev/myled c 250 0
 /home/drivers/led_test on
 /home/dirvers/led_test off

 总结：底层驱动write编写三步曲：
 1.定义内核缓冲区
 2.从用户缓冲区拷贝数据到内核缓冲区
 3.根据用户的需求进行硬件数据写入操作

5. linux内核字符设备驱动硬件操作接口之read
  回忆：应用read系统调用函数的使用
  char msg[1024];
  read(fd, msg, 1024); //从硬件设备读取数据到msg缓冲区

  对应的底层驱动的read接口：
  struct file_operations {
        ssize_t (*read) (struct file *file,
                        char __user *buf,
                        size_t count,
                        loff_t *ppos);
  };
  调用关系：
  应用调read->C库read->软中断->内核sys_read->驱动read接口
  功能：从硬件设备读取数据到用户缓冲区
  参数：
  file:文件指针
  buf：此指针变量用__user修饰,表明此指针变量保存的地址位于
       用户空间(0~3G),也就是保存用户缓冲区的首地址(例如msg)
       虽然底层驱动可以访问buf向用户缓冲区写入数据,但是内核不允许驱动
       直接操作这个用户缓冲区(例如：*(int *)buf=0x5555),
       这么操作时相当危险的,如果驱动要想用户缓冲区写入数据
       必须要利用内核提供的内存拷贝函数copy_to_user将内核缓冲区的
       数据拷贝到用户缓冲区中
  count:要读取的字节数
  ppos：记录了上一次的读位置,参考代码：
         loff_t pos = *ppos //获取上一次的读位置
         这一次读了512字节,此接口返回之前,要记得更新读位置：
         *ppos = pos + 512

        友情提示：如果读操作只进行一次,无需记录读位置！
        所以此参数用于多次读操作

   内存拷贝函数copy_to_user
   unsigned long copy_to_user(void __user *to,
                                const void  *from,
                                unsigned long n)
   函数功能：将内核空间缓冲区的数据拷贝到用户空间的缓冲区中
   参数：
   to:目标,用户缓冲区的首地址
   from:源,内核缓冲区的首地址
   n:要拷贝的字节数
   切记：此函数仅仅做了将内核内存的数据拷贝到用户的内存
         此时还没有进行硬件操作,硬件操作还需要进行额外的操作

    总结：数据流走向
    对于write：
    用户数据->经过一次拷贝到内核空间->经过二次拷贝到硬件
    对于read：
    硬件经过一次数据拷贝->内核,经过二次拷贝->用户

    案例：获取灯的开关状态
    总结：底层驱动read编写三步曲：
    1.定义内核缓冲区
    2.从硬件获取数据拷贝到内核缓冲区
    3.将内核缓冲区数据最终拷贝到用户缓冲区

案例：应用能够任意开关某个灯
提示：应用应该向设备写入两个信息：开或者关和灯的编号(1或者2)
应用只需向驱动写入一个结构体即可：
struct led_cmd {
        int cmd; //开：1;关：0
        int index;//第一个灯：1；第二个灯：2
};
write(fd, 结构体,结构体大小);

底层驱动write接口用结构体来接收数据，
接收完解析判断结构体成员

回顾：
1.linux内核设备驱动开发相关基础
  1.1.设备驱动两大核心思想
  1.2.linux内核设备驱动的分类
  1.3.linux系统包含的两个空间：用户空间和内核空间
  1.4.linux内核程序的编程框架
  1.5.linux内核程序的命令行传参
  1.6.linux内核程序的符号导出

2.linux内核程序的打印函数printk
  2.1.printk VS printf
  相同点：
        都是用于打印信息
        用法完全一致
  不同点：
        前者只能用于内核空间
        后者只能用于用户空间
        前者能够指定打印输出级别

  2.2.printk的打印输出级别
  级别共8级:0~7,数字越大,输出级别越小
  #define  KERN_EMERG	"<0>" //系统崩溃时需要打印
  #define  KERN_ALERT	"<1>" //立即需要处理
  #define  KERN_CRIT	"<2>" //严重问题
  #define  KERN_ERR	"<3>" //错误信息
  #define  KERN_WARNING	"<4>" //警告
  #define  KERN_NOTICE	"<5>" //正常但还需要引起注意
  #define  KERN_INFO	"<6>" //信息
  #define  KERN_DEBUG	"<7>" //额外的调试信息
  用法：
  printk(KERN_ERR "this is a error msg!\n");
  或者
  printk("<3>" "this is a error msg!\n");

  2.3.问：实际产品在发布的时候,有些信息是没有必要输出的,
      有些信息可能需要进行打印输出,只需设置一个默认的
      打印输出级别(类似水位的警戒线)进行控制信息是否输出
      如果printk指定的输出级别大于默认的打印输出级别,此信息
      输出,否则不输出,如何设置默认的打印输出级别呢？
      答：通过两种方法进行配置

  方法1：通过修改printk打印输出级别的配置文件
         /proc/sys/kernel/printk
  案例：练习方法1
  实施步骤：
  虚拟机执行：
  1.mkdir /opt/drivers/day02/1.0 -p
  2.cd /opt/drivers/day02/1.0
  3.vim printk_all.c
  4.vim Makefile
  5.make
    cp printk_all.ko /opt/rootfs/home/drivers

  ARM板执行：
  0.cd /home/drivers
  1.insmod printk_all.ko //查看打印信息
  2.rmmod printk_all.ko //查看打印信息
  3.查看当前内核printk的默认打印输出级别
    cat /proc/sys/kernel/printk
    7(串口终端设备对应的输出级别)       4       1       7
  4.修改配置文件来修改默认打印输出级别
    echo 8 > /proc/sys/kernel/printk
    cat /proc/sys/kernel/printk
  5.insmod printk_all.ko
    rmmod printk_all

  6.结论：方法1不能解决内核启动时候的打印信息,例如：不能
          完全将内核信息进行屏蔽

  方法2：通过修改内核的启动参数,来设置默认的打印输出级别
  案例：练习方法2
  实施步骤：
  1.重启开发板,进入uboot命令行模式,执行：
    setenv bootargs root=/dev/nfs nfsroot=192.168.1.8:/opt/rootfs ip=192.168.1.110:192.168.1.8:192.168.1.1:255.255.255.0::eth0:on init=/linuxrc console=ttySAC0,115200 debug
    boot
  2.系统启动
    cd /home/drivers/
    insmod printk_all.ko
    rmmod printk_all
    cat /proc/sys/kernel/printk
    结论：debug对应的级别为10

  3.重启开发板,进入uboot命令行模式,执行：
    setenv bootargs root=/dev/nfs nfsroot=192.168.1.8:/opt/rootfs ip=192.168.1.110:192.168.1.8:192.168.1.1:255.255.255.0::eth0:on init=/linuxrc console=ttySAC0,115200 quiet
    boot
  4.系统启动
    cd /home/drivers/
    insmod printk_all.ko
    rmmod printk_all
    cat /proc/sys/kernel/printk
    结论：quiet对应的级别为4

  5.重启开发板,进入uboot命令行模式,执行：
    setenv bootargs root=/dev/nfs nfsroot=192.168.1.8:/opt/rootfs ip=192.168.1.110:192.168.1.8:192.168.1.1:255.255.255.0::eth0:on init=/linuxrc console=ttySAC0,115200 loglevel=0
    boot
  6.系统启动
    cd /home/drivers/
    insmod printk_all.ko
    rmmod printk_all
    cat /proc/sys/kernel/printk
    结论：loglevel=数字

3.linux内核GPIO操作库函数
  3.1.明确”GPIO操作“：配置GPIO为输出或者输入
      如果是输出口,输出1或者0
      如果是输入口,获取GPIO的状态1或者0

  3.2.ARM裸板GPIO操作软件编程
  例如：配置为输出口,输出1
  *gpiocon &= ~(0xf << xxx);
  *gpiocon |= (1 < xxx);
  *gpiodata|= (1 << xxx);

  3.3.linux内核便于驱动开发者进行GPIO操作,提供了相关的
      GPIO操作库函数
  1.int gpio_request(int gpio, char *label)
    功能：明确CPU的任何硬件信息,比如GPIO管脚硬件信息对于
          内核来说都是一种宝贵的资源(像内存),程序要想访问
          必须先向内核去申请硬件资源,类似malloc
    参数：
    gpio:表示硬件GPIO管脚对应的内核软件编号(类似身份证号)
         具有唯一性
         内核软件编号由内核已经定义好,例如：
         硬件GPIO名       内核软件编号
         GPC0_3		  S5PV210_GPC0(3) //宏
         GPC0_4		  S5PV210_GPC0(4)
         GPF1_3		  S5PV210_GPF1(3)
         ...              ...
    label：随意指定一个名称即可

    内核函数的返回值一律不允许记忆,只需要利用SI打开内核
    源码,看大神如何写,照猫画虎;
    置于头文件的添加,将大神的代码的头文件一股脑全部拷贝即可

  2.void gpio_free(int gpio)
    功能：硬件GPIO资源不再使用了,记得要释放资源,类似free

  3.int gpio_direction_output(int gpio, int value)
    功能：配置GPIO为输出口,同时输出一个value值(1/0)

  4.int gpio_direction_input(int gpio)
    功能：配置GPIO为输入口

  5.int gpio_set_value(int gpio, int value)
    功能：仅仅设置GPIO的输出状态为value值(1/0)
          前提是GPIO必须配置为输出口

  6.int gpio_get_value(int gpio)
    功能：获取GPIO的状态,返回值保存状态(1/0)
          不管是输入还是输出口都可以使用

  涉及头文件：
  #include <asm/gpio.h>
  #include <plat/gpio-cfg.h>

  案例：加载驱动开灯;卸载驱动关灯
  实施步骤：
  虚拟机执行：
  mkdir /opt/drivers/day02/2.0
  cd /opt/drivers/day02/2.0
  vim led_drv.c
  vim Makefile
  make
  cp led_drv.ko /opt/rootfs/home/drivers/

  开发板执行：
  cd /home/drivers
  insmod led_drv.ko //开灯
  rmmod led_drv //关灯

  结构体的标记初始化方式：
  struct std {
        int a;
        int b;
        int c;
        int d;
        int e;
  };

  //一般定义初始化
  struct std info = {100, 200, 300, 400, 500};

  //标记初始化
  struct std info = {
        .e = 100,
        .a = 200,
        .c = 300
  }; //不用全部初始化,还可以不用按照顺序

4.linux系统的系统调用实现原理
  面试题：谈谈linux系统调用
  回忆：学过系统调用函数：open/read/write/close/mmap/lseek/fork/exit/sbrk等
  系统调用函数作用：它是用户空间和内核空间数据交互的唯一的通道
                    应用程序利用系统调用函数能够向内核发起一个业务处理的请求
                    内核最终帮你完成业务,并且将处理的结果给应用程序
  系统调用实现的基本过程：
  这里以write系统调用函数为例：
  1.首先应用程序调用write系统调用函数
  2.会调用到C库的write函数的定义
  3.C库的write函数将做两件事：
    3.1.保存write函数对应的系统调用号到R7寄存器
    系统调用号：linux系统调用函数都有唯一的一个软件编号(类似身份证号)
    系统调用号定义在内核源码的arch/arm/include/asm/unistd.h
    #define __NR_restart_syscal (0+  0)
    #define __NR_exit			(0+  1)
    #define __NR_fork			(0+  2)
    #define __NR_read			(0+  3)
    #define __NR_write			(0+  4)
    ...				         ...
    #define __NR_函数名                  数字

    3.2.调用svc软中断指令,触发软中断异常

    3.3.一旦触发软中断异常,CPU开启了软中断异常的处理
        最终CPU跳转到软中断处理的入口地址,至此应用程序
        由用户空间“陷入”内核空间,CPU的工作模式有USER切换到
        SVC管理模式

    3.4.进入软中断的处理入口地址以后,同样做两件事：
        1.从R7寄存器中取出之前保存的系统调用号
        2.然后以取出的系统调用号为下标在内核事先已经
          定义好的系统调用表(表=大数组)中找到一个函数
          此函数为sys_write,找到以后执行此函数
        系统调用表：本质就是一个大数组,数组中每一个元素
                    保存的是一个函数地址
        定义在内核源码的：arch/arm/kernel/calls.S

    3.5.执行完毕,最终原路返回到用户空间

    提示：必须会画图

**********************************************************
4.linux内核字符设备驱动开发相关内容
  面试题：如何编写一个字符设备驱动程序
  4.1.linux的理念：一切皆文件
  “一切”：就是指硬件资源
          将来只要访问某个文件,本质上就是在访问硬件本身！

  4.2.设备文件特性
     字符设备对应的文件又称字符设备文件
     块设备对应的文件又称块设备文件
     网络设备没有对应的文件,通过socket套接字进行访问
     结论：设备文件包括字符设备文件和块设备文件

     设备文件存在于根文件系统rootfs的dev目录中,以TPAD的4个UART
     为例,4个UART对应的设备文件：
     ls /dev/s3c2410_serial* -lh
     crw-rw----  204,  64  /dev/s3c2410_serial0
     crw-rw----  204,  65  /dev/s3c2410_serial1
     crw-rw----  204,  66  /dev/s3c2410_serial2
     crw-rw----  204,  67  /dev/s3c2410_serial3

     说明：
     "c":表示此设备文件对应的硬件是字符设备硬件
         块设备用"b"
     "204":表示设备文件的主设备号
     "64~67":表示设备文件的次设备号
     s3c2410_serial0:第一个UART的设备文件名
     s3c2410_serial1:第二个UART的设备文件名
     s3c2410_serial2:第三个UART的设备文件名
     s3c2410_serial3:第四个UART的设备文件名

     设备文件的访问：一定要利用系统调用函数进行：
     //打开第一个串口
     int fd = open("/dev/s3c2410_serial0", O_RDWR);

     //从串口读取数据
     read(fd, buf, size);

     //向串口写入数据
     write(fd, "hello,world", 12);

     //关闭串口
     close(fd);

     设备文件的创建方法：2种
     1.手动创建,利用命令mknod
       mknod /dev/设备文件名 c  主设备号  次设备号
       例如：
       mknod /dev/zhangsan c 250 0

     2.自动创建

  4.3.设备号
  设备号包括主设备号和次设备号
  设备号的数据类型：dev_t,本质unsigned int
  设备号的高12位保存的主设备号
  设备号的低20位保存的次设备号
  设备号相关操作宏：
  MKDEV:已知主，次设备号,合并一个设备号
        dev_t dev = MKDEV(主设备号, 次设备号);
  MAJOR:已知设备号,提取主设备号
        int major = MAJOR(设备号);
  MINOR：已知设备号，提取次设备号
        int minor = MINOR(设备号);
  主设备号：应用程序根据设备文件的主设备号在茫茫的内核源码中
            找到自己匹配的设备驱动程序,一个设备驱动仅有一个
            主设备号
  次设备号：如果多个硬件共享一个主设备号,也就共享一个设备驱动
            将来设备驱动根据次设备号来区分用户到底想操作哪个
            硬件个体
  结论：设备号对于内核来说是一种宝贵的资源,驱动必须首先
        向内核去申请设备号资源

  向内核申请和释放设备号的两个函数：
  int alloc_chrdev_region(dev_t *dev,
                        unsigned baseminor,
                        unsigned count,
                        const char *name);
  功能：向内核去申请设备号
  dev:保存内核给你分配的设备号
  baseminor:希望起始的次设备号,一般给0
  count：分配次设备号的个数
  name：设备名称而不是设备文件名,通过cat /proc/devices查看

  void unregister_chrdev_region(dev_t dev, int count);
  功能：释放申请的设备号
  dev:申请好的设备号
  count:次设备号的个数

5.自行设计linux内核字符设备驱动
  声明一个描述字符设备驱动的数据结构
  struct char_device {
        char *name; //字符设备的名称
        dev_t dev; //字符设备对应的设备号
        int count; //硬件设备的个数
        int (*open)(...) //打开设备接口
        int (*close)(...) //关闭设备接口
        int (*read)(...) //读设备接口
        int (*write)(...) //写设备接口
  };
  大胆设想：
  应用程序调用open->软中断->内核的sys_open->驱动的open接口
  应用程序调用close->软中断->内核的sys_close->驱动的close接口
  应用程序调用read->软中断->内核的sys_read->驱动的read接口
  应用程序调用write->软中断->内核的sys_write->驱动的write接口

  优化数据结构：
  //描述字符设备驱动的数据结构
  struct char_device {
        char *name; //字符设备的名称
        dev_t dev; //字符设备对应的设备号
        int count; //硬件设备的个数
        struct file_operations *ops;
  };

  //描述字符设备驱动接口的数据结构
  struct file_operations {
        int (*open)(...) //打开设备接口
        int (*close)(...) //关闭设备接口
        int (*read)(...) //读设备接口
        int (*write)(...) //写设备接口
        ... //为所欲为添加任何一个接口
  };

6.内核描述字符设备驱动的数据结构和硬件操作接口的数据结构
    //描述字符设备驱动的数据结构
  struct cdev {
        dev_t dev; //字符设备对应的设备号
        int count; //硬件设备的个数
        struct file_operations *ops;//字符设备驱动具有的硬件操作接口
        ... //内核使用
  };

  //描述字符设备驱动接口的数据结构
  struct file_operations {
        int (*open)(struct inode *, struct file *) //打开设备接口
        int (*close)(struct inode *, struct file *) //关闭设备接口
        ...
  };

一.嵌入式linux设备驱动开发相关内容
<<Linux设备驱动程序>>第三版
<<Linux内核设计与实现>>第三版
<<跟我一起写Makefile>>电子档

关于SecureCRT远程登录linux系统的配置过程：
打开快速连接->协议：ssh2
              主机名：192.168.1.8
              用户名：tarena
->保存->输入密码->配置SecureCRT->会话选项->仿真->终端：ANSI
                                                       使用颜色方案选中
->外观：设置自己喜欢的字体Courier New
        字符编码：UTF-8
        保存
->重新SecureCRT即可

面试题：如何开发一个linux硬件设备驱动？
友情提示：嵌入式linux系统一旦运行起来以后,要花更多的时间
          和精力放在开发板上的外设硬件的设备驱动程序上,
          如果这个外设有了驱动,需要进行测试,测试的前提是
          你要看得懂；
          如果这个外设没有驱动,要进行这个外设硬件的设备驱动开发

1. 设备驱动概念
   一个驱动的关键两个内容：
   1.将硬件的整个操作过程进行封装
   2.必须能够给用户提供访问操作硬件的接口(函数)
     将来用户调用函数能够随便访问硬件

2.linux系统的两个空间(两种状态)：用户空间和内核空间(了解即可)
  用户空间：
        又称用户态
        包含的软件就是各种命令,各种应用程序,各种库,各种配置服务等
        用户空间的软件在运行的时候,CPU的工作模式为USER模式
        用户空间的软件不能访问硬件设备的物理地址,如果要访问硬件物理地址
        必须将硬件外设的物理地址映射到用户空间的虚拟地址上
        用户空间的软件不能直接访问内核空间的代码,地址和数据
        用户空间的软件如果进行非法的内存访问,不会导致操作系统崩溃
        但是应用软件会被操作系统干掉(例如：*(int *)0=0)
        用户空间的软件类似论坛的普通用户
        用户空间的虚拟地址空间大小为3G(0x00000000~0xBFFFFFFF)
  内核空间：
        又称内核态
        内核空间的软件就是内核源码(zImage)
        内核代码运行时,CPU的工作模式为SVC模式
        内核空间代码同样不能访问硬件外设的物理地址,必须将物理地址
        映射到内核空间的虚拟地址上
        内核代码如果进行非法的内存访问,操作系统会直接崩溃(吐核)
        (例如：*(int *)0=0)
        内核空间的软件类似论坛的管理员
        内核空间的虚拟地址空间大小为1G(0xC0000000~0xFFFFFFFF)

3.linux系统设备驱动分类
  字符设备驱动
        字符设备访问时按照字节流形式访问
        例如：LED,按键,UART接口设备(BT,GPS,GPRS),触摸屏
              LCD,声卡,摄像头,各种传感器
  块设备驱动
        块设备访问时按照一定的数据块进行访问,数据块比如为
        512字节,1KB字节
        例如：硬盘,U盘,SD卡,TF卡,Nor,Nand等

  网络设备驱动
        网络设备驱动访问时需要配合TCP/IP协议栈进行访问
        驱动一般由芯片厂家提供,驱动开发者需要进行移植
        例如：DM9000网卡基地址

4.linux字符设备驱动开发相关内容
  4.0.明确不管什么驱动,它们都是内核程序
  4.1.明确linux内核程序编程基本框架
  回忆：应用程序编程框架
  vim helloworld.c
  #include <stdio.h> //标准C头文件

  //main：程序的入口函数
  int main(int argc, char *argv[])
  {
        //标准C库函数
        printf("hello,world\n");

        //程序的出口
        return 0;
  }

  内核程序参考代码：
  mkdir /opt/drivers/day01/1.0 -p
  cd /opt/drivers/day01/1.0
  vim helloworld.c 添加第一个内核程序
  #include <linux/init.h>
  #include <linux/module.h>
  static int helloworld_init(void)
  {
        printk("hello,world\n");
        return 0;
  }
  static void helloworld_exit(void)
  {
        printk("good bye world!\n");
  }
  module_init(helloworld_init);
  module_exit(helloworld_exit);
  MODULE_LICENSE("GPL");
  说明：
  1.内核程序使用的头文件位于linux内核源码中(/opt/kernel)
  2.内核程序的入口函数需要使用module_init宏进行修饰,例如
    helloworld_init函数就是此内核程序的入口函数,将来加载
    安装驱动时(insmod),内核会调用此函数；
    此函数的返回值必须为int型,执行成功返回0,执行失败返回负值
  3.内核程序的出口函数需要使用module_exit宏进行修饰,例如
    helloworld_exit函数就是此内核程序的出口函数,将来卸载
    驱动(rmmod)时,内核会调用此函数
  4.任何一个内核程序源码(.c结尾)必须添加MODULE_LICENSE("GPL")
    这句话,就是告诉内核,此内核程序同样遵循GPL协议,否则后果
    很严重
  5.内核打印函数使用printk,此函数定义不再C库中,而是在内核
    源码中
  6.结论：编译内核程序肯定需要关联内核源码

  4.2.内核程序的编译
  回顾：应用程序的编译
        gcc -o helloworld helloworld.c
        编写Makefile,make编译即可
  内核程序编译：
  回顾led_drv.c编译步骤：
  1.静态编译
    拷贝内核程序到内核源码中
    修改Kconfig
    修改Makfile
    make menuconfig //选择为*
    make zImage (led_drv.c包含在zImage里面)
  2.模块化编译
    拷贝内核程序到内核源码中
    修改Kconfig
    修改Makfile
    make menuconfig //选择为M
    make zImage
    make modules //将led_drv.c->led_drv.ko
    insmod
    rmmod
  3.模块化编译方法2：
    思想就是无需把内核程序拷贝到内核源码中
    无需修改Kconfig和Makefile
    无需make menuconfig
    无需make zImage
    只需一个小小的Makeifle即可搞定：
    死记一下参考代码：
    cd /opt/drivers/day01/1.0
    vim Makefile 添加如下内容：
    obj-m += helloworld.o  #采用模块化编译,helloworld.c->helloworld.ko
    #执行命令make all或者make,执行对应的命令make -C ...
    all:
        make -C /opt/kernel SUBDIRS=$(PWD) modules
        #make -C /opt/kernel=cd /opt/kernel && make
        #SUBDIRS=/opt/drivers/day01/1.0,告诉内核源码,在内核源码之外还有一个目录作为子目录
        #modules：对1.0这个子目录下的内核程序采用模块化编译
    clean：
        make -C /opt/kernel SUBDIRS=$(PWD) clean
        #将子目录1.0的程序进行make clean操作
    保存退出
    make //编译
    ls
      helloworld.ko //编译成果
    cp helloworld.ko /opt/rootfs/

    开发板测试：
    重启开发板,进入uboot,让内核加载采用tftp,让内核启动采用nfs
    setenv bootcmd tftp 20008000 zImage \; bootm 20008000
    setenv bootargs root=/dev/nfs nfsroot=192.168.1.8:/opt/rootfs ...
    savenv
    boot //启动
    启动以后：
    insmod helloworld.ko //安装内核程序,内核执行入口函数helloworld_init
    lsmod //查看内核程序的安装信息
    rmmod helloworld //卸载内核程序,内核执行出口函数helloworld_exit

4.2.linux内核程序编程之命令行传参
1.回忆应用程序的命令行传参
  vim helloworld.c
  #include <stdio.h>
  int main(int argc, char *argv[])
  {
        int a;
        int b;

        if (argc != 3) {
           printf("用法: %s num1 num2\n", argv[0]);
           return -1;
        }

        //"100"->100
        a = strtoul(argv[1], NULL, 0);
        b = strtoul(argv[2], NULL, 0);

        printf("a = %d, b = %d\n", a, b);
        return 0;
  }
  gcc -o helloworld helloworld.c
  ./helloworld 100 200
  分析：
  argc = 3
  argv[0] = "./helloworld"
  argv[1] = "100"
  argv[2] = "200"
  缺点：一旦程序启动,后序就没法再次传递新的参数

  内核程序的命令行传参实现过程：
  1.内核程序的命令行传参时,接收参数的内核程序变量必须是
    全局变量
  2.变量的数据类型必须是基本的数据类型,结构体不行
  3.如果要给内核程序的某个全局变量传递参数,需要内核程序
    显式的进行传参声明,传参声明的宏：
    module_param(name, type, perm)
    name：接收参数的内核全局变量名
    type: 变量的数据类型：
          bool invbool
          short ushort
          int uint
          long ulong
          charp(=char *)
          切记：内核不允许处理浮点数(float,double)
          例如：2.3*3.2
                23*32/100
                浮点数的运算放在用户空间的应用程序来进行
    perm：变量的访问权限(rwx)
          例如：0664
          注意：不允许有可执行权限(x=1)

   案例：编写内核程序,实现内核程序的命令行传参
   实施步骤：
   虚拟机执行：
   1.mkdir /opt/drivers/day01/2.0 -p
     cd /opt/drivers/day01/2.0
   3.vim helloworld.c 添加如下内容
   4.vim Makefile 添加如下内容
   5.make
     helloworld.ko
   6.cp helloworld.ko /opt/rootfs/

   linux系统调试宏：
   __FILE__
   __LINE__
   __FUNCITION__/__func__
   __DATE__
   __TIME__

   ARM板执行：
   1.不传递参数
     insmod helloworld.ko
     lsmod
     rmmod helloworld

   2.加载安装内核程序时传递参数
     insmod helloworld.ko irq=100 pstring=china
     lsmod
     rmmod helloworld

   3.加载安装内核程序以后传递参数
     insmod helloworld.ko irq=100 pstring=china
     //读取文件irq的内容
     cat /sys/module/helloworld/parameters/irq
     ls /sys/module/helloworld/parameters/pstring  //没有此文件
     //向文件irq重新写入一个新内容
     echo 20000 > /sys/module/helloworld/parameters/irq
     rmmod helloworld

     结论：
     1.如果传参声明时,权限为非0,那么在/sys/...../parameters
       会生成一个跟变量名同名的文件,文件内容就是变量的值
     2.通过修改文件的内容就可以间接修改变量的值
     3.如果权限为0,那么在/sys/.../parameters下就不会
       生成同名的文件,这个变量的传参只能在程序加载时进行
     4.注意：/sys/目录下所有的内容都是内核创建,存在于
       内存中,将来如果没有内核程序加载以后传递参数的需求
       权限必须一律给0,目的为了节省内存资源！

4.3.linux内核程序编程之内核符号导出
回忆：应用程序多文件之间的调用
参考代码：
mkdir /opt/drivers/day01/3.0
cd /opt/drivers/day01/3.0
vim test.h //声明
#ifndef __TEST_H
#define __TEST_H

extern void test(void);

#endif

vim test.c //定义
#include <stdio.h>
void test(void)
{
        printf("%s\n", __func__);
}

vim main.c //调用
#include <stdio.h>
#include "test.h"

int main(void)
{
        test();//调用
        return 0;
}

编译：
arm-linux-gcc -fpic -shared -o libtest.so test.c
arm-linux-gcc -o main main.c -L. -ltest
mkdir /opt/rootfs/home/applib
cp libtest.so /opt/rootfs/home/applib
cp main /opt/rootfs/home/applib

开发板测试：
export LD_LIBRARY_PATH=/home/applib:$LD_LIBRARY_PATH
/home/applib/main

内核程序多文件的调用实现过程：
1.内核程序多文件的调用实现过程和应用程序多文件的调用实现
  过程一模一样:该声明的声明,该定义的定义,该调用的调用
2.还需要显式的进行符号(函数名或者变量名)的导出
  导出符号的宏：
  EXPORT_SYMBOL(函数名或者变量名);
  或者
  EXPORT_SYMBOL_GPL(函数名或者变量名);
  前者导出的变量和函数,不管其他内核程序是否添加：MODULE_LICENSE("GPL")
  都能访问调用；
  后者导出的变量和函数,只能给那些添加了MODULE_LICENSE("GPL")的内核程序访问

案例：编写内核程序,掌握内核的符号导出知识点
实施步骤：
虚拟机执行：
mkdir /opt/drivers/day01/4.0
cd /opt/drivers/day01/4.0
vim test.h 添加如下内容
#ifndef __TEST_H
#define __TEST_H

//函数声明
extern void test(void);

#endif
保存退出

vim test.c 添加如下内容
#include <linux/init.h>
#include <linux/module.h>

//函数定义
void test(void)
{
        printk("%s\n");
}

//显式的进行导出
EXPORT_SYMBOL(test);

EXPORT_SYMBOL_GPL(test);

//添加遵循GPL协议的信息
MODULE_LICENSE("GPL");

保存退出

vim helloworld.c 添加如下内容
#include <linux/init>
#include <linux/module.h>

static int helloworld_init(void)
{
        test(); //调用
        printk("%s\n", __func__);
        return 0;
}

static void helloworld_exit(void)
{
        test(); //调用
        printk("%s\n", __func__);
}

module_init(helloworld_init);
module_exit(helloworld_exit);

MODULE_LICENSE("GPL");

保存退出

修改Makefile,添加对test.c的编译支持
obj-m += helloworld.o test.o
或者
obj-m += helloworld.o
obj-m += test.o

make //开始编译
test.ko helloworld.ko

mkdir /opt/rootfs/home/drivers/ //创建驱动目标文件的存放目录
cp *.ko /opt/rootfs/home/drivers/


开发板测试：
1.insmod /home/drivers/?
2.insmod /home/drivers/?
3.rmmod ?
4.rmmod ?


案例：利用EXPORT_SYMBOL_GPL进行符号导出,做对比测试


获取一个设备的驱动的名字：
const char *dev_driver_string(struct device *dev);
const char *dev_name(struct device *dev);
例如：
下面的hid-generic 0003:0461:4D81.0001就是使用上面的来两个函数输出的
dev_driver_string() // 输出hid-generic
dev_name() // 输出 0003：0461：4D81.0001
[   29.284197] hid-generic 0003:0461:4D81.0001: input: USB HID v1.11 Mouse [USB Optical Mouse] on usb-ci_hdrc.0-1/input0


八、做过的项目
    广州：Phascan、Flexscan、Phascan-II
        Doppler-II.c  400多行
        Doppler.c     300多行

    上海：TCP的编程、智能社区

智能家居项目：
   监控室内温度,温度高于某个阀值,报警
   监控室内烟雾,烟雾浓度高于某个阀值,报警
   监控红外状态,判断是否有非法闯入
   实现软件的在线升级
   实现软件和硬件版本号的查询
   实现MP3播放器功能
智能小车项目：
   实现小车的运动控制
   实现小车上的摄像头的摆动
   实现摄像头视频数据的采集
   实现小车的无线路由器功能和热点

实施步骤：
面试题：如何做一个嵌入式产品？
面试题：以采集温度为例,用51单片机,成本只需100元不到,为什么
        要选择一个高端的S5PV210+linux系统来做呢？

1.要分析用户的需求
  围绕着"嵌入式系统"的概念去谈
  以用户需求为中心
  紧接着以iphone手机的诺基亚1050为例
  软件和硬件可裁剪
  功能要合理
  价格要合适
  成本要低
  可靠性要高
  体积？
  功耗要低

2.硬件设计
  谈：嵌入式产品开发包括硬件和软件
  最难：芯片选型
  芯片选型的原则：
  性能要合适
  价格要合理
  芯片厂家服务要周到：
                最好能够提供硬件参考设计
                最好能够提供软件参考设计
  硬件通信接口要简单为主：
                GPIO
                UART
                总线
                I2C
                1-Wire
                SPI
  例如：以温度传感器为例：
        LM77(I2C接口)：首选,采用标准I2C接口,I2C控制器完成时序,效率高
        DS18B20(1-Wire):次选,采用1-wire,将会面临大量的忙延时

  以智能家居为例：
  CPU选型
  内存选型
  闪存选型
  外围接口的选型
  “主动出击”谈为什么不选择51单片机而选择高端的S5PV210
  如果以采用51单片机采集温度,烟雾,红外完全没有问题,成本低
  但是如果添加视频采集,视频数据的存储,网络功能,此处理器完全
  不能胜任,此时需要考虑高端的CPU

3.软件设计
  明确：是否运行操作系统
  裸板程序,程序框架:
  main() {
        xxx_init //各种硬件初始化
        while(1) {
                //处理业务
        }
  }
  中断处理函数(){
        //中断相关的业务
  }

  操作系统：以linux系统为例
  交叉编译器
        芯片厂家获取
        版本要合适
  bootloader:(u-boot)
        大谈特谈uboot的功能,谈笔记
  linux内核：
        7大子系统,谈笔记
  rootfs根文件系统：
        谈笔记,分分钟搞定
  外设设备的驱动程序：属于linux的范畴
        以按键或者AT24C02两个芯片为例
        按键关键牵扯到中断,大谈中断
        AT24C02牵着I2C总线,大谈I2C总线

  应用程序:属于rootfs范畴
        谈系统调用的原理

项目第一天任务安排：
1.制作最小rootfs根文件系统
2.移植tslib
  特点：
  0.tslib=touch screen lib触摸屏的硬件操作库
  1.开源软件
  2.管理的硬件是触摸屏
  3.运行在用户空间,本质就是动态库
  4.应用程序QT,Android能够调用tslib提供的动态库函数能够
    获取到触摸屏的有效坐标(X,Y)
    画图
  5.移植tslib的本质目的就是获取到对应的动态库,将来QT
    能够获取到X,Y坐标
  6.提示：开源软件操作三步曲：
    ./configure --prefix=/opt/project/tslib --host=arm-linux //配置
    切记：--prefix:指定安装路径
          --host:指定将来软件运行的目标平台arm,linux系统
    make //编译
    make install //安装,将编译生成的二进制文件统统放在
                 --prefix选项指定的目录中
  7.linux系统的按键,触摸屏,鼠标的设备文件都叫：
    /dev/input/eventX
    或者
    /dev/eventX
  8.tslib运行时重要的环境变量：
    //指定tslib动态库将来操作的触摸屏的设备文件,一定不能错
    export TSLIB_TSDEVICE=/dev/input/event3
    //指定tslib动态库的路径,否则将来提示找不到动态库
    export LD_LIBRARY_PATH=/home/tslib/lib:$LD_LIBRARY_PATH
  9.触摸屏校准
    如果将来QT点击,不精确,重新运行ts_calibrate校准

3.移植QT
  1.移植的QT版本为4.8.4
    交叉编译器的版本不能为4.4.1,
  2.移植QT本质的目的：同样获取到QT的动态库
    将来自己编写的QT程序调用移植的QT动态库实现界面的操作和显示
  3.QT涉及的关键环境变量
    //告诉QT将来获取的坐标X,Y对应的触摸屏的设备文件
    export QWS_MOUSE_PROTO="Tslib:/dev/input/event3"
    //指定字体库
    export QT_QWS_FONTDIR=$QTDIR/lib/fonts
    //指定图片处理库
    export QT_PLUGIN_PATH=$QTDIR/plugins
    //QT运行时指定的QT动态库的路径
    export LD_LIBRARY_PATH=$QTDIR/lib:$LD_LIBRARY_PATH
  4.切记切记,交叉编译自己的QT软件步骤：
    如果让自己的QT运行在linux虚拟机中,编译步骤：
    cd 自己的QT程序目录
    qmake -project //生成工程文件,只做一次
    qmake  //根据工程文件,生成Makefile,只做一次
    vim Makefile //查看CPP=g++
    make //编译


    如果让自己的QT程序运行在TPAD,编译步骤：
    cd 自己的QT程序目录
    //一定使用自己移植QT生成的qmake工具
    /opt/project/qt/bin/qmake -project //生成工程文件,只做一次
    /opt/project/qt/bin/qmake  //根据工程文件,生成Makefile,只做一次
    vim Makefile //查看CPP=arm-linux-g++
    make //编译

4.通过QT界面实现开关灯操作
  实施步骤：
  1.分析用户需求
    通过QT上的界面按钮实现点击开和关TPAD上的LED1和LED2
  2.硬件设计,硬件特性
    LED采用GPIO通信方式
    硬件操作：输出高电平开
              输出低电平关
  3.软件设计
    3.1.uboot/kernel/rootfs:都已搞定
    3.2.编写LED的设备驱动
    实施步骤：
    1.创建项目LED驱动的源码存放目录
      mkdir /opt/project/drivers/led -p
      cd /opt/project/drivers/led
    2.编写LED驱动
      驱动参考代码：project.rar/drivers.tar.bz2/led
      vim led_drv.c
      vim Makefile
      make
    3.创建驱动目标的存放目录
      mkdir /opt/rootfs/home/drivers/
      cp led_drv.ko /opt/rootfs/home/drivers/

    3.3.画出整个软件的操作流程图
        编写LED的硬件操作库(目的：让代码维护更加简便,使用更加方便)
        实施步骤：
        1.创建硬件操作库源码的存放目录
          mkdir /opt/project/hwlib/led -p
          cd /opt/project/hwlib/led
        2.编写硬件操作库源码
          参考代码：project.rar/hwlib.tar.bz2/led
                    led.h //声明
                    led.c //定义
                    ledlib_test.c //测试用例
                    Makefile
         vim led.h
         vim led.c
         vim ledlib_test.c

        3.编译生成动态库和测试用例
        arm-linux-gcc -shared -fpic -o libled.so led.c
        arm-linux-gcc -o ledlib_test ledlib_test.c -L. -lled

        4.创建硬件操作库和测试用例的存放目录
        mkdir /opt/rootfs/home/apptest //测试用例
        mkdir /opt/rootfs/home/applib  //动态库
        cp libled.so /opt/rootfs/home/applib
        cp ledlib_test /opt/rootfs/home/apptest

        5.添加动态库的运行的环境变量
          vim /opt/rootfs/etc/profile 文件最后添加：
          export LD_LIBRARY_PATH=/home/applib:$LD_LIBARY_PATH
          保存退出即可
          重启开发板
        6.开发板上测试驱动和硬件操作库
          开发板上执行：
          insmod /home/drivers/led_drv.ko
          /home/apptest/ledlib_test on 1
          ...
          如果都OK，说明动态库OK，驱动OK，硬件OK~!

      3.4.编写QT图形界面,会调用硬件操作库实现最终的开关灯
      实施步骤：
      参考代码：project.rar/ehome_led.tar.bz2
      0.友情提示可以花点时间复习QT
        先看视屏QT.avi和QT2.avi
      1.利用qtcreator创建QT项目工程
        工程名：ehome
        工程源码存放路径：/opt/project/ehome
      2.利用qtcreator打开mainwindow.ui文件,添加两个
        按钮：
        开灯           关灯
        QPushButton    QPushButton
      3.给这两个按钮添加槽函数
        光标移动到按钮上方,点击右键,选择"跳转到槽函数"
        选择clicked()信号函数,确定以后自动在代码中
        添加了槽函数的声明和槽函数的定义
      4.利用qtcreator打开mainwindow.h文件,添加硬件
        操作库的头文件和相关的成员
        #include "led.h"

        在MainWindow类中添加新成员
        int m_led_fd; //LED设备文件描述符
      5.利用qtcreator打开mainwindow.cpp文件
        在构造函数中调用硬件操作库：
        m_led_fd = led_open();

        在开灯按钮的槽函数中调用库函数实现开灯：
        struct led_cmd led;
        led.whichled = 1; //第一个灯
        led.cmd = 1; //开
        led_config(m_led_fd, &led); //实现开第一个灯

        在关灯按钮的槽函数中调用库函数实现关灯：
        struct led_cmd led;
        led.whichled = 1; //第一个灯
        led.cmd = 0; //关
        led_config(m_led_fd, &led); //实现关第一个灯

      6.交叉编译ehome图形界面软件
        切记：不能用qtcreator的绿色的三角按钮编译
              只能通过命令行去编译

        cd /opt/project/ehome
        /opt/project/qt/bin/qmake --project //生成工程文件
        vim ehome.pro //打开工程文件,添加：
        INCLUDEPATH += /opt/project/hwlib/led
        LIBS += -L/opt/project/hwlib/led -lled
        保存退出
        /opt/project/qt/bin/qmake //工程文件只有修改,就需要重新生成Makefile
        make
        ls
          ehome //可执行程序
        创建图形界面软件的存放目录
        mkdir /opt/rootfs/home/appbin
        cp ehome /opt/rootfs/home/appbin

      7.开发板测试ehome
        /home/appbin/ehome -qws //操作按钮观察灯是否开或者关

项目第二天任务安排：
面试题：请谈谈你的智能家居项目
        提示：就以温度采集显示监控为例
实施步骤：
1.用户需求：采集室内温度,并且在ehome图形界面每隔5秒动态刷新显示温度
          如果温度高于某个阀值,启动报警器,让LED1告警指示灯每隔200ms闪烁

2.硬件设计
  2.1.硬件外设芯片选型,原则：
  性能合适
  价格合理
  服务周到
  接口简单

  采集温度要选择一款温度传感器
  例如：
        I2C接口的LM77
        TPAD上选择1-Wire接口的DS18B20温度传感器(咱滴)

  2.2.掌控DS18B20的硬件特性
  1.粗看
    查看DS18B20温度传感器在开发板上所在的位置(咨询硬件工程师)
    确定DS18B20对应的标签“U20”

  2.细看
    首先看底板原理图,根据标签U20找到对应的链接位置P6
    三根管脚：
    VDD:电源
    GND：地
    DQ:数据线,并且连接了一个上拉电阻(默认为高电平)
       并且连接到CPU的XEINT8/GPH1_0

    最后看DS18B20的芯片手册,主要目的掌握软件将来如何访问此硬件

  3.阅读DS18B20芯片手册,关键目的是软件如何访问硬件
    3.1.DS18B20硬件通信接口采用一线式串行总线(1-Wire bus)
    开始解释“一线式串行总线”
    “一线式”：CPU和DS18B20的数据传输只需一根数据线,不像I2C总线
              还有一根时钟线
              数据线上连接一个上拉电阻
    “串行”：CPU和DS18B20是一个"时钟周期"传输1个bit位
    "总线"：在这一根数据线上可以挂接多个DS18B20
    画出简要的连接示意图

    3.2.看图提问题
    1.CPU如何找到总线上某个DS18B20
    2.如果CPU找到了某个DS18B20,CPU如何通过一根数据线和
      DS18B20进行通信呢？
    3.由于没有时钟线,如何保证双方数据传输正常呢
    答：答案都在DS18B20的手册中,重点关注其中的时序图

    3.3.继续阅读DS18B20芯片手册
    1.每一个DS18B20片内都集成了64BIT的ROM,存储对应的序列码(ID)
      类似I2C总线上外设的设备地址,都具有唯一性
    2.每一个DS18B20片内都集成了9字节的SRAM,用于存储相关的数据
      可以把它作为寄存器使用
      SRAM的byte0,byte1分别存放温度的低字节和高字节
      所以温度=byte1 << 8 | byte0

      兴奋：如果CPU要获取DS18B20采集的问题,无非就是CPU想办法
            读取到DS18B20片内的byte1和byte0数据即可
      通过byte0和byte1这两个寄存器的说明,得到以下公式：
      实际温度值=(byte1 << 8 | byte0)*0.0625(摄氏度)
      例如：
      实际温度值=0x0191*0.0625=25.0625摄氏度
    3.CPU访问DS18B20三步骤
      1.CPU发送初始化复位信号
        类似UART的起始位,I2C的START信号
      2.CPU发送ROM命令,用来匹配查找总线上某个DS18B20
        类似I2C的设备地址,SPI总线的片选信号拉低
      3.CPU发送功能性命令,用来和DS18B20进行数据的读写操作等

      明确：GPIO控制权
            谁配输出谁控制
            谁配输入谁释放
            可以同时配输入
            不可以同时配输出

    4.CPU访问DS18B20三步曲之CPU发送初始化复位信号P15
      重中之重：看时序写代码
      参考代码：
      void ds18b20_reset(void)
      {
        gpio_direction_output(..., 0);
        udelay(500);
        gpio_direction_output(..., 1);
        udelay(30);
        gpio_direction_input(...); //释放控制权
        data = gpio_get_value(...);
        if (data == 1)
                failed
        else
                ok
      }

    5.CPU访问DS18B20三步骤之CPU发送ROM命令
      如果只连接一个DS18B20,可以跳过匹配过程,
      CPU只需向总线发送SKIP ROM命令即可,命令字=0xcc(11001100)
      注意：CPU通过一根数据线向总线发送数据,从数据的低位开始传输
      问：由于CPU的处理速度要远远快于DS18B20,CPU如果单纯的发送数据
          0xCC给DS18B20,软件实现很简单,但是DS18B20显然不能处理
          CPU如何通过一根数据线将数据正常的发给DS18B20呢？
      答：重点看P16四个时序图
      void ds18b20_write8(unsigned char data)
      {
                int i;

                for (i = 0; i < 8; i++) {
                        if(data & 0x1) {
                                //根据写1时序图
                                gpio_...(...,0);
                                udelay(3);
                                gpio_...(...,1); //CPU帮上拉电阻拉高
                                udelay(80);
                        } else {
                                //根据写0时序图
                                gpio_...(...,0);
                                udelay(80);
                                gpio_...(...,1);
                                udelay(3);
                        }
                        data = data >> 1;
                }
      }

      unsigned char ds18b20_read8(void)
      {
                unsigned char data = 0;
                unsigned int ret;
                int i;

                for (i = 0; i < 8; i++) {
                    gpio_direction_output(.., 0);
                    udelay(3);
                    gpio_direction_input();//CPU释放控制权,将控制权交给DS18B20或者上拉电阻
                    ret = gpio_get_value(); //采样0/1
                    data |= ret << i;
                }
                return data;
      }

      切记：务必画出5个时序图

    6. CPU访问DS18B20三步骤之CPU发送功能性命令
    转换温度命令：CONVERTT,命令字=0x44
                  如果CPU要获取到DS18B20采集的温度,首先CPU
                  必须向DS18B20发送此命令,让DS18B20硬件上
                  进行采集温度,DS18B20采集的温度会自动放在
                  片内RAM的byte0和byte1中
    READ RAM命令：命令字=0xBE
                  此命令用于CPU读取片内的RAM数据

    阶段总结：目前基本掌握了CPU访问DS18B20的三步骤,但是细节不够详细
              要结合手册中的操作流程图才可以

    7.就以CPU获取DS18B20采样的温度为例,整个流程如下：
    1.CPU向总线发送初始化复位信号
      ds18b20_rest();
    2.CPU向总线发送SKIP ROM命令(0xCC)//不用匹配
      ds18b20_write8(0xcc);
    3.CPU首先向设备发送温度转换命令0x44,DS18B20硬件自动
      启动温度的采集,采集完毕,自动将温度值放在byte0,byte1
      ds18b20_write8(0x44);
    4.CPU再次向总线发送初始化复位信号
      ds18b20_rest();
    5.CPU向总线发送SKIP ROM命令(0xCC)//不用匹配
      ds18b20_write8(0xcc);
    6.CPU向设备发送读取RAM数据的命令0xBE
      ds18b20_write8(0xbe);
    7.CPU开始读取byte0数据
      templ = ds18b20_read8();
    8.CPU再读取byte1数据
      temph = ds18b20_read();
    9.至此采集的温度读取到了,换算处最后的实际温度
      temp = (temph << 8 | templ) * 625;

3.软件设计
  3.1.掌握硬件特性以后,编写DS18B20的设备驱动
  参考驱动：drivers.tar.bz2/ds18b20
                           ds18b20_drv.c //驱动
                           ds18b20_test.c //测试程序
  1.先运行品味驱动的采集温度
    make
    arm-linux-gcc -o ds18b20_test ds18b20_test.c
    cp ds18b20_test ds18b20_drv.ko /opt/rootfs/home/drivers/
    开发板测试：
    insmod /home/drivers/ds18b20_drv.ko
    ls /dev/ds18b20 -lh
    /home/drivers/ds18b20_test //每隔一秒钟打印温度
    手摸一下,吹一下

  2.编写DS18B20驱动
    mkdir /opt/project/drivers/ds18b20
    cd /opt/project/drivers/ds18b20
    vim ds18b20_drv.c
    vim Makefile
    make
    cp ds18b20_drv.ko /opt/rootfs/home/drivers

  3.2.先画出整个温度采集显示的软件框架图
      编写ds18b20硬件操作库
      参考代码：hwlib.tar.bz2/ds18b20
                              ds18b20.h //声明
                              ds18b20.c //定义
                              ds18b20lib_test.c //测试用例
      mkdir /opt/project/hwlib/ds18b20
      cd /opt/project/hwlib/ds18b20
      vim ds18b20.h
      vim ds18b20.c
      vim ds18b20lib_test.c
      arm-linux-gcc -shared -fpic -o libds18b20.so ds18b20.c
      arm-linux-gcc -o ds18b20lib_test ds18b20lib_test.c -L. -lds18b20
      cp libds18b20.so /opt/rootfs/home/applib
      cp ds18b20lib_test /opt/rootfs/home/apptest

      开发板测试：
      insmod /home/drivers/ds18b20_drv.ko
      /home/apptest/ds18b20lib_test

  3.3.在ehome图形界面添加温度显示,每隔5秒显示一次
  0.参考代码：ehome_ds18b20.tar.bz2
  1.利用qtcreator打开mainwindow.ui文件,添加元素
    当前室内温度：25摄氏度
      QLabel       QLabel
  2.利用qtcreator打开mainwindow.h文件，添加
    #include "ds18b20.h"
    在Mainwindow类中添加:
    QTimer *timer; //利用timer定时器实现每隔5秒读取温度
    int m_fd_ds18b20; //ds18b20设备文件描述符
  3.利用qtcreator打开mainwindow.cpp文件，添加
    在构造函数中调用库函数打开设备
    m_fd_ds18b20 = ds18b20_open();

    还要添加定时器的超时对应的槽函数

  4.在定时器超时以后要执行的槽函数中,调用库函数获取温度
    并且在QLabel中显示
    struct ds18b20_cmd ds18b20;
    ds18b20_read(...);
    qlabel->setText(显示);

  5.编译
    cd /opt/project/ehome/
    vim ehome.pro 添加ds18b20头文件和库的支持
    INCLUDEPATH += /opt/project/hwlib/ds18b20
    LIBS += -L/opt/project/hwlib/ds18b20 -lds18b20
    保存退出
    /opt/project/qt/bin/qmake //重新生成Makefile
    make
    cp ehome /opt/rootfs/home/appbin

    开发板测试

项目第四天的任务安排：ehome图形界面显示当前系统的硬件版本号和软件版本号
用户需求：任何一个软件都需要进行显示版本号功能
          类似手机
面试题：谈谈你的智能家居项目
        以版本的查询为例谈谈

实施步骤：
1.分析用户需求
  版本信息的查询
  1.1.版本号定义的格式：
  硬件版本号格式：HYYMMDDXY,例如："H16072100"
  软件版本号格式：SYYMMDDXY,例如："S16072100"

  1.2.版本存储的方式
  1.软件干脆直接写死：
    例如：char *phversion = "H16072100";
          label->setText(phversion);//显示版本信息

  2.以文件的形式
    version.txt 内容
    H16072100
    S16072100
    ehome打开文件,读取文件内容,显示即可

  3.利用EEPROM进行存储
    EEPROM：电可擦除存储器(写之前由硬件自动进行擦除操作)
            不像Nand和NorFlash(写之前需要手动擦除)
            “统称”
            TPAD有一个EEPROM,具体型号为：AT24C02,I2C总线接口
    将版本信息存储到AT24C02,将来查询时,只需从AT24C02中
    读取并且进行显示即可！

2.硬件设计
  理论上应该做硬件芯片的选型
  原则：4个方面
  EEPROM具体型号的芯片种类特别多
  1-Wire接口的
  I2C接口的
  SPI接口的
  TPAD上选择的I2C接口的EEPROM,具体型号为AT24C02
  EEPROM存储区域的划分
  粗看：
        硬件工程师
  细看：
        原理图
        AT24C02的芯片手册(重点关注其中的时序图)

  由于AT24C02属于I2C接口的EEPROM,所以首先要掌握I2C总线的
  硬件特性,此时此刻,玩命开讲I2C特性

3.软件设计
  编写驱动
  参考代码：drivers.tar.bz2/eeprom/
  编写硬件操作库
            hwlib.tar.bz2/eeprom/
  编写ehome界面添加版本显示功能
            ehome_eeprom.tar.bz2

项目第五天任务安排：通过ehome图形界面实现软件的在线升级
                    类似小米手机软件升级通过网络和本地升级
实施步骤：
1.用户需求分析
  以升级TPAD上的zImage为例
  软件的在线升级的方法有两种：
  网络升级：下位机利用网络从服务器上下载要升级的软件,最终
            将新的软件替代原先的老的软件
            画图
            结论：
            1.从服务器利用网络编程下载要升级的zImage到Nand
              上某个分区上
            2.利用某些软件将Nand进行擦除和写入

  本地升级：利用U盘或者SD完成本地升级,首先客户自行到服务器
             上下载要升级的软件zImage到U盘或者SD卡;
             将U盘或者SD卡插入到TPAD上,嵌入式linux系统能够
             识别U盘或者SD卡,最后将U盘或者SD卡上的软件更新到
             对应的位置
             画图
            总结：
            1.如何让TPAD识别U盘上的文件
            2.如果在uboot的命令不能使用的前提下
              擦除和写入数据到Nand上

2.软件设计
  此项目选择本地升级方式来升级zImage
  2.1.明确,关键的技术点
  1.如何让TPAD识别U盘
  2.如何擦和写Nand

  2.2.手动玩U盘,在TPAD上
  实施步骤：
  开发板操作：
  1.TPAD上linux系统正常启动
  2.将zImage拷贝到U盘上,将U盘插入到TPAD的USB口
    观察打印信息,获取到U盘的设备文件(sda1,sda4,sdb4...)
    类似一下信息：
    sda: sda4 //说明U盘的设备文件为sda4

    如果再插入一个U盘,又会出现打印信息,类似以下信息：
    sdb: sdb4 //说明第二块U盘的设备文件为sdb4
  3.手动挂接U盘到根文件系统rootfs某个目录上
    mount -t vfat /dev/sda4 /mnt
    说明：
    将U盘(sda4)挂接到mnt目录,并且指定的文件系统类型为FAT32
    一旦挂接成功将来访问mnt目录就是在访问U盘

    cd /mnt //进入U盘
    ls  //查看U盘的文件
      zImage
  4.如果拔掉U盘,先去卸载U盘
    cd /  //务必先从U盘中退出来,退出mnt目录
    umount /mnt //卸载U盘
    ls /mnt //还能看到U盘的zImage？

 2.3.自动挂接和卸载U盘
 实施步骤：
 1.只需一个配置文件和两个脚本文件即可
   project.rar/usb.tar.bz2/
                        mdev.conf:配置文件
                        usb_insert.sh:挂接使用的脚本
                        usb_remove.sh:卸载使用的脚本
 2.给rootfs添加mdev.conf配置文件
   cp mdev.conf /opt/rootfs/etc/

   mdev.conf说明：
   插入U盘时执行：
   sd[a-z][0-9] 0:0 666 @/home/usb/usb_insert.sh /dev/$MDEV

   拔出U盘时执行：
   sd[a-z] 0:0 666 $/home/usb/usb_remove.sh

   第一列：U盘的设备文件,利用正则表达式
   第二列：用户：组
   第三列：访问权限
   第四列：
          @：插入U盘以后要执行的命令/home/usb/usb_insert.sh
          $: 拔出U盘之前要执行的命令/home/usb/usb_remove.sh
   第五列：
         /dev/$MDEV:给脚本传递的参数
                    $MDEV就是U盘的设备文件sda4
                    /dev/$MDEV=/dev/sda4

 3.给rootfs添加两个脚本
   mkdir /opt/rootfs/home/usb
   mkdir /opt/rootfs/mnt/usb

   cp usb_insert.sh /opt/rootfs/home/usb
   cp usb_remove.sh /opt/rootfs/home/usb
   chmod 777 /opt/rootfs/home/usb/*

 4.开发板测试
   1.重启TPAD
   2.插入U盘,查看U盘是否自动完成挂接,只需执行：
     mount  //查看一下类似信息：
     /dev/sda4 on /mnt/usb //表明挂接成功
     cd /mnt/usb //进入U盘
     ls //查看U盘的内容
   3.拔出U盘
     cd / //务必先退出U盘
     拔出U盘
     mount //查看是否还有以下信息：
     /dev/sda4 on /mnt/usb //应该消失不见

  2.4.问：如何在嵌入式linux系统正常运行的情况下(uboot早已结束)
          能对Nand某个分区进行擦除和写入操作呢？
      答：移植Nand的操作工具(命令)对应的开源软件
  实施步骤：
  1.获取源码：project.rar/mtd-utils-mtd-utils.tar

  2.源码操作
    mkdir /opt/project/mtd/
    cp mtd-utils-mtd-utils.tar.bz2 /opt/project/mtd
    cd /opt/project/mtd
    tar -xvf mtd-utils-mtd-utils.tar.bz2
    cd mtd-utils-mtd-utils //进入工具的源码根目录
    make //编译,生成一个arm-linux新目录
    cd arm-linux
    ls
        flash_erase:擦除Nand命令
        nandwrite:写Nand命令
        nanddump:读Nand命令

  3.拷贝到rootfs
    cp nandwrite /opt/rootfs/sbin
    cp flash_erase /opt/rootfs/sbin

  4.开发板上手动擦除和写入zImage到Nand上
    开发板执行：
    cat /proc/mtd //查看Nand的分区信息
    mtd0:... .... "uboot"
    mtd1:... .... "kernel"
    mtd2:... .... "rootfs"
    mtd3:.. ..... "userdata"
    说明：zImage存在Nand的第二分区mtd1

    ls /dev/mtd* -lh //查看Nand的分区设备文件
    mtd0:第一分区的字符设备文件
    mtdblock0:第一分区的块设备文件
    mtd1:第二分区的字符设备文件
    mtdblock1:第二分区的块设备文件
    ...

    切记：nand的操作命令flash_erase,nandwrite只针对Nand字符设备文件

    flash_erase /dev/mtd1 0 0 //将zImage所在的分区mtd1全部擦除
    nandwrite -p /dev/mtd1 /mnt/usb/zImage //将U盘中的zImage写入到第二分区mtd1
                                           //前提是U盘挂接成功

    注意：以后升级不可能让用户操作以上命令,需要通过点击界面自动完成

  2.5.编写升级软件操作库
      参考代码：hwlib.tar.bz2/update_kernel
  2.6.编写ehome图形界面,添加升级按钮,当用户点击按钮
      自动将U盘中的zImage写入到Nand上
      参考代码：ehome_update_kernel.tar.bz2

第六天任务安排：MP3播放器实现
1.用户需求
  通过ehome实现MP3播放器,实现音乐播放,暂停,上一首,下一首,
  音量的大小调节

2.软件设计
  移植一堆的MP3播放器的开源软件
  具体参见tcar.doc文档之MP3播放器移植
  这套开源软件的框架：画图


项目内容：小车运动控制和摄像头的摆动
用户需求：
1.实现小车的前进,后退,左转,右转
2.摄像头的上下摆动和左右摆动

硬件设计：
1.利用直流电机控制小车的运动
  明确：CPU不能直接控制直流电机
        选择一个驱动模块,L298N,用于驱动直流电机
  研究对象转移：
  1.CPU如何操作2个直流电机
  2.CPU如何操作L298N
  3.CPU如何操作6根信号线
  4.具体的操作参看PPT的表格
  总结：采用GPIO通信接口

2.利用舵机实现摄像头的摆动
  直流电机的角度控制相当难
  采用舵机即可解决
  能够实现按照一定的角度转动
  TPAD选择MG995舵机
  总结：型号MG995,GPIO(PWM)通信方式

简历
个人介绍：

专业技能：

项目经验：先写以前的项目经验或者毕业设计或者参赛作品
项目名称：智能家居
硬件平台：S5PV210(ARM),1G DDR,1G SLC Nand,DM9000网卡
          8个独立式按键(GPIO接口),AT24C02存储器(I2C接口)
          DS18B20温度传感器(1-Wire),L298N驱动模块(GPIO接口)
          MG995舵机(PWM)...
          原则：型号+功能(接口),目的：刺激他
软件平台：arm-linux-gcc-4.4.6
          u-boot-1.3.4
          linux-2.6.35.7
          busybox-1.21.1
          QT-4.8.4
          原则：软件名+版本信息

负责内容：
        1.
        2.编写DS18B20(1-Wire接口)温度传感器驱动,实现温度的
          采集告警
        3.编写AT24C02(I2C接口)存储器驱动,实现软件和硬件
          版本的存储功能
        4.编写MG995(PWM)舵机驱动,实现摄像头的水平和垂直摆动


        原则：编写 + 型号(接口)功能,实现...

个人特长


60智能家居项目
用户需求
1.	终端界面每隔5秒刷新显示当前温度值，单位摄氏度；温度高于32摄氏度，启动报警器同时让LED1每隔200ms进行闪烁；
2.	终端界面每隔10秒刷新显示当前电压值（用于模拟烟雾浓度），单位伏；电压高于2.5伏，启动报警器同时让LED2每隔400ms闪烁；
3.	终端界面显示红外监控状态，监控KEY_UP按键（用于模拟红外传感器），如果按下（有贼），终端界面显示异常，否则正常；启动报警器同时让LED1和LED2每隔1000ms闪烁；
4.	终端界面显示日期时间，显示格式：2014年10月25日 10时14分12秒  星期六；
5.	终端界面能够进行软件在线升级操作；
硬件设计
CPU：S5PV210
内存：1G
闪存：SLC 1G Nand
网卡：DM9000,100M
串口：2个，调试和数据通信
USB：4个，外接U盘和移动硬盘
DS18B20：温度传感器（单总线接口 1-Wire）
ADC:模数转换器，分辨率10位或者12位
独立式按键：8个
LED灯：2个
蜂鸣器：1个
AT24C02：EEPROM存储器，容量256字节
LCD显示屏：分辨率800*480
电容触摸屏：GT811
软件设计
交叉编译器（虚拟机已有）
采用官方交叉编译器；
编译器版本:4.4.6
编译器路径:/home/tarena/workdir/toolchain/opt/S5PV210-crosstools/4.4.6
设置交叉编译器环境变量:
sudo vim /etc/environment,在“PATH”中添加如下信息：
添加之前：/usr/local/sbin: /usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games"
添加之后：
/home/tarena/workdir/toolchains/opt/S5PV210-crosstools/4.4.6/bin:/usr/local/sbin: /usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games"
启动交叉编译器环境变量
source /etc/environment
验证：arm-linux-gcc –v //查看是否是4.4.6版本编译器
UBOOT移植(注意无需移植)
采用官方UBOOT源码；
源码包u-boot_CW210_1.3.4.tar.bz2
源码存放路径：/opt/uboot/
源码操作：
解压源码:tar –xvf u-boot_CW210_1.3.4.tar.bz2
清除源码配置文件和目标文件：make distclean
配置源码:make cw210_config
make all
USB烧写固化u-boot.bin
Linux内核移植(注意无需移植)
采用官方Linux内核源码；
源码包Kernel_2.6.35.7_CW210_for_Linux_v1.0.tar.gz
源码存放路径：/opt/kernel
源码操作:
解压源码:tar –xvf Kernel_2.6.35.7_CW210_for_Linux_v1.0.tar.gz
清除源码配置文件和目标文件：cd /opt/kernel && make distclean
配置源码:cp config_CW210_linux_V1.0   .config
make menuconfig //保存退出
make zImage
cp arch/arm/boot/zImage    /tftpboot/
根文件系统制作
采用busybox开源软件制作
busybox源码包：busybox-1.21.1.tar.bz2
源码存放目录：/opt/busybox/
源码操作:
解压源码：tar –jxvf busybox-1.21.1.tar.bz2
cd busybox-1.21.1
配置源码:make menuconfig
重新定制模块操作命令
Linux Module Utilities  --->
          [*] Simplified modutils (NEW)  //去掉
[*]   insmod    //添加
[*]   rmmod  //添加、
[*]   lsmod//添加
[*]   modprobe   //添加
[*]     Blacklist support//添加
[*]   depmod   //添加
取出闪存flash操作命令
Miscellaneous Utilities  --->
         [*] nandwrite (NEW) //去掉
                 [*] nanddump (NEW)     //去掉
保存退出
修改Makefile文件
vim Makefile
将CROSS_COMPILE ?= 修改为CROSS_COMPILE=arm-linux-
将ARCH ?= $(SUBARCH)修改为ARCH=arm
编译和安装 make && make install
默认安装当前目录的_install目录：ls  _install
用file命令检查编译结果busybox可执行文件的属性：file _install/bin/busybox,打印信息如下：ELF 32-bit LSB executable, ARM, version 1 (SYSV), dynamically linked (uses shared libs), stripped //红色字体的内容必须为ARM，而不是intel X86
进入安装目录：cd  _install
创建目录：
mkdir dev lib etc/init.dproc syshome mnt var tmp root  -p
添加系统启动配置文件
vim etc/inittab //添加如下内容
::sysinit:/etc/init.d/rcS
::respawn:-/bin/sh
::ctrlaltdel:/sbin/reboot
::shutdown:/bin/umount -a –r
保存退出
添加文件系统配置文件
vim etc/fstab //添加如下内容
 proc    /proc        proc    defaults     0  0
 tmpfs   /tmp        tmpfs  defaults     0   0
 sysfs    /sys        sysfs   defaults        0   0
 tmpfs   /dev       tmpfs  defaults        0   0
说明：sysfs,procfs,tmpfs都是虚拟文件系统，文件系统相关的信息存在内存中。
保存退出
添加系统启动服务配置脚本
vim etc/init.d/rcS //添加内容如下
/bin/mount -a
    mkdir /dev/pts
    mount -t devpts devpts /dev/pts
    echo /sbin/mdev > /proc/sys/kernel/hotplug
    mdev –s
保存退出
修改rcS文件权限
chmod 777 etc/init.d/rcS
添加 busybox运行时所需动态库
动态库添加原则：应用软件需要哪些动态库，就添加，不相关不做添加，以便节省闪存空间
应用软件编译连接需要的动态库在交叉编译器中获取：
动态库路径：/home/tarena/workdir/toolchains/opt/S5PV210-crosstools/4.4.6/arm-concenwit-linux-gnueabi/lib/
查看busybox可执行程序所需的动态库
arm-linux-readelf -a bin/busybox | grep "Shared" //提示信息如下：
0x00000001 (NEEDED) Shared library:      [libm.so.6]
0x00000001 (NEEDED) Shared library:      [libc.so.6]
可知需要动态库为：libc和libm两个动态库
拷贝所需动态库到根文件系统lib目录下
find /home/tarena/workdir/toolchains/opt/S5PV210-crosstools/4.4.6/arm-concenwit-linux-gnueabi/lib/ \( -name "libc-*"-o -name "libc.so*" \) -exec cp -frd {}  lib/  \;  //拷贝标准C库
find /home/tarena/workdir/toolchains/opt/S5PV210-crosstools/4.4.6/arm-concenwit-linux-gnueabi/lib/ \( -name "libm-*"-o -name "libm.so*" \) -exec cp -frd {}  lib/  \; //拷贝数学运算库
find /home/tarena/workdir/toolchains/opt/S5PV210-crosstools/4.4.6/arm-concenwit-linux-gnueabi/lib/ \( -name "ld-*"\) -exec cp -frd {}  lib/  \;   //拷贝动态链接库

测试制作好的根文件系统
备份原有的根文件系统rootf:mv /opt/rootfs /opt/rootfs_bak
cp _install /opt/rootfs –frd  //将安装制作好的根文件系统_install拷贝为/opt/rootfs
注意添加NFS网络服务的支持：sudo vim /etc/exports 添加如下语句：
/opt/rootfs *(rw,sync,no_root_squash)
保存退出
重启网络服务sudo /etc/init.d/nfs-kernel-server restart
uboot中设置NFS网络启动参数
setenv bootargs root=/dev/nfs nfsroot=192.168.1.8:/opt/rootfs ip=192.168.1.110:192.168.1.8:192.168.1.1:255.255.255.0::eth0:on init=/linuxrc console=ttySAC0,115200
saveenv
重启开发板测试挂接制作的rootfs
查看根文件系统的大小: du /opt/rootfs –lh  (一般情况下为3.2M)
tslib移植
tslib作用：
在采用触摸屏的移动终端中，触摸屏性能的调试是个重要问题之一，因为电磁噪声的缘故，触摸屏容易存在点击不准确、有抖动等问题。tslib是一个开源的程序，能够为触摸屏驱动获得的采样提供诸如滤波、去抖、校准等功能，通常作为触摸屏驱动的适配层，为上层的应用（例如QT）提供了一个统一的接口。
tslib源码包：tslib.tar.gz
源码存放目录：/opt/project/source/
源码移植：
进入源码目录:cd /opt/project/source
解压源码: tar –xvf tslib.tar.gz
cd tslib
执行./autogen.sh 生成配置文件configure
执行echo  "ac_cv_func_malloc_0_nonnull=yes"> tmp.cache
执行./configure --host=arm-linux --cache-file=tmp.cache   --prefix=/opt/project/tslib  //指定安装的目录为/opt/project/tslib目录
执行make && make install //编译安装
编译安装成果: cd /opt/project/tslib && ls –lh 提示信息如下：
etc bin lib include //生成四个目录
etc:用于配置tslib
bin:tslib的测试程序，运行在ARM开发板上
lib:动态库，供QT使用，用于获取坐标等信息
include：头文件，用于编译源码
修改tslib的配置文件ts.conf
vim etc/ts.conf   //打开配置文件，进行如下操作：
在“module pthres pmin=1”前一行添加“module_raw input”语句 （需要注意的是module开头的几行前面不能有空格. )
开发板测试tslib：
编译tslib生成目标文件存放目录:/opt/rootfs/home/tslib/
mkdir /opt/rootfs/home/tslib/
cp etc  /opt/rootfs/home/tslib/ -frd    //拷贝运行时配置文件
cp bin  /opt/rootfs/home/tslib/ -frd  //拷贝触摸屏测试软件
cp lib   /opt/rootfs/home/tslib/ -frd //拷贝tslib动态库文件
连接触摸屏和开发板，获取触摸屏设备文件
开发板上执行hexdump /dev/input/event0，然后用手指点击触摸屏，看串口终端是否有打印信息，如果没有，event0不是触摸屏的设备文件，再执行：hexdump /dev/input/event1,同样点击屏幕看是否有打印信息，如果没有，再次更换设备文件为event2,直到找到触摸屏的设备文件，例如：hexdump /dev/input/event3，有打印信息，至此触摸屏的设备文件为/dev/input/event3.
添加使用tslib时的环境变量
vim /opt/rootfs/etc/profile 添加如下内容：
export TSLIBDIR=/home/tslib
export TSLIB_CONSOLEDEVICE=none
export TSLIB_FBDEVICE=/dev/fb0
export TSLIB_TSDEVICE=/dev/input/event3 //根据上一步骤找触摸屏的设备文件，不能有错！
export TSLIB_CALIBFILE=$TSLIBDIR/etc/pointercal
export TSLIB_CONFFILE=$TSLIBDIR/etc/ts.conf
export TSLIB_PLUGINDIR=$TSLIBDIR/lib/ts
export PATH=/home/tslib/bin:$PATH
export LD_LIBRARY_PATH=/home/tslib/lib:$LD_LIBRARY_PATH
保存退出
重启开发板
添加使用tslib时的标准系统库(libdl)
find /home/tarena/workdir/toolchains/opt/S5PV210-crosstools/4.4.6/arm-concenwit-linux-gnueabi/lib/ \( -name "libdl-*"-o -name "libdl.so*"\) -exec cp -frd {}/opt/rootfs/lib/ \;重启开发板，进行触摸屏校准
开发板运行: ts_calibrate  //此时屏幕有一个十字光标，用手指精确点击光标，点击光标5次，完成校准，生成一个校准文件保存在home/tslib/etc/pointercal
开发板运行:ts_test  //点击屏幕”Draw”，写字，画画
至此tslib移植成功，触摸屏测试成功！
QT移植
QT介绍:
移植QT目的:
移植注意事项：必须先移植好tslib
源码包：qt-everywhere-opensource-src-4.8.4.tar.gz
源码包存放目录：/opt/project/source/
源码移植：
cd /opt/project/source/
解压源码
tar –xvf  qt-everywhere-opensource-src-4.8.4.tar.gz
mv qt-everywhere-opensource-src-4.8.4 qt_src
cd  qt_src
修改配置文件:
vim  mkspecs/qws/linux-arm-g++/qmake.conf 操作如下：
原先的内容：
QMAKE_CC = arm-linux-gcc
QMAKE_CXX = arm-linux-g++
QMAKE_LINK = arm-linux-g++
QMAKE_LINK_SHLIB = arm-linux-g++
修改为： //添加tslib动态库的支持
QMAKE_CC = arm-linux-gcc -lts
QMAKE_CXX = arm-linux-g++ -lts
QMAKE_LINK = arm-linux-g++ -lts
QMAKE_LINK_SHLIB = arm-linux-g++ -lts
编译源码:
下载build.sh编译配置脚本，放置在源码目录/opt/project/source/qt_src中
执行./build.sh
会提示输入"c"或者"o",选择"o"开始配置
make  //编译，大约3小时
make install //安装
交叉编译QT，生成的目标文件自动安装在/opt/project/qt目录中
ls /opt/project/qt/ 信息如下
bin  include  lib  mkspecs  plugins  translations
安装中文字体库
字体库文件:wqy-zenhei.ttc
删除QT自带字体库
rm /opt/project/qt/lib/fonts/* -fr
安装中文字体库
cp wqy-zenhei.ttc /opt/project/qt/lib/fonts/
安装编译出来的QT库到跟文件系统/opt/rootfs中
QT库的存放目录：/opt/rootfs/home/qt
mkdir /opt/rootfs/home/qt
拷贝QT库
cp /opt/project/qt/lib  /opt/rootfs/home/qt –frd
cp /opt/project/qt/plugins  /opt/rootfs/home/qt  -frd
添加QT运行时的环境变量
vim  /opt/rootfs/etc/profile, 添加如下内容
export QTDIR=/home/qt
export QWS_MOUSE_PROTO="Tslib:/dev/input/event3"  #dev/input/event3为触摸屏设备文件
export QWS_SIZE=800X480
export QT_QWS_FONTDIR=$QTDIR/lib/fonts
export QT_PLUGIN_PATH=$QTDIR/plugins
exportQWS_DISPLAY="LinuxFB:mmWidth180:0"
export LD_LIBRARY_PATH=$QTDIR/lib:$LD_LIBRARY_PATH
保存退出，重启开发板
执行env命令，查看环境变量是否生效
添加QT运行时的系统库
find /home/tarena/workdir/toolchains/opt/S5PV210-crosstools/4.4.6/arm-concenwit-linux-gnueabi/lib/ \( -name  "libpthread-*"  -o  -name  "libpthread.so*"  \)  -exec  cp  -frd  {}  /opt/rootfs/lib/  \;
find /home/tarena/workdir/toolchains/opt/S5PV210-crosstools/4.4.6/arm-concenwit-linux-gnueabi/lib/ \( -name  "libstdc++-*"  -o  -name  "libstdc++.so*"  \)  -exec  cp  -frd  {}  /opt/rootfs/lib/  \;
find /home/tarena/workdir/toolchains/opt/S5PV210-crosstools/4.4.6/arm-concenwit-linux-gnueabi/lib/ \( -name  "librt-*"  -o  -name  "librt.so*"  \)  -exec  cp  -frd  {}  /opt/rootfs/lib/  \;
find /home/tarena/workdir/toolchains/opt/S5PV210-crosstools/4.4.6/arm-concenwit-linux-gnueabi/lib/ \( -name  "libgcc_s-*"  -o  -name  "libgcc_s.so*"  \)  -exec  cp  -frd  {}  /opt/rootfs/lib/  \;
开发板上测试QT
测试源码包:美女摇奖游戏 game.tar.bz2
源码存放目录:/opt/project/game
可执行文件存放目录:/opt/rootfs/home/apptest/
mkdir /opt/project/game
cd /opt/project/game
tar –jxvf game.tar.bz2
cd game
清除源码目标和配置文件:make clean
生成pro工程文件:/opt/project/qt/bin/qmake –project   //注意不要直接qmake，为什么?
生成Makefile文件:/opt/project/qt/bin/qmake
编译：make
创建可执行文件存放目录:mkdir /opt/rootfs/home/apptest
cp game  /opt/rootfs/home/apptest
开发板上运行: /home/apptest/game –qws //看QT游戏能否启动
驱动开发
需要开发的驱动如表所示：
硬件对象	2个LED	1个蜂鸣器	1个DS18B20温度传感器	1个ADC 	8个按键	1个AT24C02存储器
功能	告警指示	报警	采集室内温度	用于采样电压模拟信号，转换电压值作为模拟烟雾浓度	用于玩游戏和模拟红外传感器	存储软件和硬件版本信息
驱动文件名	led_drv.c	beep_drv.c	ds18b20_drv.c	adc_drv.c	btn_drv.c	at24c02_drv.c
源码存放路径	/opt/project/drivers/led	/opt/project/drivers/beep	/opt/project/drivers/ds18b20	/opt/project/drivers/adc	/opt/project/drivers/btn	/opt/project/drivers/eeprom
ko目标存放目录	/opt/rootfs/home/drivers
封装底层硬件操作库函数
底层硬件库函数的作用：用于图形界面QT调用库函数间接操作访问硬件设备，是连接QT和设备的桥梁
软件操作流程：

LED设备底层硬件操作库实现过程：
用户需求：开发板运行QT软件，能够开关灯
源码存放目录：/opt/project/hwlib/led
mkdir /opt/project/hwlib/led  -p
编写头文件led.h,源码如下：
#ifndef __LED_H
#define __LED_H

#ifdef __cplusplus
extern "C" {
#endif

/*头文件*/
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <fcntl.h>

/*调试宏*/
#define DEBUG

#ifdef DEBUG
#define pr_debug(fmt, ...) printf(fmt, ##__VA_ARGS__) //打开调试信息
#else
#define pr_debug(fmt, ...)  //关闭调试信息
#endif  //以后打印不用printf用pr_debug

/*设备文件名*/
#define LED_DEVFILE_NAME	"/dev/myled"

/*LED数据结构
 应用软件利用此数据结构进行访问设备
*/
struct led_cmd {
    unsigned char whichled; //指定哪个灯，第一个灯此值为1,第二个灯此值为2
    unsigned char cmd;//亮，灭命令;开灯此值设置为1,关灯此值设置为0
    unsigned char reserved[2];
};

/*LED控制命令宏*/
#define LED_ON	0x100001
#define LED_OFF	0x100002

/*
        函数功能:打开LED设备
        参数：无
        返回值：打开设备成功，返回设备文件描述符fd;失败返回-1
*/
extern int led_open(void);

/*
        函数功能:关闭LED设备
        参数：
                @fd:设备文件描述符
        返回值：无
*/
extern void led_close(int fd);

/*
        函数功能：控制LED亮，灭
        参数：
                @fd:设备文件描述符;
                @cmd:控制LED开关命令
        返回值：开，关灯结果，操作成功，返回0，否则返回-1
*/
extern int led_config(int fd, struct led_cmd *cmd);

#ifdef __cplusplus
}
#endif

#endif
编写库函数实现源文件led.c,源码如下：
#include "led.h"

int led_open(void)
{
        int fd = open(LED_DEVFILE_NAME, O_RDWR);
        if (fd < 0) {
                pr_debug("open led device failed.\n");
                return -1;
        }
        pr_debug("open led device successfully!\n");
        return fd;
}

void led_close(int fd)
{
        pr_debug("close led device...\n");
        close(fd);
}

int led_config(int fd, struct led_cmd *ledctrl)
{
        int ret;

        if (fd < 0) {
                pr_debug("fd is invalid.\n");
                return -1;
        }

        if (ledctrl == NULL) {
            pr_debug("ledctrl is invalid.\n");
            return -1;
        }

        if (ledctrl->whichled != 1 && ledctrl->whichled != 2) {
                pr_debug("whichled is invalid.\n");
                pr_debug("whichled value must be 1 or 2\n");
                return -1;
        }

        if (ledctrl->cmd != 1 && ledctrl->cmd != 0) {
                pr_debug("cmd is invalid.\n");
                pr_debug("cmd value must be 1 or 0\n");
                return -1;
        }

        if (ledctrl->cmd == 1)
                ret = ioctl(fd, LED_ON, &ledctrl->whichled);
        else
                ret = ioctl(fd, LED_OFF, &ledctrl->whichled);
        if (ret == -1) {
                pr_debug("ioctl led device failed.\n");
        }
        pr_debug("ioctl led device successfully!\n");
        return ret;
}

制作为动态库：
arm-linux-gcc -shared -fpic -o libled.so led.c led.h
动态库存放目录:/opt/rootfs/home/applib
mkdir /opt/rootfs/home/applib
cp libled.so /opt/rootfs/home/applib/

编写库函数测试用例ledlib_test.c,源码如下：
#include "led.h"

int main(int argc, char *argv[])
{
        int fd;
        struct led_cmd ledctrl;

        if (argc != 3) {
                printf("usage:\n %s <on|off><1|2>\n", argv[0]);
                return -1;
        }

        fd = led_open();
        if (fd < 0)
                return -1;

        ledctrl.whichled = strtoul(argv[2], NULL, 0);

        if (!strcmp(argv[1], "on")) {
            ledctrl.cmd = 1;
        } else {
            ledctrl.cmd = 0;
        }

        if (led_config(fd, &ledctrl) == -1)
            return -1;

        led_close(fd);

        return 0;
}

编译测试用例:
arm-linux-gcc -o ledlib_test  ledlib_test.c -L/opt/project/hwlib/led –lled
测试用例可执行文件存放目录:/opt/rootfs/home/apptest
mkdir /opt/rootfs/home/apptest
cp libled_test /opt/rootfs/home/apptest

添加动态库环境变量:
vim /opt/rootfs/etc/profile ,在文件最后添加如下内容：
export LD_LIBRARY_PATH=/home/applib:$LD_LIBRARY_PATH
重启开发板
运行测试用例:
/home/apptest/ledlib_test on 1  //开第一个灯

基于QT图形界面实现开关灯
图形界面包含操作元素：一个开灯按钮，一个关灯按钮
界面大小:800*480
界面图标：添加至/opt/project/ehome/images
功能：点击图形界面按钮，实现开关灯操作
源码存放目录:/opt/project/ehome
可执行文件ehome存放目录：/opt/rootfs/home/appbin
Tarena虚拟机安装QT开发环境
QT开发工具包:qt-ubuntu.tar.bz2
或者在windows下安装QT开发工具：qt-opensource-windows-x86-mingw482_opengl-5.3.2.exe
下载安装即可
ubuntu安装QT开发环境步骤：
mkdir /home/tarena/qt/
cp qt-ubuntu.tar.bz2 /home/tarena/qt
tar –xvf qt-ubuntu.tar.bz2
sudo dpkg –i  *
打开qtcreator开发工具：
创建ehome工程
添加开，关按钮控件和背景图片，参看视频
添加硬件库函数使用的头文件
添加文件描述m_fd_led定义
构造函数中可以打开设备
槽函数中开关设备
具体参看视频
交叉编译：
        cd /opt/project/ehome
/opt/project/qt/bin/qmake –project //生成工程文件，只需做一次，以后不需要再生成
修改工程文件，添加动态库的支持
vim /opt/project/ehome/ehome.pro
添加如下内容：
INCLUDEPATH += /opt/project/hwlib/led  //头文件
LIBS += -L/opt/project/hwlib/led –lled  //动态库
其他库依次按此法添加，例如beep：
INCLUDEPATH += /opt/project/hwlib/beep  //头文件
LIBS += -L/opt/project/hwlib/beep –lbeep  //动态库
保存退出
执行/opt/project/qt/bin/qmake  生成Makefile文件
make 编译
cp /opt/project/ehome/ehome /opt/rootfs/home/appbin
开发板测试/home/appbin/ehome –qws //实现开关灯
统软件部署
系统软件组成部分：
u-boot.bin:系统启动软件
zImage:内核软件
根文件系统rootfs:根文件系统，包含库，命令，配置文件等
userdata目录：包含用户软件，驱动模块，脚本，自己封装的动态库，测试用例，应用软件
注意：rootfs和userdata是两个目录，最后需要制作为镜像文件
rootfs根文件系统目录组成部分：
lib:存放系统标准库，不包含QT库，tslib库和自己封装的库
etc:系统启动配置文件，fstab,profile,inittab,rcS
bin,sbin,usr:系统运行命令
home：作为nandflash分区的挂节点
mnt：作为U盘或者SD卡挂节点
dev：存放设备文件
proc，sys，tmp，var：作为procfs，sysfs虚拟文件系统的挂节点
userdata用户数据软件目录组成部分：
userdata目录只包含自己产品软件内容
目录位置：/opt/project/
创建目录：mkdir /opt/project/userdata
创建userdata目录内容：
cd /opt/project/userdata
mkdir qt  tslib appbin applib apptest scripts drivers
各个目录说明：
qt目录:包含移植生成的库文件
cp /opt/project/qt/lib  qt/  -frd  //qt标准库
cp /opt/project/qt/plugins qt/ -frd  //图形处理库
tslib目录：包含移植tslib生成的库，命令和配置文件
cp /opt/project/tslib/bin tslib/ -frd//触摸屏校准测试工具
cp /opt/project/tslib/etc tslib/ -frd //配置文件
cp /opt/project/tslib/lib tslib/ -frd //动态库
appbin目录：存放ehome可执行文件
cp /opt/project/ehome/ehome  appbin/
apptest目录：存放测试用例
find  /opt/project/hwlib/  -name  *_test  -exec cp {} apptest/  \;
applib目录：存放自己制作封装的动态库
find  /opt/project/hwlib/  -name  *.so  -exec cp {} applib/  \;
drivers目录：存放驱动目标文件
find  /opt/project/drivers/  -name  *.ko  -exec cp {} drivers/  \;
scripts目录：存放应用软件启动命令
mv /opt/rootfs/etc/profile scripts/run.sh  //复制profile脚本文件
chmod 777 scripts/run.sh
vim scripts/run.sh  在文件最后添加如下内容：
#自动加载模块
find  /home/drivers/  -name *.ko  -exec insmod {}  \;
#自动运行可执行文件
/home/appbin/ehome -qws & //后台运行
根文件系统rootfs相关配置文件修改：
vim /opt/rootfs/etc/profile 添加如下内容
.  /home/scripts/run.sh  #注意“.”后要跟空格键
保存退出
利用NFS网络文件系统测试userdata是否能使用，是否能够实现软件自启动：
备份原先根文件系统rootfs/home/下的内容：
mv  /opt/rootfs/home /opt/project/home_bak
cp /opt/project/userdata  /opt/rootfs/home  -frd
cd /opt/rootfs/home/
ls  //可以看到userdata中的各个目录
重启开发板
看LCD是否显示ehome的界面
ps //查看进程信息
env //查看qt,tslib的环境变量是否生效
lsmod //查看驱动模块是否加载
如果测试成功，说明userdata没有问题,将/opt/rootfs/home/下的内容删除
rm  /opt/rootfs/home/* -fr
至此rootfs和userdata彻底分开，根文件系统和用户软件彻底分开
将rootfs和userdata两个目录分别制作为镜像文件进行烧写：
镜像文件对应文件系统类型的选择，采用：
rootfs制作为rootfs.img镜像,采用的文件系统类型为cramfs,只读，用于保护根文件系统；
userdata制作为userdata.img镜像,采用的文件系统类型为yaffs2,可读写；
配置linux内核，支持两种文件系统：
cd  /opt/kernel
make menuconfig
  File Systems->
         [*] Miscellaneous filesystems  --->
<*>Compressed ROM file system support (cramfs) //支持cramfs文件系统
  File Systems->
         [*] Miscellaneous filesystems  --->
        <*>   YAFFS2 file system support //已经支持
保存退出
make zImage
cp arch/arm/boot/zImage /tftpboot/
重启开发板
cat /proc/filesystems //查看是否支持cramfs和yaffs2
将rootfs和userdata分别制作为cramfs和yaffs2文件系统镜像：
目录            镜像文件              文件系统类型
rootfs        rootfs.img          cramfs
userdata    userdata.img     yaffs2
rootfs.img镜像制作步骤：
cd /opt/
mkfs.cramfs rootfs   rootfs.img
cp rootfs.img /tftpboot
userdata.img镜像制作步骤：
从ftp下载mkyaffs2image工具到虚拟机中:
sudo cp  mkyaffs2image  /usr/sbin
sudo chmod 777 /usr/sbin/mkyaffs2image
cd /opt/project
mkyaffs2image userdata userdata.img
chmod 666 userdata.img
cp userdata.img /tftpboot
至此四个软件包都准备就绪：
u-boot.bin,zImage,rootfs.img,userdata.img
存放目录:/tftpboot
nandflash分区规划,用于部署镜像文件：
0----------2M----------7M----------17M------------剩余
  uboot     zImage   rootfs.img  userdata.img
注意：镜像文件大小要小于各个分区的大小！请确认！
修改nandflash的分区表
cd /opt/kernel
vim drivers/mtd/nand/s3c_nand.c 找到分区表，修改为如下分区表信息：
struct mtd_partition s3c_partition_info[ ] = {
//第一分区信息
{
       .name           = "uboot", //分区的名称
       .offset         = (0), //分区的起始地址
       .size           = （SZ_1M*2）, //分区的大小
},
//第二分区信息
{
     .name           = "kernel",
     .offset         = MTDPART_OFS_APPEND, //追加
     .size           = （SZ_1M*5）,
},
//第三分区信息
{
         .name           = "rootfs",
         .offset         = MTDPART_OFS_APPEND,
         .size           = (SZ_1M*10),
},
//第四分区信息
{
         .name           = "userdata",
         .offset         =MTDPART_OFS_APPEND,
         .size           = MTDPART_SIZ_FULL //剩余
}
｝；
保存退出
make zImage
cp arch/arm/boot/zImage /tftpboot
重启开发板
cat /proc/mtd //查看分区表
ls /dev/mtd* -lh //查看字符设备文件和块设备文件
/dev/mtd0:第一个分区的字符设备文件
/dev/mtdblock0:第一个分区的块设备文件
将zImage,rootfs.img,userdata.img烧写到nand上：
烧写方法有两种，一种通过uboot，另一种通过mtd工具
利用uboot来进行烧写的步骤：
烧写zImage:
tftp 50008000 zImage
nand erase 200000 500000
nand write 50008000 200000 500000
烧写rootfs.img
tftp 50008000 rootfs.img
nand erase 700000 a00000
nand write 50008000 700000 a00000
烧写userdata.img
tftp 50008000 userdata.img
nand erase 1100000
nand write.yaffs 50008000 1100000 $filesize
或者
nand write.yaffs 50008000 1100000 $(filesize)

设置本地启动的参数信息：
setenv bootcmd nand read 50008000 200000 500000 \; bootm 50008000
setenv bootargs root=/dev/mtdblock2 init=/linuxrc console=ttySAC0,115200 rootfstype=cramfs
saveenv
重启开发板，看rootfs是否能挂接，所在第三块分区
验证根文件系统是否为只读：
cd  /
mkdir helloworld //看是否能创建目录
手动挂接存放userdata数据的第四块分区到根文件系统home目录：
在开发板上执行：
mount -t yaffs2 /dev/mtdblock3 /home
mount //看是否挂接成功
cd /home //进入第四块分区
ls //查看第四块分区的内容,是否有之前userdata目录的内容
.  /home/scripts/run.sh  //手动运行软件启动脚本，"."后跟一个空格
自动挂接存放userdata数据的第四块分区到根文件系统home目录：
vim /opt/rootfs/etc/init.d/rcS，在文件最后添加：
mount -t yaffs2 /dev/mtdblock3 /home
ifconfig eth0 192.168.1.110
ifcofig lo 127.0.0.1
保存退出
重新制作rootfs为rootfs.img镜像，然后重新烧写
重启开发板，看软件是否能够实现自启动
系统启动完毕，还可以手动挂接虚拟机的网络文件系统，进行软件调试：
一旦系统自启动完毕，进入开发板的终端，输入挂接命令：
mount –t nfs –o nolock 192.168.1.8:/opt/rootfs /mnt/  //挂接虚拟机的网络文件系统，挂接到开发板的mnt目录，以后开发板访问mnt目录就是在访问虚拟的/opt/rootfs目录，实现远程的软件测试，不需要为了更新一个软件而重新烧写镜像文件！
cd /mnt/
ls
以更新ehome和rootfs.img为例：
首先将要更新的ehome和rootfs.img拷贝到/opt/rootfs
cp /opt/project/ehome/ehome  /opt/rootfs
cp /opt/rootfs.img /opt/rootfs
开发板执行mount挂接网络；
cp /mnt/ehome  /home/appbin/  //更新ehome
flash_erase /dev/mtd2 0 0
nandwrite –p  /dev/mtd2 /mnt/rootfs.img //更新rootfs.img
利用mtd工具烧写u-boot.bin,zImage,rootfs.img,userdata.img镜像文件:
mtd烧写工具：flash_erase,nandwrite,nanddump等


九、工作的经历的时间表
        2013.7 ~ 2016.6 上海
                2013.9 ~ 2014.3  TCP/IP即时通讯软件
                2014.3 ~ 2015.1  租赁计时计费
                2015.3 ~ 2016.6  智能社区

        2016.8 ~ 2018.7 广州 广州做驱动程序开发
                2016.8 ~ 2018.7  基于imx6q平台开发
                2016.8 ~ 2018.7  基于omap3530平台的开发

十、熟练使用的工具
    git、tftp、nfc、ssh、minicom、vim、qtcreator、virtual box，df，du
        git的常用操作
        tftp的传输
        nfs的使用
        ssh的使用
        vim的常用操作，配置，文本的批量操作
        qtcreator的集成开发环境的配置
        虚拟机的使用

十一、关注的科技新闻
    ARM，AI、AR、VR、区块链、云服务

十二、工作感受

十三、读过的书，作者、博客
        精通linux驱动设备的开发
        linux设备驱动程序 第三版 2.6.x
        linux内核的设计与实现
        linux系统编程
        qt快速入门
        unix编程艺术
        shell编程

十四、调试过程中遇到的问题
        与FPGA的联调, EIM接口的调试，SPI接口的调试(时序与片选有关)
        DMA驱动的调试
        opengles2.0的移植，环境整体不一样
        更新FPGA程序的调试, 字节的8位需反向, 需单片机的协助
        FPGA对SPI更新的影响(由于人员更换，FPGA代码重构，
                FPGA的一个引脚被配置为输出所引起的SPI的数据输出信号
                电平处于2.2v，ARM无法识别数据所致)

