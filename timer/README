定时器Timer应用场景非常广泛，在Linux下，有以下几种方法：

1，使用sleep()和usleep()
其中sleep精度是1秒，usleep精度是1微妙，具体代码就不写了。使用这种方法缺点
比较明显，在Linux系统中，sleep类函数不能保证精度，尤其在系统负载比较大时，
sleep一般都会有超时现象。

2，使用信号量SIGALRM + alarm()
这种方式的精度能达到1秒，其中利用了linux系统的信号量机制，首先注册信号量
SIGALRM处理函数，调用alarm()，设置定时长度，代码：alarm.c
alarm方式虽然很好，但是无法首先低于1秒的精度。

3，使用RTC机制
RTC机制利用系统硬件提供的Real Time Clock机制，通过读取RTC硬件/dev/rtc，
通过ioctl()设置RTC频率，代码 : rtc.c
这种方式比较方便，利用了系统硬件提供的RTC，精度可调，而且非常高。

4，使用select()
这种方法在看APUE神书时候看到的，方法比较冷门，通过使用select()，来设置定时
器；原理利用select()方法的第5个参数，第一个参数设置为0，三个文件描述符集都
设置为NULL，第5个参数为时间结构体，代码：select.c
这种方法精度能够达到微妙级别，网上有很多基于select()的多线程定时器，说明
select()稳定性还是非常好。

总结：如果对系统要求比较低，可以考虑使用简单的sleep()，毕竟一行代码就能解决
；如果系统对精度要求比较高，则可以考虑RTC机制和select()机制。

